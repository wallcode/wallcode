<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>wallleap</title>
  <meta charset="UTF-8">
  <meta name="description" content="luwang的博客，正在努力学习💪">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/favicon.png" type="image/png" />
  <meta name="description" content="luwang的博客，正在努力学习💪">
<meta property="og:type" content="website">
<meta property="og:title" content="wallleap">
<meta property="og:url" content="https://blog.wallleap.cn/index.html">
<meta property="og:site_name" content="wallleap">
<meta property="og:description" content="luwang的博客，正在努力学习💪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Luwang">
<meta property="article:tag" content="wallleap">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/nexmoe/nexmoe.github.io@latest/css/style.css,npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css" crossorigin>
  
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1721693_jg94kndwhe.css">
  
  <link rel="stylesheet" href="/css/style.css?v=1599833537936">

   
    <style>
      .nexmoe-avatar img:hover {
        -webkit-transform: rotateZ(360deg);
        -moz-transform: rotateZ(360deg);
        transform: rotateZ(360deg);
      }	
    </style>
  

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
<script src="https://cdn.jsdelivr.net/gh/wallleap/live2d-widget@latest/autoload.js"></script> 
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/busuanzi.pure.mini.js"></script>

<link rel="stylesheet" href="/css/github-badge.css">
<link rel="stylesheet" href="/css/tags_ca.css">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
  .pace .pace-progress {  background: rgb(254, 27, 115); /*进度条颜色*/
  height: 3px;  }
  .pace .pace-progress-inner {  box-shadow: 0 0 10px #ff0000, 0 0 5px     #ff0000; /*阴影颜色*/
  }
  .pace .pace-activity {  border-top-color: rgb(251, 30, 30);    /*上边框颜色*/
  border-left-color: rgb(251, 30, 30);    /*左边框颜色*/
}
</style>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Luwang" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/custom/avatar.jpg" alt="Luwang"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Luwang">
            <img src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/custom/avatar.jpg" alt="Luwang" alt="Luwang">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>54</div>
        <div><span>标签</span>57</div>
        <div><span>分类</span>25</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/categories" title="文章分类">
            <i class="mdui-list-item-icon nexmoefont icon-appstore-fill"></i>
            <div class="mdui-list-item-content">
                文章分类
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/friends.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:wallleap.cn" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/157360395" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
            <!-- <i class="fa icon-bilibili"></i> -->
        </a><a class="mdui-ripple" href="https://github.com/wallleap/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
            <!-- <i class="fa icon-github"></i> -->
        </a><a class="mdui-ripple" href="https://github.com/wallleap/" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(0 , 0, 252);background-color: rgba(0, 0, 252, .15);">
            <i class="nexmoefont icon-QQ"></i>
            <!-- <i class="fa icon-QQ"></i> -->
        </a><a class="mdui-ripple" href="https://github.com/wallleap/" target="_blank" mdui-tooltip="{content: '微信公众号'}" style="color: rgb(0, 229, 105);background-color: rgba(0, 229, 105, .15);">
            <i class="nexmoefont icon-wechat-fill"></i>
            <!-- <i class="fa icon-wechat-fill"></i> -->
        </a><a class="mdui-ripple" href="https://github.com/wallleap/" target="_blank" mdui-tooltip="{content: '我的邮箱'}" style="color: rgb(245, 0, 0);background-color: rgba(245, 0, 0, .15);">
            <i class="nexmoefont icon-mail-fill"></i>
            <!-- <i class="fa icon-mail-fill"></i> -->
        </a><a class="mdui-ripple" href="https://github.com/wallleap/" target="_blank" mdui-tooltip="{content: '我的微博'}" style="color: rgb(245, 0, 0);background-color: rgba(245, 0, 0, .15);">
            <i class="nexmoefont icon-weibo"></i>
            <!-- <i class="fa icon-weibo"></i> -->
        </a><a class="mdui-ripple" href="https://github.com/wallleap/" target="_blank" mdui-tooltip="{content: 'RSS'}" style="color: rgb(252, 129, 0);background-color: rgba(252, 129, 0, .15);">
            <i class="nexmoefont icon-rss"></i>
            <!-- <i class="fa icon-rss"></i> -->
        </a> 
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/ACL/" style="font-size: 10px;">ACL</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/AngularJS/" style="font-size: 10px;">AngularJS</a> <a href="/tags/Blog/" style="font-size: 17.14px;">Blog</a> <a href="/tags/C-C/" style="font-size: 11.43px;">C/C++</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ES/" style="font-size: 10px;">ES</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitHub/" style="font-size: 15.71px;">GitHub</a> <a href="/tags/HCL/" style="font-size: 15.71px;">HCL</a> <a href="/tags/HCNA/" style="font-size: 15.71px;">HCNA</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 17.14px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 14.29px;">JavaScript</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/NAT/" style="font-size: 10px;">NAT</a> <a href="/tags/NodeJS/" style="font-size: 10px;">NodeJS</a> <a href="/tags/OSPF/" style="font-size: 10px;">OSPF</a> <a href="/tags/RIP/" style="font-size: 10px;">RIP</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/STP/" style="font-size: 10px;">STP</a> <a href="/tags/Sakura/" style="font-size: 10px;">Sakura</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/VLAN/" style="font-size: 10px;">VLAN</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/Win10/" style="font-size: 10px;">Win10</a> <a href="/tags/eNSP/" style="font-size: 15.71px;">eNSP</a> <a href="/tags/eNsp/" style="font-size: 11.43px;">eNsp</a> <a href="/tags/hackintosh/" style="font-size: 10px;">hackintosh</a> <a href="/tags/hexo/" style="font-size: 11.43px;">hexo</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/w650dc/" style="font-size: 10px;">w650dc</a> <a href="/tags/web/" style="font-size: 18.57px;">web</a> <a href="/tags/%E4%B8%BB%E9%A2%98/" style="font-size: 12.86px;">主题</a> <a href="/tags/%E4%BA%94%E7%AC%94/" style="font-size: 10px;">五笔</a> <a href="/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA/" style="font-size: 10px;">交换机</a> <a href="/tags/%E4%BC%81%E4%B8%9A%E7%BD%91/" style="font-size: 10px;">企业网</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%8D%8E%E4%B8%89/" style="font-size: 15.71px;">华三</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 17.14px;">博客</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 11.43px;">后端</a> <a href="/tags/%E5%9B%BE%E9%9B%86/" style="font-size: 10px;">图集</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 10px;">安装</a> <a href="/tags/%E5%AE%9E%E9%AA%8C/" style="font-size: 12.86px;">实验</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 10px;">微信</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E9%98%B2%E7%9B%97%E9%93%BE/" style="font-size: 10px;">微信防盗链</a> <a href="/tags/%E6%82%A6%E8%AF%BB/" style="font-size: 10px;">悦读</a> <a href="/tags/%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">技术</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">框架</a> <a href="/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 10px;">模块化</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 10px;">考研</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 10px;">英语</a> <a href="/tags/%E9%80%86%E6%B0%B4%E5%AF%92/" style="font-size: 10px;">逆水寒</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 12.86px;">配置</a> <a href="/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/" style="font-size: 10px;">黑苹果</a>
    </div>
    
      <script>
        var maxTagcloud = parseInt(10);
        var tags_length = parseInt(57);
        var tags_arr = [];
        for(var i = 0; i < tags_length; i++){
          tags_arr.push(i);
        }
        tags_arr.sort(function (l, r) {
          return Math.random() > 0.5 ? -1 : 1;
        });
        tags_arr = tags_arr.slice(0, maxTagcloud < tags_length ? tags_length - maxTagcloud : 0);
        for(var tag_i = 0; tag_i < tags_arr.length; tag_i++){
          document.getElementById("randomtagcloud").children[tags_arr[tag_i]].style.display = 'none';
        }
      </script>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li></ul>
    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2020/08/28/VUE/">Vue学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/08/20/AJAX/">Ajax学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/07/12/React/">React全家桶(技术栈)学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/07/04/Git/">Git学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/06/14/nodejs/">NodeJs学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
    <!-- <div class="nexmoe-copyright">
        &copy; 2020 Luwang
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div> -->
    <div style="text-align: center;">
        <div class="github-badge">
            <a rel="license" href="https://github.io/" target="_blank" title="静态网页托管于Github">
            <span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen"><i class="fa fa-github" aria-hidden="true"></i> Github</span></a>
        </div>
        <div class="github-badge">
            <a rel="license" href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank" title="站点使用 Sakura 主题，作者：Mashiro & Hojun">
            <span class="badge-subject"><i class="fa fa-themeisle" aria-hidden="true"></i> Theme</span><span class="badge-value bg-theme">nexmoe</span></a>
        </div><br />
        <div class="github-badge">
            <span class="badge-subject"><i class="fa fa-user" aria-hidden="true"></i> UV</span>
            <span  class="badge-value bg-orange" id="busuanzi_value_site_uv"></span>
        </div>
        <div class="github-badge">
            <span class="badge-subject"><i class="fa fa-eye" aria-hidden="true"></i> PV</span>
            <span class="badge-value bg-brightgreen" id="busuanzi_value_site_pv"></span>
        </div>
    </div>
    <div class="site-img" style="margin: 20px 0 20px 16px;">
        <a href="#"><img width="200px" src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/wechat/wallleap.bmp"></a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">

        <div class="wallleap" data-spotlight="wallleap">wallleap</div>
        <style>
        .wallleap {
            display: block;
            margin: 10px auto;
            padding-left: 300px;
            text-align: center;
            color: #eee;
            font-size: 80px;
            font-family:Helvetica;
        }
        .wallleap::after {
            content: attr(data-spotlight);
            color: transparent;
            position: relative;
            left: -3.6em;
            -webkit-clip-path: ellipse(29px 29px at 0% 50%);
            clip-path: ellipse(29px 29px at 0% 50%);
            animation: spotlight 6s infinite;
            background-image: linear-gradient(to right, skyblue, red, #ff1c74, black);
            background-size: 150%;
            background-position: center center;
            -webkit-background-clip: text;
            background-clip: text;
        }
        @keyframes spotlight{
            0%{
            -webkit-clip-path: ellipse(29px 29px at 0% 50%);
            clip-path: ellipse(29px 29px at 0% 50%);
            }
            50%{
            -webkit-clip-path: ellipse(29px 29px at 100% 50%);
            clip-path: ellipse(29px 29px at 100% 50%);
            }
            100%{
            -webkit-clip-path: ellipse(29px 29px at 0% 50%);
            clip-path: ellipse(29px 29px at 0% 50%);
            }
        }
        </style>
        
        <div  style="font-size: 32px; margin-bottom: 20px; text-align: center; color: rgb(208, 67, 121);"><i class="fa fa-ravelry" aria-hidden="true"></i>每日一句</div>
        <i class="fa fa-volume-up" aria-hidden="true"></i>      <span id="hitokoto" style="margin-left:5px;"> :D 获取中...</span>
        <p align="right" id="afrom"></p>
        <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
        <script>
          fetch('https://v1.hitokoto.cn/?c=h')
            .then(function (res){
              return res.json();
            })
            .then(function (data) {
              var hitokoto = document.getElementById('hitokoto');
              var afrom = document.getElementById('afrom');
              hitokoto.innerText = data.hitokoto;
              afrom.innerText =  '——【' + data.from + ' ' + data.from_who + '】';
            })
            .catch(function (err) {
              console.error(err);
            })
        </script>
        
        
        <div  style="font-size: 32px; margin-bottom: 20px; text-align: center; color: rgb(208, 67, 121);"><i class="fa fa-music" aria-hidden="true"></i>欣赏音乐</div>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
        <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
        <!-- require MetingJS -->
        <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
        
        <meting-js
            server="netease"
            type="playlist"
            id="2162711186"
          list-folded="true">
        </meting-js>
        


    <div  style="font-size: 32px; margin-bottom: 20px; text-align: center; color: rgb(208, 67, 121);"><i class="fa fa-pied-piper" aria-hidden="true"></i>文章列表</div>
    
    <div class="nexmoe-post">
        <a href="/2020/08/28/VUE/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="Vue学习笔记" class="lazyload">
                    <h1>Vue学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年08月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>13.9k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 69 分钟</a>
        </div>

        <article>
            
                <h2 id="一、Vue概述"><a href="#一、Vue概述" class="headerlink" title="一、Vue概述"></a>一、Vue概述</h2><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><h4 id="1-1-1-前端开发模式的发展"><a href="#1-1-1-前端开发模式的发展" class="headerlink" title="1.1.1 前端开发模式的发展"></a>1.1.1 前端开发模式的发展</h4><ol>
<li>静态页面</li>
</ol>
<ul>
<li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容。</li>
</ul>
<ol start="2">
<li>异步刷新，操作DOM</li>
</ol>
<ul>
<li>1995年，网景工程师Brendan Eich花了10天时间设计了JavaScript语言。<ul>
<li>随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态地效果，但是依然是以静态为主。</li>
</ul>
</li>
<li>ajax盛行：<ul>
<li>2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。</li>
<li>此时的开发人员不仅需要编写HTML样式，还要动ajax与后端交互，然后通过js操作DOM元素来实现页面动态效果。比较流行的框架如jQuery就是典型代表。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>MVVM，关注模型和视图</li>
</ol>
<ul>
<li>2008年，Google的Chrome发布，随后就以极快的速度占领市场，超过IE称为浏览器市场的主导者。</li>
<li>2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。<ul>
<li>基于事件循环的异步IO</li>
<li>单线程运行，避免多线程的变量同步问题</li>
<li>js可以编写后台diamante，前后台统一编程语言</li>
</ul>
</li>
<li>Node.js的伟大之处不在于让js迈向了后端开发，而是构建了一个庞大的生态系统。</li>
<li>2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循CommonJS规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界上最大的包模块管理系统。</li>
<li>随后，在Node的基础上，涌现了一大批的前端框架：</li>
</ul>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827092819.png" alt="image-20200827092403465" class="lazyload"></p>
<h4 id="1-1-2-MVVM模式"><a href="#1-1-2-MVVM模式" class="headerlink" title="1.1.2 MVVM模式"></a>1.1.2 MVVM模式</h4><p>M：Model，模型，包括数据和一些基本操作</p>
<p>V：View，视图，页面渲染结果</p>
<p>VM：View-Model，模型与视图间的双向操作(无需开发人员干涉)</p>
<p>在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。</p>
<p>而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何相互影响的：</p>
<ul>
<li>只要Model发生了改变，View上自然就会表现出来。</li>
<li>当用户修改了View，Model中的数据也会跟着改变。</li>
</ul>
<p>把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827093743.png" alt="" class="lazyload"></p>
<p>MVVM通过<strong>视图</strong>与<strong>模型</strong>的<strong>双向绑定</strong>，简化前端操作。</p>
<p>Vue就是一款MVVM模式的框架</p>
<h3 id="1-2-认识Vue"><a href="#1-2-认识Vue" class="headerlink" title="1.2 认识Vue"></a>1.2 认识Vue</h3><blockquote>
<p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</blockquote>
<ul>
<li>前端框架三巨头：Vue.js、React.js、Angular.js，Vue.js以其轻量易用著称，Vue.js和React.js发展速度最快。</li>
<li>遵循 MVVM 模式  </li>
<li>渐进式 JavaScript 框架  <ul>
<li>渐进式：可以<strong>选择性</strong>地使用该框架的一个或一些组件，这些组件的使用也不需要将框架全部组件都应用，而且用了这些组件也不要求你的系统全部都使用该框架。</li>
</ul>
</li>
<li>中文官网：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></li>
<li>英文官网：<a href="https://vuejs.org/" target="_blank" rel="noopener">https://vuejs.org/</a></li>
<li>参考：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li>
<li>作用: 动态构建用户界面  </li>
<li>特点：<ul>
<li>易用</li>
<li>灵活</li>
<li>高效</li>
</ul>
</li>
<li>编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发  </li>
<li>它本身只关注 UI, 可以轻松引入 vue 插件或其它第三库开发项目  </li>
<li>GitHub地址：<a href="https://github.com/vuejs" target="_blank" rel="noopener">https://github.com/vuejs</a></li>
<li>作者：<a href="https://github.com/yyx990803" target="_blank" rel="noopener">尤雨溪</a>(一位华裔前 Google 工程师)，Vue.js创作者，Vue Technology创始人，致力于Vue的研究开发。</li>
</ul>
<h3 id="1-3-与其它前端JS框架的关联"><a href="#1-3-与其它前端JS框架的关联" class="headerlink" title="1.3 与其它前端JS框架的关联"></a>1.3 与其它前端JS框架的关联</h3><ul>
<li>借鉴 angular 的<strong>模板</strong>和<strong>数据绑定</strong>技术</li>
<li>借鉴 react 的<strong>组件化</strong>和<strong>虚拟 DOM</strong> 技术  </li>
</ul>
<h3 id="1-4-Vue扩展插件"><a href="#1-4-Vue扩展插件" class="headerlink" title="1.4 Vue扩展插件"></a>1.4 Vue扩展插件</h3><ul>
<li>vue-cli: vue 脚手架</li>
<li>vue-resource(axios): ajax 请求</li>
<li>vue-router: 路由</li>
<li>vuex: 状态管理</li>
<li>vue-lazyload: 图片懒加载</li>
<li>vue-scroller: 页面滑动相关</li>
<li>mint-ui: 基于 vue 的 UI 组件库(移动端)</li>
<li>element-ui: 基于 vue 的 UI 组件库(PC 端)  </li>
</ul>
<h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><p>搭建示例工程</p>
<h3 id="2-1创建工程"><a href="#2-1创建工程" class="headerlink" title="2.1创建工程"></a>2.1创建工程</h3><p>创建一个目录，例如：<code>testVue</code></p>
<h3 id="2-2-引入Vue"><a href="#2-2-引入Vue" class="headerlink" title="2.2 引入Vue"></a>2.2 引入Vue</h3><ul>
<li><p>使用CDN(使用jsdelivr，也可以到bootcdn中找)</p>
<ul>
<li>开发版(包含了有帮助的命令行警告)：<a href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a></li>
<li>生产版(压缩了，优化了尺寸和速度)：<a href="https://cdn.jsdelivr.net/npm/vue" target="_blank" rel="noopener">https://cdn.jsdelivr.net/npm/vue</a></li>
</ul>
<pre><code class="html">&lt;!-- 引入 --&gt;
&lt;script src=&quot;https://……&quot;&gt;&lt;/script&gt;</code></pre>
</li>
</ul>
<ul>
<li><p>下载到本地</p>
<ul>
<li>下载地址：<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></li>
<li>下载release版：<a href="https://github.com/vuejs/vue/archive/v2.6.11.zip，解压之后在`dist`目录中可以看到`vue.js`文件" target="_blank" rel="noopener">https://github.com/vuejs/vue/archive/v2.6.11.zip，解压之后在`dist`目录中可以看到`vue.js`文件</a></li>
</ul>
<pre><code class="html">&lt;!-- 引入 --&gt;
&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</code></pre>
</li>
</ul>
<ul>
<li><p><strong>npm安装</strong>(推荐)</p>
<ul>
<li>进入工程目录：<code>cd testVue</code></li>
<li>初始化项目：<code>npm init -y</code></li>
<li>下载安装Vue：<code>npm install vue --save</code></li>
</ul>
</li>
</ul>
<h3 id="2-3、演示双向绑定与事件处理"><a href="#2-3、演示双向绑定与事件处理" class="headerlink" title="2.3、演示双向绑定与事件处理"></a>2.3、演示双向绑定与事件处理</h3><p>需求：创建testVue.html页面并初始化Vue实例，通过console修改Vue数据实现双向绑定效果和创建按钮实现点击自增效果。</p>
<ul>
<li>创建页面，初始化Vue</li>
<li><code>{ {} }</code>获取显示数据</li>
<li><code>v-model</code>实现<strong>双向绑定</strong></li>
<li><code>v-on</code>演示<strong>事件处理</strong></li>
</ul>
<p>在刚刚<code>testVue</code>目录中新建<code>testVue.html</code>文件，书写代码，测试初始化Vue实例、<code>{ {} }</code>使用</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;!-- 引入vue.js
        1. cdn
        2. 下载后本地引入
        3. npm安装后从node_modules中引入(项目中import引入)
    --&gt;
    &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;{{name}}&lt;/h2&gt;  &lt;!-- 插值 --&gt;
        &lt;p&gt;渐进式JavaScript框架&lt;/p&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        /* 创建Vue实例，在里面可以指定一些vue的参数 */
        var app = new Vue({ // 键值对
            el: &quot;#app&quot;, // 指定需要渲染的元素
            data:{ // 指定数据
                name: &quot;Vue.js&quot;
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>在控制台输入命令：</p>
<pre><code class="javascript">app.name=&quot;Vue&quot;</code></pre>
<p>Vue.js也会变成Vue</p>
<p>测试<code>v-model</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;!-- 模型 --&gt;
        &lt;h2&gt;{{name}} 创建 {{num}} 年了&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var app = new Vue({
            el: &quot;#app&quot;,
            data:{
                name: &quot;Vue.js&quot;,
                num: 5
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>修改文本框中的值，下面的xx年也会变(模型改变，视图也改变；视图改变也会影响对应的模型)，控制台中也能修改</p>
<p>上面的演示的是双向绑定，下面接着演示事件处理</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;!-- 模型 --&gt;
        &lt;h2&gt;{{name}} 创建 {{num}} 年了&lt;/h2&gt;
        &lt;button v-on:click=&quot;num++&quot;&gt;num+1&lt;/button&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var app = new Vue({ 
            el: &quot;#app&quot;,
            data:{
                name: &quot;Vue.js&quot;,
                num: 5
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>点击按钮，num会自增</p>
<h2 id="三、Vue实例"><a href="#三、Vue实例" class="headerlink" title="三、Vue实例"></a>三、Vue实例</h2><p>在创建Vue实例的时候可以指定模板id、数据和方法；而如果要在实例化、模板渲染的过程中需要执行一些其他操作的话，那么可以使用生命周期钩子函数</p>
<h3 id="3-1-创建Vue实例"><a href="#3-1-创建Vue实例" class="headerlink" title="3.1 创建Vue实例"></a>3.1 创建Vue实例</h3><p>每个Vue应用都是通过用<code>Vue</code>函数创建一个新的<strong>Vue实例</strong>开始的(常用变量vm——ViewModel接收)</p>
<pre><code class="javascript">var vm = new Vue({ // 传入的参数——对象
  // 选项
})</code></pre>
<p>在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括：</p>
<ul>
<li><p>el：指定一个页面元素，受Vue实例的管理，只有被Vue实例管理的元素内部才能使用Vue的语法。</p>
</li>
<li><p>data：定义Vue实例中使用到的数据，本身就是一个对象，里面的键值对可以随意写。使用时可以直接<code>vm.msg</code>使用这个数据(不需要<code>vm.data.msg</code>)，在声明周期钩子函数中使用<code>this.msg</code>。</p>
</li>
<li><p>methods：定义Vue实例的一些函数</p>
</li>
<li><p>computed：计算属性，可以将一些属性数据经过方法处理之后返回。</p>
</li>
<li><p>watch：监控属性，可以指定一些方法，监控指定的值的变化。</p>
<ul>
<li><p>监控简单数据：定义一个和监控的变量名称一致的函数即可，函数的参数为新值和旧值。例如，要监控data中的message，在watch中<code>message(newValue,oldValue){}</code></p>
</li>
<li><p>监控对象中的数据——深度监控：定义一个和监控的对象名称一致的属性，值是一个对象。内部设置deep属性为true代表深度监控开启，回调函数为handler，会传过来新的对象，例如：</p>
<pre><code class="javascript">watch:{
  person: {
    /* 开启深度监控，监控对象中的属性值变化 */
    deep: true,
    // 可以获取到最新的对象属性数据
    handler(obj){
     console.log(&quot;姓名：&quot; + obj.name + &quot;,年龄：&quot; + obj.age)
  }
}</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>template</p>
</li>
<li><p>声明周期钩子函数名(ES6语法<code>created: function(){}</code>简化为<code>created(){}</code>)，本质仍是键值对</p>
</li>
<li><p>…</p>
</li>
</ul>
<h3 id="3-2-模板或元素"><a href="#3-2-模板或元素" class="headerlink" title="3.2 模板或元素"></a>3.2 模板或元素</h3><p>每个Vue实例都需要关联一段HTML模板，Vue会基于此模板进行视图渲染；可以通过el属性来指定。</p>
<p>例如一段HTML模板：</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;

&lt;/div&gt;</code></pre>
<p>然后创建Vue实例，关联这个div</p>
<pre><code class="javascript">var vm = new Vue({
  el: &quot;#app&quot;
})</code></pre>
<p>这样，Vue就可以基于id为app的div元素作为模板进行渲染了，在这个div范围以外的部分是无法使用vue特性的。</p>
<h3 id="3-3-数据"><a href="#3-3-数据" class="headerlink" title="3.3 数据"></a>3.3 数据</h3><p>当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且<strong>监视</strong>data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式”系统。</p>
<p>例如在HTML中模型指定name</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt;
&lt;/div&gt;</code></pre>
<p>js中vue的data属性设置一个name</p>
<pre><code class="javascript">var vm = new Vue({
  el: &quot;#app&quot;,
  data:{
    name: &quot;Vue.js&quot;
  }
})</code></pre>
<ul>
<li>name的变化会影响到input的值</li>
<li>input中输入的值，也会导致vm中的name发生改变</li>
</ul>
<h3 id="3-4-方法"><a href="#3-4-方法" class="headerlink" title="3.4 方法"></a>3.4 方法</h3><p>Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。</p>
<p>例如HTML模板中指定v-on事件click之后执行的代码(可以是一个语句也可以是个函数)</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;button v-on:click=&quot;add&quot;&gt;add&lt;/button&gt;
&lt;/div&gt;</code></pre>
<p>在创建实例时到methods属性中定义add方法</p>
<pre><code class="javascript">var vm = new Vue({
  el: &quot;#app&quot;,
  data:{},
  methods:{
    add: function(){
      console.log(&quot;add被点击了&quot;)
    }
  }
})</code></pre>
<h3 id="3-5-声明周期及钩子函数"><a href="#3-5-声明周期及钩子函数" class="headerlink" title="3.5 声明周期及钩子函数"></a>3.5 声明周期及钩子函数</h3><h4 id="3-5-1-声明周期"><a href="#3-5-1-声明周期" class="headerlink" title="3.5.1 声明周期"></a>3.5.1 声明周期</h4><blockquote>
<p>每个Vue实例在被创建时都要经过一系列的初始化过程——创建实例、装载模板、渲染模板等，Vue为生命周期中的每个状态都设置了钩子函数(监听函数)，每当Vue实例处于不同的声明周期时，对应的函数就会被触发调用。</p>
</blockquote>
<p>所有的生命周期钩子自动绑定<code>this</code>上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你<strong>不能使用箭头函数来定义一个声明周期方法</strong>(比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>)，因为箭头函数的 <code>this</code>与你期待的Vue实例不同，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
<p>声明周期：</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827121350.png" alt="" class="lazyload"></p>
<p>实例化——&gt;挂载——&gt;销毁    (如果使用构建步骤，模板编译会提前执行，例如单文件组件)</p>
<p>钩子函数会在Vue实例的各个声明周期阶段自动调用，具体有：</p>
<p>(1) 初始化显示：</p>
<ul>
<li><code>beforeCreate</code>：在实例初始化之后，数据观测(data observer)和event/watcher事件配置之前被调用。</li>
<li><strong><code>created</code></strong>：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。</li>
<li><code>beforeMount</code>：在挂载开始之前被调用。相关的render函数首次被调用。</li>
<li><strong><code>mounted</code></strong>：el被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素。当mounted被调用时<code>vm.$el</code>也在文档内。[vm.$el：Vue实例使用的根DOM元素]</li>
</ul>
<p>(2) 更新状态：(<code>this.xxx=value</code>)</p>
<ul>
<li><code>beforeUpdate</code>：数据更新时调用，发生在虚拟DOM打补丁之前，这里适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器。</li>
<li><code>updated</code>：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个 钩子被调用时，组件DOM已经更新，所以此时可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，如果要相应状态改变，通常最好使用计算属性或watcher取而代之。</li>
</ul>
<p>(3) 销毁Vue实例：(<code>vm.$destory()</code>)</p>
<ul>
<li><strong><code>beforeDestroy</code></strong>：实例在销毁之前调用。在这一步，实例仍然完全可用。</li>
<li><code>destroyed</code>：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<p>[vm.$root：当前组件树的根Vue实例，如果当前实例没有父实例，此实例将会是其自己]</p>
<h4 id="3-5-2-钩子函数"><a href="#3-5-2-钩子函数" class="headerlink" title="3.5.2 钩子函数"></a>3.5.2 钩子函数</h4><p>例如：created代表在Vue实例创建后</p>
<p>可以在Vue中定义一个created函数，代表这个时期的构造函数：</p>
<p>创建页面<code>vueLifCycle.html</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js声明周期钩子created测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;{{msg}}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                msg: &quot;&quot;
            },
            // 钩子函数
            created(){
                this.msg = &quot;Hello Vue.js created&quot;
                console.log(this)
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>created常用于<strong>数据的初始化</strong>，即发送ajax，获取后台数据，给data属性中的数据进行赋值，接着在模板中应用数据，视图也会发生改变，从而实现数据的异步加载。</p>
<p>mounted发送 ajax 请求, 启动定时器等异步任务  </p>
<p>beforeDestory做收尾工作, 如: 清除定时器  </p>
<h4 id="3-5-3-this"><a href="#3-5-3-this" class="headerlink" title="3.5.3 this"></a>3.5.3 this</h4><p>打印的this(这个Vue实例对象)如下：</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827155040.png" alt="image-20200827155038198" class="lazyload"></p>
<h2 id="四、指令"><a href="#四、指令" class="headerlink" title="四、指令"></a>四、指令</h2><p>指令(Directives)是带有<code>v-</code>前缀的特殊属性。例如在入门案例中的v-model，代表双向绑定。</p>
<h3 id="4-1-插值表达式"><a href="#4-1-插值表达式" class="headerlink" title="4.1 插值表达式"></a>4.1 插值表达式</h3><h4 id="4-1-1-大括号"><a href="#4-1-1-大括号" class="headerlink" title="4.1.1 大括号"></a>4.1.1 大括号</h4><ul>
<li><p>格式：<code></code></p>
</li>
<li><p>说明：</p>
<ul>
<li>该表达式支持<strong>JS语法</strong>，可以调用js内置函数(必须有<strong>返回值</strong>)</li>
<li>表达式必须有返回结果。例如<code>1+1</code>，没有结果的表达式不允许使用，如<code>var a = 1 + 1</code></li>
<li>可以直接获取Vue实例data中定义的<strong>数据或函数</strong></li>
<li>可以直接写<code>&quot;&quot;</code></li>
</ul>
</li>
<li><p>示例：</p>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js插值表达式测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;{{msg}}&lt;/h2&gt;
    &lt;h2&gt;{{"说的没错"}}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                msg: &quot;Vue.js 轻便好用&quot;
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="4-1-2-插值闪烁"><a href="#4-1-2-插值闪烁" class="headerlink" title="4.1.2 插值闪烁"></a>4.1.2 <del>插值闪烁</del></h4><p>使用<code>{ {} }</code>方式在网速较慢的时候会出现问题，在数据未加载完成时，页面会显示出原始的<code></code>，加载完毕后才显示正确数据，这种情况称为插值闪烁(在最新的Vue中几乎没有这个问题)。</p>
<p>在以前版本中，出现插值闪烁，可以使用v-text、v-html解决。</p>
<h4 id="4-1-3-v-text和v-html"><a href="#4-1-3-v-text和v-html" class="headerlink" title="4.1.3 v-text和v-html"></a>4.1.3 v-text和v-html</h4><ul>
<li><p>使用v-text和v-html指令来代替<code>{ {} }</code></p>
</li>
<li><p>说明：</p>
<ul>
<li><code>v-text</code>：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出</li>
<li><code>v-html</code>：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染</li>
</ul>
</li>
<li><p>示例：</p>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js v-html/v-text测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2 v-text=&quot;msg&quot;&gt;&lt;/h2&gt;
        &lt;h2 v-html=&quot;msg&quot;&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                msg: &quot;&lt;span style=&#39;color: red;&#39;&gt;Vue.js 很好用&lt;/span&gt;&quot;
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827164955.png" alt="image-20200827164954008" class="lazyload"></p>
<p><strong>插值</strong>可以使用在需要显示Vue实例数据的地方，可以在插值表达式中调用实例的属性和函数。</p>
<p>v-text和v-html的作用：可以将数据在模板中进行显示；区别：<strong>v-html</strong>会对内容中出现的HTML标签进行渲染，而<strong>v-text</strong>会将内容当作普通文本输出到元素里面。(有点像js中的innerHTML和innerText)</p>
<h3 id="4-2-v-model"><a href="#4-2-v-model" class="headerlink" title="4.2 v-model"></a>4.2 v-model</h3><p>刚才的v-text和v-html可以看做是<strong>单向绑定</strong>，数据影响了视图渲染，但是反过来就不行。接下来的v-model就是<strong>双向绑定</strong>的了，视图(View)和模型(Model)之间会相互影响。</p>
<p>既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model可以使用的元素有：</p>
<ul>
<li>input</li>
<li>select</li>
<li>textarea</li>
<li>checkbox</li>
<li>radio</li>
<li>components(Vue中的自定义组件)</li>
</ul>
<p>基本上除了最后一项，其它都是表单的输入项。</p>
<p>示例：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js v-model测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;C/C++&quot; v-model=&quot;language&quot; /&gt;C/C++ &lt;/label&gt;&lt;br&gt;
        &lt;label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;Java&quot; v-model=&quot;language&quot; /&gt;Java &lt;/label&gt;&lt;br&gt;
        &lt;label&gt;&lt;input type=&quot;checkbox&quot; value=&quot;PHP&quot; v-model=&quot;language&quot; /&gt;PHP &lt;/label&gt;&lt;br&gt;
        &lt;h2&gt;你选择了：{{language.join(", ")}}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                language: []
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827182301.gif" alt="demo" class="lazyload"></p>
<ul>
<li>多个<code>checkbox</code>对应一个model时，model的类型是一个<strong>数组</strong>，单个checkbox值是<strong>boolean类型</strong></li>
<li><code>radio</code>对应的值是input的<strong>value值</strong></li>
<li><code>input</code>和<code>textarea</code>默认对应的model是<strong>字符串</strong></li>
<li><code>select</code>单选对应<strong>字符串</strong>，多选对应也是<strong>数组</strong></li>
</ul>
<p>补充：插件Vue.js devtools</p>
<p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?utm_source=chrome-ntp-icon</a></p>
<h3 id="4-3-v-on"><a href="#4-3-v-on" class="headerlink" title="4.3 v-on"></a>4.3 v-on</h3><h4 id="4-3-1-基本用法"><a href="#4-3-1-基本用法" class="headerlink" title="4.3.1 基本用法"></a>4.3.1 基本用法</h4><p>在没有使用Vue之前，页面标签可以通过设置onXXX响应事件；在Vue中可以通过v-on指令响应事件(<strong>给页面元素绑定事件</strong>)。</p>
<p>语法：<code>v-on:事件名=&quot;js片段或函数名&quot;</code></p>
<p>简写语法：<code>@事件名=&quot;js片段或函数名&quot;</code></p>
<p>例如<code>v-on:click=&quot;add&quot;</code>可以简写为<code>@click=&quot;add&quot;</code></p>
<p>示例：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js v-on测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button v-on:click=&quot;num++&quot;&gt;增加&lt;/button&gt;
        &lt;button @click=&quot;decrement&quot;&gt;减少&lt;/button&gt;
        &lt;h2&gt;num的数值为 {{num}}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                num: 1
            },
            methods: {
                decrement: function(){
                    this.num--
                }
            },
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827184155.gif" alt="on" class="lazyload"></p>
<p>默认事件形参: <code>event</code><br>隐含属性对象: <code>$event</code></p>
<h4 id="4-3-2-事件修饰符"><a href="#4-3-2-事件修饰符" class="headerlink" title="4.3.2 事件修饰符"></a>4.3.2 事件修饰符</h4><p>在事件处理程序中调用<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>是非常常见的需求(阻止默认事件)。尽管我们可以在方法中轻松实现这点，但方法只有纯粹的数据逻辑，而不是去处理DOM事件细节。</p>
<p>为了解决这个问题，Vue.js为<code>v-on</code>提供了<strong>事件修饰符</strong>。修饰符是由点开头的指令后缀来表示的。</p>
<p>语法：<code>v-on:事件名.修饰符=&quot;js片段或函数名&quot;</code> 或 <code>@事件名.修饰符=&quot;js片段或函数名&quot;</code></p>
<p>常用修饰符：</p>
<ul>
<li><strong><code>.stop</code></strong>：阻止事件冒泡<ul>
<li>事件冒泡：默认情况下，在某个页面元素上触发的事件，在当前元素处理完之后会自动传递给祖先元素，祖先的相同事件也会执行</li>
</ul>
</li>
<li><strong><code>.prevent</code></strong>：阻止默认事件发生<ul>
<li>浏览器默认的一些事件行为，例如：<ul>
<li>获取焦点事件会把光标放入输入框</li>
<li>表单提交事件会提交数据到action指定的url</li>
<li>点击a标签会跳转到href指定的地址</li>
</ul>
</li>
</ul>
</li>
<li><code>.capture</code>：使用事件捕获模式<ul>
<li>相当于和冒泡相反，父元素先于子元素获取事件</li>
</ul>
</li>
<li><code>.self</code>：只有元素自身触发事件才执行(冒泡或捕获的都不执行)</li>
<li><code>.once</code>：只执行一次</li>
</ul>
<p>冒泡测试：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;事件冒泡测试&lt;/h2&gt;
        &lt;div v-on:click=&quot;print(&#39;点击了div&#39;)&quot; style=&quot;background: skyblue; width: 400px; height: 400px;&quot;&gt;
            &lt;button @click=&quot;print(&#39;点击了button&#39;)&quot;&gt;按钮&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                num: 1
            },
            methods: {
                print(str){
                    console.log(str)
                }
            },
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827190036.gif" alt="bubble" class="lazyload"></p>
<p>阻止冒泡：</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;h2&gt;阻止事件冒泡测试&lt;/h2&gt;
    &lt;div v-on:click=&quot;print(&#39;点击了div&#39;)&quot; style=&quot;background: skyblue; width: 400px; height: 400px;&quot;&gt;
        &lt;button @click.stop=&quot;print(&#39;点击了button&#39;)&quot;&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827190024.gif" alt="stopbubble" class="lazyload"></p>
<p>阻止默认事件：点击超链接不会跳转</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;阻止默认事件&lt;/h2&gt;
        &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;print(&#39;点击了a&#39;)&quot;&gt;百度&lt;/a&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                num: 1
            },
            methods: {
                print(str){
                    console.log(str)
                }
            },
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="4-3-3-按键修饰符"><a href="#4-3-3-按键修饰符" class="headerlink" title="4.3.3 按键修饰符"></a>4.3.3 按键修饰符</h4><ul>
<li><code>.keycode</code> : 操作的是某个 keycode 值的键</li>
<li><code>.keyName</code> : 操作的某个按键名的键(少部分)  </li>
</ul>
<pre><code class="html">&lt;h2&gt;3. 按键修饰符&lt;/h2&gt;
&lt;input @keyup.8=&quot;test&quot;&gt; &lt;!-- 按键8 --&gt;
&lt;input @keyup.enter=&quot;test&quot;&gt; &lt;!-- 按键enter --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
new Vue({
  el: &#39;#example&#39;,
  data: {
      name: &#39;Vue.js&#39;
  },
  methods: {
    test(event) {
          alert(event.keyCode + &#39;---&#39; + event.target.value)
      }
  }
})
&lt;/script&gt;</code></pre>
<h3 id="4-4-v-for"><a href="#4-4-v-for" class="headerlink" title="4.4 v-for"></a>4.4 v-for</h3><p>可以在Vue实例化的时候指定要遍历的数据，然后通过v-for指令在模板中遍历显示数据。一般情况下，要遍历的数据可以通过钩子函数created发送异步请求获取数据。</p>
<h4 id="4-4-1-遍历数组"><a href="#4-4-1-遍历数组" class="headerlink" title="4.4.1 遍历数组"></a>4.4.1 遍历数组</h4><ul>
<li>语法：<code>v-for=&quot;item in items&quot;</code><ul>
<li>items：要遍历的数组名或对象名，需要在Vue的data中定义好。</li>
<li>item：循环遍历</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;user in users&quot;&gt;
                我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                users:[
                    {&quot;name&quot;:&quot;唐僧&quot;,&quot;age&quot;:24,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:26,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;猪八戒&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;沙和尚&quot;,&quot;age&quot;:32,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;蜘蛛精&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;女&quot;}
                ]
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827200312.png" alt="image-20200827200311325" class="lazyload"></p>
<h4 id="4-4-2-数组角标"><a href="#4-4-2-数组角标" class="headerlink" title="4.4.2 数组角标"></a>4.4.2 数组角标</h4><p>在遍历的过程中，如果需要知道数组角标/索引号，可以指定第二个参数</p>
<ul>
<li>语法：<code>v-for=&quot;(item,index) in items&quot;</code><ul>
<li>items：要遍历的数组</li>
<li>item：遍历得到的数组元素别名</li>
<li>index：遍历到的当前元素索引，从0开始</li>
</ul>
</li>
<li>示例：</li>
</ul>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(user, index) in users&quot;&gt;
            {{index}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827200728.png" alt="image-20200827200727402" class="lazyload"></p>
<h4 id="4-4-3-遍历对象"><a href="#4-4-3-遍历对象" class="headerlink" title="4.4.3 遍历对象"></a>4.4.3 遍历对象</h4><p>v-for除了可以迭代数组，也可以迭代对象，语法基本类似</p>
<p>语法：</p>
<pre><code>v-for=&quot;value in object&quot;
v-for=&quot;(value,key) in object&quot;
v-for=&quot;(value,key,index) in object&quot;</code></pre><ul>
<li>1个参数时，得到的是对象的值</li>
<li>2个参数时，第一个是值，第二个是键</li>
<li>3个参数时，第三个是索引，从0开始</li>
</ul>
<p>示例：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(value, key, index) in person&quot;&gt;
                {{index}}——{{key}}——{{value}}
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                person:{&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:26,&quot;gender&quot;:&quot;男&quot;,&quot;address&quot;:&quot;花果山&quot;}
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200827201526.png" alt="image-20200827201525393" class="lazyload"></p>
<h4 id="4-4-4-key"><a href="#4-4-4-key" class="headerlink" title="4.4.4 key"></a>4.4.4 key</h4><p>当Vue.js用<code>v-for</code>正在更新已渲染过的元素列表时，它默认用”就地复用”策略。如果数据项的顺序被改变,，Vue 将不会移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元，并且确保它在特定索引下显示已被渲染过的每个元素。<br>如果使用key这个功能可以有效的提高渲染的效率; key一般使用在遍历完后，还要增、减集合元素的时候更有意义。<br>但是要实现这个功能，你需要给Vue-些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key 属性。理想的<code>key</code>值是每项都有的且唯一的id。也就是key是该项的唯一标识。</p>
<p>示例：</p>
<pre><code class="html">    &lt;ul&gt;
        &lt;li v-for=&quot;(user, index) in users&quot; :key=&quot;index&quot;&gt;
            {{index}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
        &lt;/li&gt;
    &lt;/ul&gt;</code></pre>
<p>这里使用了一个特殊的语法：<code>:key=&quot;&quot;</code>，它可以读取Vue中的属性，并赋值给key属性</p>
<p>这里绑定的key是数组的索引，是唯一的(以后可以加其他的唯一的数据，例如user.id)</p>
<h3 id="4-5-v-if和v-show"><a href="#4-5-v-if和v-show" class="headerlink" title="4.5 v-if和v-show"></a>4.5 v-if和v-show</h3><h4 id="4-5-1-基本使用"><a href="#4-5-1-基本使用" class="headerlink" title="4.5.1 基本使用"></a>4.5.1 基本使用</h4><p>v-if，条件判断，当得到的结果为true时，所在的元素才会被渲染。</p>
<p>语法：<code>v-if=&quot;布尔表达式&quot;</code></p>
<p>示例：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;show=!show&quot;&gt;按钮&lt;/button&gt;
        &lt;h2 v-if=&quot;show&quot;&gt;Hello Vue.js&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                show: true
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="4-5-2-与v-for结合"><a href="#4-5-2-与v-for结合" class="headerlink" title="4.5.2 与v-for结合"></a>4.5.2 与v-for结合</h4><p>当v-if和v-for一起出现的时候，v-for优先级更高，即会先遍历，再判断条件。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;女性人物&lt;/h2&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(user, index) in users&quot; v-if=&quot;user.gender==&#39;女&#39;&quot;&gt;
                {{index}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                users:[
                    {&quot;name&quot;:&quot;唐僧&quot;,&quot;age&quot;:24,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:26,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;猪八戒&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;沙和尚&quot;,&quot;age&quot;:32,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;蜘蛛精&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;女&quot;}
                ]
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="4-5-3-v-else"><a href="#4-5-3-v-else" class="headerlink" title="4.5.3 v-else"></a>4.5.3 v-else</h4><p>可以使用<code>v-else</code>指令来表示<code>v-if</code>的“else块”，需要注意，v-else元素必须紧跟在带有v-if或v-else-if的元素的后面，否则它将不会被识别(两者之间不能插入其他元素)</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;西游人物&lt;/h2&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(user, index) in users&quot; v-if=&quot;user.gender==&#39;女&#39;&quot; style=&quot;color:pink;&quot;&gt;
                {{index+1}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
            &lt;/li&gt;
            &lt;li v-else style=&quot;color:skyblue;&quot;&gt;
                {{index+1}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                users:[
                    {&quot;name&quot;:&quot;唐僧&quot;,&quot;age&quot;:24,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:26,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;猪八戒&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;沙和尚&quot;,&quot;age&quot;:32,&quot;gender&quot;:&quot;男&quot;},
                    {&quot;name&quot;:&quot;蜘蛛精&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;女&quot;}
                ]
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><code>v-else-if</code>，充当<code>v-if</code>的”else-if块“，可以连续使用(v-else-if也必须紧跟在带v-if或v-else-if的元素后)</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;h2&gt;西游人物&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(user, index) in users&quot; v-if=&quot;user.age&lt;20&quot; style=&quot;color:yellowgreen;&quot;&gt;
            {{index+1}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
        &lt;/li&gt;
        &lt;li v-else-if=&quot;user.age&lt;30&quot; style=&quot;color:skyblue;&quot;&gt;
            {{index+1}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
        &lt;/li&gt;
        &lt;li v-else style=&quot;color:yellow;&quot;&gt;
            {{index+1}}：我是{{user.name}}，今年{{user.age}}岁了，性别{{user.gender}}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;</code></pre>
<h4 id="4-5-4-v-show"><a href="#4-5-4-v-show" class="headerlink" title="4.5.4 v-show"></a>4.5.4 v-show</h4><p><code>v-show</code>也可以根据条件是否展示元素，例如：</p>
<pre><code class="html">&lt;h1 v-show=&quot;ok&quot;&gt;Hello Vue.js.&lt;/h1&gt;</code></pre>
<p>但是，带有<code>v-show</code>的元素始终会被渲染并保留在DOM中，<code>v-show</code>只是简单地切换元素的CSS属性<code>display</code>的值。</p>
<p>示例：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;show=!show&quot;&gt;切换&lt;/button&gt;
        &lt;h2 v-if=&quot;show&quot;&gt;Vue.js&lt;/h2&gt;
        &lt;h2 v-show=&quot;show&quot;&gt;Vue.js&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                show: true
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200828082251.png" alt="image-20200828082250681" class="lazyload"></p>
<p><code>v-if</code>在条件不满足的时候元素会消失；<code>v-show</code>条件不满足的时候只是<code>display:none</code>了</p>
<h3 id="4-6-v-bind"><a href="#4-6-v-bind" class="headerlink" title="4.6 v-bind"></a>4.6 v-bind</h3><h4 id="4-6-1-属性上使用vue数据"><a href="#4-6-1-属性上使用vue数据" class="headerlink" title="4.6.1 属性上使用vue数据"></a>4.6.1 属性上使用vue数据</h4><p>插值表达式不能用在属性中，会报错<code>&lt;div id=&quot;box&quot; class=&quot;&quot;&gt;点击按钮改变背景颜色&lt;/div&gt;</code></p>
<p>v-bind作用：可以对所有元素的属性值设置为vue中data的数据</p>
<p>语法：在属性名之前加上<code>v-bind:</code>(<code>v-bind:属性名=&#39;Vue中的变量&#39;</code>)，简写为<code>:属性名=&#39;属性值&#39;</code></p>
<p><code>&lt;img src=&quot;&quot; height=&quot;&quot; /&gt;</code>其中src和height的值如果不想写死，而是想获取Vue实例中的数据属性值的话，那么可以通过使用v-bind实现</p>
<pre><code class="html">&lt;img v-bind:src=&quot;vue实例中的数据属性名&quot; :height=&quot;vue实例中的数据属性名&quot; /&gt;</code></pre>
<p>利用v-bind实现点击切换背景颜色</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        #box{
            width: 150px;
            height: 150px;
            color: white;
        }
        .red{
            background-color: red;
        }
        .green{
            background-color: green;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;bgcolor=&#39;red&#39;&quot;&gt;切换红色&lt;/button&gt;
        &lt;button @click=&quot;bgcolor=&#39;green&#39;&quot;&gt;切换绿色&lt;/button&gt;
        &lt;br&gt;&lt;br&gt;
        &lt;div id=&quot;box&quot; v-bind:class=&quot;bgcolor&quot;&gt;点击按钮改变背景颜色&lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                bgcolor: &quot;red&quot;
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="4-6-2-class属性的特殊用法"><a href="#4-6-2-class属性的特殊用法" class="headerlink" title="4.6.2 class属性的特殊用法"></a>4.6.2 class属性的特殊用法</h4><p>上面虽然实现了颜色切换，但是比较麻烦。</p>
<p>Vue对class属性进行了特殊处理，可接受数组或对象格式</p>
<p>对象语法：</p>
<p>可以传给<code>:class</code>一个对象，用于动态切换class：</p>
<pre><code class="html">&lt;div :class=&quot;{red: true, green: false}&quot;&gt;&lt;/div&gt;</code></pre>
<ul>
<li>对象中，key是已经定义的class样式的名称，比如上面的<code>red</code>、<code>green</code></li>
<li>对象中，value是一个布尔值，如果为true，则这个样式会生效，如果为false，则不生效。</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        #box{
            width: 150px;
            height: 150px;
            color: white;
        }
        .red{
            background-color: red;
        }
        .green{
            background-color: green;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;bool=!bool&quot;&gt;切换颜色&lt;/button&gt;
        &lt;br&gt;&lt;br&gt;
        &lt;div id=&quot;box&quot; v-bind:class=&quot;{red: bool, green: !bool}&quot;&gt;点击按钮改变背景颜色&lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                bgcolor: &quot;red&quot;,
                bool: true
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="4-7-计算属性"><a href="#4-7-计算属性" class="headerlink" title="4.7 计算属性"></a>4.7 计算属性</h3><p>在插值表达式中使用js表达式是非常方便的，而且也经常被用到。</p>
<p>但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便。</p>
<p>例如，将一个日期的毫秒值显示转为格式化的yyyy-MM-dd：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;日期：{{new Date(date).getFullYear()}}-{{new Date(date).getMonth()+1}}-{{new Date(date).getDate()}}&lt;/h2&gt; &lt;!-- 日期：2020-8-28 --&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                date: 1598580451457 // 毫秒值
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>这样利用js的方法能够实现需求，但是很麻烦。</p>
<p>Vue中提供了计算属性，来替代复杂的表达式：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;日期：{{new Date(date).getFullYear()}}-{{new Date(date).getMonth()+1}}-{{new Date(date).getDate()}}&lt;/h2&gt;
        &lt;hr&gt;
        &lt;h2&gt;computed,日期：{{getDay}}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                date: 1598580451457 // 毫秒值
            },
            computed: {
                getDay(){
                    const date = new Date(this.date)
                    return date.getFullYear() + &quot;-&quot; + (date.getMonth()+1) + &quot;-&quot; + date.getDate()
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>computed计算属性可以应用在插值或者指令表达式复杂的时候，它可以将一些属性数据经过方法处理之后返回。</p>
<h3 id="4-8-watch"><a href="#4-8-watch" class="headerlink" title="4.8 watch"></a>4.8 watch</h3><h4 id="4-8-1-监控"><a href="#4-8-1-监控" class="headerlink" title="4.8.1 监控"></a>4.8.1 监控</h4><p>在vue实例中，数据属性因为在页面中修改而产生了变化，可以通过watch监控获取其改变前后的值。</p>
<p>watch使用场景：可以监控视图中的数据变化从而做出相应的反应，例如，下拉列表中，如果选择了对应的下拉列表选项之后，要根据最新的值去加载一些其他数据。</p>
<h4 id="4-8-2-深度监控"><a href="#4-8-2-深度监控" class="headerlink" title="4.8.2 深度监控"></a>4.8.2 深度监控</h4><p>如果是修改的对象数据属性，可以开启深度监控获取修改后最新的对象数据。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
        &lt;br&gt;&lt;hr&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;person.name&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;person.age&quot;&gt;
        &lt;button @click=&quot;person.age++&quot;&gt;年龄+1&lt;/button&gt;
        &lt;h2&gt;姓名：{{person.name}}，年龄：{{person.age}}&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                message: &quot;你好啊！&quot;,
                person:{
                    name: &quot;张三&quot;,
                    age: 21
                }
            },
            watch: {
                message(newValue, oldValue){
                    console.log(&quot;新值：&quot;+ newValue +&quot;，旧值：&quot; + oldValue)
                },
                person: {
                    /* 开启深度监控，监控对象中的属性值变化 */
                    deep: true,
                    // 可以获取到最新的对象属性数据
                    handler(obj){
                        console.log(&quot;姓名：&quot; + obj.name + &quot;,年龄：&quot; + obj.age)
                    }
                }
            },
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="五、组件化"><a href="#五、组件化" class="headerlink" title="五、组件化"></a>五、组件化</h2><p>在大型应用开发的时候，页面可以划分成很多部分。</p>
<p>但是如果每个页面都独自开发，无疑会增加开发的成本，因此会把页面的不同部分拆分成独立的组件，然后再不同的页面共享这些组件，避免重复开发。</p>
<h3 id="5-1-定义全局组件"><a href="#5-1-定义全局组件" class="headerlink" title="5.1 定义全局组件"></a>5.1 定义全局组件</h3><p>通过Vue的component方法来定义一个全局组件。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 引入组件(使用) --&gt;
        &lt;counter /&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // 定义组件
        const counter = {
            // el 组件不需要el绑定一个具体的元素
            template: &quot;&lt;button @click=&#39;num++&#39;&gt;你点击了{{num}}次&lt;/button&gt;&quot;,
            data() {
                return {
                    num: 0
                }
            } // data只能是一个函数，并且有返回
            /* data: {
                num: 0
            } */
        }
        // 全局注册组件：在所有的vue实例中都可以使用组件
        Vue.component(&quot;counter&quot;, counter) // 参数1：组件内名称，参数2：具体的组件
        var vm = new Vue({
            el: &quot;#app&quot;
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li><p>组件其实也是一个Vue实例，因此它在定义时也会接收data、methods、生命周期函数等</p>
</li>
<li><p>不同的是，组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性</p>
</li>
<li><p>但是组件渲染需要hmtl模板，所以添加了template属性，值就是HTML模板</p>
</li>
<li><p>全局组件定义完毕，任何Vue实例都可以直接在HTML中通过组件名称来使用该组件</p>
</li>
<li><p>data的定义方式比较特殊，必须是一个函数</p>
</li>
</ul>
<h3 id="5-2-组件的复用"><a href="#5-2-组件的复用" class="headerlink" title="5.2 组件的复用"></a>5.2 组件的复用</h3><p>定义好的组件，可以任意复用多次：</p>
<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;!-- 引入组件(使用) --&gt;
    &lt;counter&gt;&lt;/counter&gt;
    &lt;counter&gt;&lt;/counter&gt;
    &lt;counter&gt;&lt;/counter&gt;
&lt;/div&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200828121653.png" alt="image-20200828121651862" class="lazyload"></p>
<p>每个组件互不干扰，有自己的num值，这是因为</p>
<p><strong>组件的data属性必须是函数</strong></p>
<p>当定义这个组件的时候，它的data并不是像这样直接提供一个对象：</p>
<pre><code class="javascript">data:{
    num: 0
}</code></pre>
<p>而必须是一个函数，因此每个实例可以维护一分被返回对象的独立的拷贝</p>
<pre><code class="javascript">data: function() {
  return {
    num: 0
  }
}</code></pre>
<p>如果Vue没有这条规则，点击一个按钮就会影响到其他所有实例</p>
<h3 id="5-3-局部注册"><a href="#5-3-局部注册" class="headerlink" title="5.3 局部注册"></a>5.3 局部注册</h3><p>一旦全局注册，就意味着即便以后不再使用这个组件，它依然会随着Vue的加载而加载。因此，对于一些使用并不频繁的组件，会采用局部注册。</p>
<p>先在外部定义一个对象，结构与创建组件时传递的第二个参数一致，然后再Vue中使用它：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 引入组件(使用) --&gt;
        &lt;counter&gt;&lt;/counter&gt;
        &lt;counter&gt;&lt;/counter&gt;
        &lt;counter&gt;&lt;/counter&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // 定义组件
        const counter = {
            // el 组件不需要el绑定一个具体的元素
            template: &quot;&lt;button @click=&#39;num++&#39;&gt;你点击了{{num}}次&lt;/button&gt;&quot;,
            data() {
                return {
                    num: 0
                }
            } // data只能是一个函数，并且有返回
        }
        // 全局注册组件：在所有的vue实例中都可以使用组件
        /* Vue.component(&quot;counter&quot;, counter) */ // 参数1：组件内名称，参数2：具体的组件
        var vm = new Vue({
            el: &quot;#app&quot;,
            // 局部注册组件
            components:{
                counter: counter // 组件名: 具体的某个组件
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li>components就是当前vue对象子组件集合<ul>
<li>其key就是子组件名称</li>
<li>其值就是组件对象的属性</li>
</ul>
</li>
<li>效果与全局注册时一样的，但是这个局部注册的counter组件只能在当前的Vue实例中使用</li>
</ul>
<p>组件使用场景：在项目需要重用某个模块(头部、尾部、内容……)的时候，可以将模块抽取成组件，其他页面中注册组件并引用。</p>
<p>全局注册：在任何Vue实例中都可以引用，如：网站的头部导航菜单</p>
<p>局部注册：可以在有需要的页面引入组件，如：商城网站首页页面中各种活动模块</p>
<h3 id="5-4-组件通信"><a href="#5-4-组件通信" class="headerlink" title="5.4 组件通信"></a>5.4 组件通信</h3><p>通常一个单页面应用会以一颗嵌套的组件树的形式来组织：</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/pic/illustrtion/20200828155751.png" alt="img" class="lazyload"></p>
<ul>
<li>页面首先分为了顶部导航、左侧内容区、右侧边栏三个部分</li>
<li>左侧内容区又分为上下两个组件</li>
<li>右侧边栏中包含了3个子组件</li>
</ul>
<p>各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免地会有组件间通信的需求。</p>
<h4 id="5-4-1-父向子传递-props"><a href="#5-4-1-父向子传递-props" class="headerlink" title="5.4.1 父向子传递 props"></a>5.4.1 父向子传递 props</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;introduce :title=&quot;msg&quot;&gt;&lt;/introduce&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        const introduce = {
            template:&quot;&lt;h2&gt;{{title}}&lt;/h2&gt;&quot;,
            // 定义接收父组件的属性
            props:[&quot;title&quot;]
        }
        Vue.component(&quot;introduce&quot;, introduce)
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                msg:&quot;父组件的msg属性数据内容&quot;
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>introduce这个子组件中要使用title属性渲染页面，但是自己并没有title属性。通过props来接收父组件属性，名为title。父组件使用子组件，同时传递title属性。</p>
<h4 id="5-4-2-传递复杂数据"><a href="#5-4-2-传递复杂数据" class="headerlink" title="5.4.2 传递复杂数据"></a>5.4.2 传递复杂数据</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;my-list :items=&quot;lessons&quot;&gt;&lt;/my-list&gt; &lt;!-- 这里就不能用驼峰命名法了 --&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        const myList = {
            template:`
                &lt;ul&gt;
                    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;{{item.id}}——{{item.name}}&lt;/li&gt;
                &lt;/ul&gt;
            `, // 这里用的是模板字符串，也可以用双引号、单引号
            props:{ // 通过props来接收父组件传递来的属性
                items:{ // 这里定义items属性
                    // 数据类型，如果是数组则是Array，如果是对象则是Object
                    type:Array,
                    // 默认值(如果父组件没有传值，那么就是一个空数组)
                    default:[]
                }
            }
        }
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                msg:&quot;父组件的msg属性数据内容&quot;,
                lessons:[
                    {&quot;id&quot;:1, &quot;name&quot;:&quot;语文&quot;},
                    {&quot;id&quot;:2, &quot;name&quot;:&quot;数学&quot;},
                    {&quot;id&quot;:3, &quot;name&quot;:&quot;英语&quot;},
                    {&quot;id&quot;:4, &quot;name&quot;:&quot;物理&quot;},
                    {&quot;id&quot;:5, &quot;name&quot;:&quot;化学&quot;},
                    {&quot;id&quot;:6, &quot;name&quot;:&quot;生物&quot;}
                ]
            },
            components:{
                myList // ES6语法
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li><p>这个子组件可以对items进行迭代，并输出到页面</p>
</li>
<li><p>但是组件中并没有定义items属性</p>
</li>
<li><p>可以通过props来定义需要从父组件中接收的属性</p>
<ul>
<li><p>items：要接收的属性名称</p>
<ul>
<li><p>type：限定父组件传递来的必须是数组，否则报错[type的值可以是Array或者Object，传递对象的时候使用]</p>
</li>
<li><p>default：默认值，如果是对象则需要写成方法的方式返回默认值，如：</p>
<pre><code>default(){
    return {&quot;xxx&quot;:&quot;默认值&quot;}
}</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-4-3-子向父的通信"><a href="#5-4-3-子向父的通信" class="headerlink" title="5.4.3 子向父的通信"></a>5.4.3 子向父的通信</h4><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.js测试&lt;/title&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        num = {{num}}
        &lt;counter @plus=&quot;numPlus&quot; @reduce=&quot;numReduce()&quot; :snum=&quot;num&quot;&gt;&lt;/counter&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        const counter = {
            template:`
                &lt;div&gt; 
                    &lt;button @click=&#39;incrNum&#39;&gt;增加&lt;/button&gt;
                    &lt;button @click=&#39;decrNum&#39;&gt;减少&lt;/button&gt;
                &lt;/div&gt;
            `,/* 只能是一个容器包裹多个元素 */
            props:[&quot;snum&quot;],
            methods: {
                incrNum(){
                    // 调用到父组件中的方法
                    return this.$emit(&quot;plus&quot;)
                },
                decrNum(){
                    // 调用到父组件中的方法
                    return this.$emit(&quot;reduce&quot;)
                }
            },
        }
        Vue.component(&quot;counter&quot;, counter)
        var vm = new Vue({
            el: &quot;#app&quot;,
            data:{
                num: 0
            },
            methods: {
                numPlus(){
                    this.num++
                },
                numReduce(){
                    this.num--
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>实现了在子组件中点击对应按钮，父组件中属性数据的改变</p>
<p>子组件绑定自定义事件，在子组件中通过<code>$emit</code>触发这个事件，去调用执行外界父组件传递过来的函数操作，函数调用时可以传递参数，从而间接地传递数据给父组件。(父组件给子组件传递一个函数，然后子组件调用此函数，调用时可以传参，函数执行时，实际执行的是父组件中的逻辑，从而可以拿到子组件传参过来的数据)</p>
<p><code>$emit</code>可以传值，<code>this.$emit(&quot;自定义事件名&quot;,要传的数据)</code>，接着会在父组件中以方法的参数传过去</p>
<h2 id="六、Vuejs-ajax"><a href="#六、Vuejs-ajax" class="headerlink" title="六、Vuejs ajax"></a>六、Vuejs ajax</h2><p>Vuejs并没有直接处理ajax的组件，但可以使用axios或vue-resource组件实现对异步请求的操作。</p>
<h3 id="6-1-vue-resource"><a href="#6-1-vue-resource" class="headerlink" title="6.1 vue-resource"></a>6.1 vue-resource</h3><p>vue-resource是Vue.js的插件，提供了使用XMLHttpRequest或JSONP进行web请求和处理响应的服务。当Vue更新到2.0之后，作者就宣告不再对vue-resource更新，而是推荐使用axios。</p>
<p>GitHub地址：<a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">https://github.com/pagekit/vue-resource</a></p>
<h3 id="6-2-axios简介"><a href="#6-2-axios简介" class="headerlink" title="6.2 axios简介"></a>6.2 axios简介</h3><p>axios是一个基于promise的HTTP库，可以用在浏览器和Node.js中。</p>
<p>GitHub地址：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p>
<pre><code class="sh"># npm 安装
npm install axios</code></pre>
<p>也可以直接使用cdn服务：</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<h3 id="6-3-axios应用"><a href="#6-3-axios应用" class="headerlink" title="6.3 axios应用"></a>6.3 axios应用</h3><h4 id="6-3-1-方法说明"><a href="#6-3-1-方法说明" class="headerlink" title="6.3.1 方法说明"></a>6.3.1 方法说明</h4><p>axios可以使用的方法有：</p>
<ul>
<li><code>axios(config)</code></li>
<li><code>axios.get(url[,config])</code></li>
<li><code>axios.delete(url[,config])</code></li>
<li><code>axios.head(url[,config])</code></li>
<li><code>axios.post(url[,data[,config]])</code></li>
<li><code>axios.put(url[,data[,config]])</code></li>
<li><code>axios.patch(url[,data[,config]])</code></li>
</ul>
<p>1、config请求配置</p>
<p>这些是创建请求时可以用的配置选项。只有<code>url</code>是必须的，如果没有指定<code>method</code>，请求将默认使用<code>get</code>方法。</p>
<pre><code class="javascript">{
  // url是用于请求的服务器URL
  url: &#39;/user&#39;,

  // method是创建请求时使用的方法
  method: &#39;get&#39;, // 默认是get方式

  // baseURL将自动加在url的前面，除非url是一个绝对URL。
  // 它可以通过设置一个baseURL，便于为axios实例的方法传递相对URL。
  baseURL: &#39;https://some-domain.com/api/&#39;,

  // transformRequest允许在将请求数据发送到服务器之前对数据进行修改
  // 只能用在&#39;PUT&#39;、&#39;POST&#39;、&#39;PATCH&#39; and &#39;DELETE&#39;这些请求方法
  // 数组中的最后一个函数必须返回字符串或Buffer，ArrayBuffer，FormData或Stream的实例
  // You may modify the headers object.
  transformRequest: [function (data, headers) {
    // 对data进行任意转换处理

    return data;
  }],

  // transformResponse在传递给then/catch前，运行修改响应数据
  transformResponse: [function (data) {
    // 对data进行任意转换处理

    return data;
  }],

  // headers是即将被发送的自定义请求头
  headers: {
    &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;
  },

  // params是即将与请求一起发送的URL参数
  // 必须是一个无格式对象(plain object)或URLSearchParams对象
  params: {
    ID: 12345
  },

  // paramsSerializer是用于序列化params的可选功能(e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function (params) {
    return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;})
  },

  // data是作为请求主体被发送的数据
  // 只适用于&#39;PUT&#39;、&#39;POST&#39;、&#39;DELETE&#39;和&#39;PATCH&#39;请求方法
  // 在没有设置transformRequest时, 必须是一下类型之一:
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - 浏览器专属: FormData, File, Blob
  // - Node专属: Stream, Buffer
  data: {
    firstName: &#39;Fred&#39;
  },

  // syntax alternative to send data into the body
  // method post
  // only the value is sent, not the key
  data: &#39;Country=Brasil&amp;City=Belo Horizonte&#39;,

  // timeout指定请求超时的毫秒数(0表示无超时时间)
  // 如果请求花费超过timeout的时间, 请求将被中断
  timeout: 1000, // 默认是`0` (no timeout)

  // withCredentials表示跨域请求时是否需要凭证
  withCredentials: false, // 默认是false

  // adapter` allows custom handling of requests which makes testing easier.
  // Return a promise and supply a valid response (see lib/adapters/README.md).
  adapter: function (config) {
    /* ... */
  },

  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.
  // This will set an `Authorization` header, overwriting any existing
  // `Authorization` custom headers you have set using `headers`.
  // Please note that only HTTP Basic auth is configurable through this parameter.
  // For Bearer tokens and such, use `Authorization` custom headers instead.
  auth: {
    username: &#39;janedoe&#39;,
    password: &#39;s00pers3cret&#39;
  },

  // responseType表示服务器响应的数据类型，可以是&#39;arraybuffer&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;
  // 浏览器专属: &#39;blob&#39;
  responseType: &#39;json&#39;, // 默认是json

  // responseEncoding` indicates encoding to use for decoding responses (Node.js only)
  // Note: Ignored for `responseType` of &#39;stream&#39; or client-side requests
  responseEncoding: &#39;utf8&#39;, // default

  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
  xsrfCookieName: &#39;XSRF-TOKEN&#39;, // default

  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
  xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // default

  // `onUploadProgress` allows handling of progress events for uploads
  // browser only
  onUploadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },

  // `onDownloadProgress` allows handling of progress events for downloads
  // browser only
  onDownloadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },

  // maxContentLength定义运行的响应内容的最大尺寸
  maxContentLength: 2000,

  // `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed
  maxBodyLength: 2000,

  // validateStatus` defines whether to resolve or reject the promise for a given HTTP response status code. 如果validateStatus返回true(或者设置为null或undefined), promise将被resolved; 否则promise将被rejected.
  validateStatus: function (status) {
    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认是200~300
  },

  // maxRedirects定义在node.js中执行重定向的最大数目
  // 如果设置为0，将不执行任何重定向。
  maxRedirects: 5, // 默认是5

  // `socketPath` defines a UNIX Socket to be used in node.js.
  // e.g. &#39;/var/run/docker.sock&#39; to send requests to the docker daemon.
  // Only either `socketPath` or `proxy` can be specified.
  // If both are specified, `socketPath` is used.
  socketPath: null, // default

  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
  // and https requests, respectively, in node.js. This allows options to be added like
  // `keepAlive` that are not enabled by default.
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),

  // `proxy` defines the hostname and port of the proxy server.
  // You can also define your proxy using the conventional `http_proxy` and
  // `https_proxy` environment variables. If you are using environment variables
  // for your proxy configuration, you can also define a `no_proxy` environment
  // variable as a comma-separated list of domains that should not be proxied.
  // Use `false` to disable proxies, ignoring environment variables.
  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and
  // supplies credentials.
  // This will set an `Proxy-Authorization` header, overwriting any existing
  // `Proxy-Authorization` custom headers you have set using `headers`.
  proxy: {
    host: &#39;127.0.0.1&#39;,
    port: 9000,
    auth: {
      username: &#39;mikeymike&#39;,
      password: &#39;rapunz3l&#39;
    }
  },

  // `cancelToken` specifies a cancel token that can be used to cancel the request
  // (see Cancellation section below for details)
  cancelToken: new CancelToken(function (cancel) {
  }),

  // `decompress` indicates whether or not the response body should be decompressed 
  // automatically. If set to `true` will also remove the &#39;content-encoding&#39; header 
  // from the responses objects of all decompressed responses
  // - Node only (XHR cannot turn off decompression)
  decompress: true // default

}</code></pre>
<p>2、响应结构</p>
<pre><code class="javascript">{
  // data是由服务器提供的响应数据
  data: {},

  // status是来自服务器响应的HTTP状态码
  status: 200,

  // statusText服务器响应的HTTP状态信息
  statusText: &#39;OK&#39;,

  // headers是服务器响应的头，服务器使用所有标头名称响应的HTTP标头均使用小写字母，并且可以使用方括号表示法进行访问。
  // 例如: `response.headers[&#39;content-type&#39;]`
  headers: {},

  // config是为请求提供给axios的配置
  config: {},

  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance in the browser
  request: {}
}</code></pre>
<p>使用<code>then</code>时，将会收到如下响应：</p>
<pre><code class="javascript">axios.get(&#39;/user/12345&#39;)
  .then(function (response) {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });</code></pre>
<p>当使用<code>catch</code>或将<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">拒绝回调</a>作为<code>then</code>的第二个参数传递时，响应将通过<code>error</code>对象提供，如“<a href="https://github.com/axios/axios#handling-errors" target="_blank" rel="noopener">处理错误</a>”部分所述。</p>
<h4 id="6-3-2-axios方法示例"><a href="#6-3-2-axios方法示例" class="headerlink" title="6.3.2 axios方法示例"></a>6.3.2 axios方法示例</h4><h4 id="6-3-3-get方法示例"><a href="#6-3-3-get方法示例" class="headerlink" title="6.3.3 get方法示例"></a>6.3.3 get方法示例</h4><h4 id="6-3-4-post方法示例"><a href="#6-3-4-post方法示例" class="headerlink" title="6.3.4 post方法示例"></a>6.3.4 post方法示例</h4><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/08/20/AJAX/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="Ajax学习笔记" class="lazyload">
                    <h1>Ajax学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年08月20日</a>
            <a><i class="nexmoefont icon-areachart"></i>11.8k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 59 分钟</a>
        </div>

        <article>
            
                <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>Web程序的最初的目的就是将信息(数据)放到公共的服务器，让所有的网络用户都可以通过浏览器访问</p>
</blockquote>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815183452.png" alt="image-20200815183450778" class="lazyload"></p>
<p>在此之前，我们可以通过以下几种方式让浏览器发出服务端的请求，获得服务端的数据：</p>
<ul>
<li><p>地址栏输入地址，回车，刷新</p>
</li>
<li><p>特定元素的href或src属性</p>
</li>
<li><p>表单提交</p>
</li>
</ul>
<p>这些方案都是我们无法通过或者很难通过代码的方式进行编程(对服务器发出请求并且接收服务端返回的响应)，如果我们可以通过JavaScript直接发送网络请求，那么web的可能就会更多，随之能够实现的功能也会更多，至少不再是“单机游戏”。</p>
<p>1、AJAX(Asynchronous JavaScript and XML,异步的JS和XML)，最早出现在2005年的Google Suggest，是在浏览器端进行网络编程(发送请求，接收响应)的技术方案，它使我们可以<strong>通过JavaScript直接获取服务端最新的内容而不必重新加载页面</strong>，让web更能接近桌面应用的用户体验。</p>
<p>说白了，AJAX就是<strong>浏览器提供的一套API</strong>，可以通过JavaScript调用，从而实现代码控制请求与响应，实现网络编程。(AJAX不是新的编程语言，而是一种将现有标准组合在一起使用的新的方式)</p>
<blockquote>
<p>能力不够API凑。</p>
</blockquote>
<blockquote>
<p>对xxx进行编程指的就是用代码的方式操作它</p>
</blockquote>
<p>2、XML</p>
<p>可扩展标记语言，被设计用来传输和存储数据，和HTML有点像，但是HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据。</p>
<p>现在已经被json取代了。</p>
<p>3、AJAX的特点</p>
<p>(1) 优点</p>
<p>可以无需刷新页面而与服务器端进行通信。</p>
<p>允许你根据用户事件来更新部分页面内容。</p>
<p>(2) 缺点</p>
<p>没有浏览历史，不能回退</p>
<p>存在跨域问题(同源)</p>
<p>SEO不友好</p>
<p>补充：搭建环境</p>
<p><strong>使用Express搭建后台</strong></p>
<p><a href="https://www.expressjs.com.cn/" target="_blank" rel="noopener">Express中文网</a></p>
<p>1、安装</p>
<p>需要有node，没有的可以先<a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载</a></p>
<p>进入一个文件夹，输入命令创建node应用</p>
<pre><code class="bash">npm init --yes</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200810090417637.png" alt="node初始化命令" class="lazyload"></p>
<p>接着输入命令，安装express</p>
<pre><code class="bash">npm install express</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200810090617412.png" alt="express安装" class="lazyload"></p>
<p>2、基本使用</p>
<p>(1) 编写代码</p>
<pre><code class="javascript">// 1、引入express
const express = require(&#39;express&#39;)
const { response } = require(&#39;express&#39;)

// 2、创建应用对象
const app = express()

// 3、创建路由规则 
// reques是对请求报文的封装；response是对响应报文的封装
app.get(&#39;/&#39;, (request, response) =&gt; { // 前端访问http://localhost:8000/
  // 设置响应
  response.send(&#39;Hello Express&#39;)
})

// 4、监听端口启动服务
app.listen(8000, () =&gt; {
  console.log(&#39;服务已经启动，8000端口监听中，请访问http://localhost:8000/&#39;)
})</code></pre>
<p>(2) 运行代码</p>
<p>在该目录下输入命令</p>
<pre><code class="bash">node 文件名.js</code></pre>
<p>eg:</p>
<pre><code class="bash">node expressTest.js</code></pre>
<p>接着访问地址<a href="http://localhost:8000/即可" target="_blank" rel="noopener">http://localhost:8000/即可</a></p>
<p>3、准备服务端代码</p>
<p><code>server.js</code></p>
<pre><code class="javascript">const express = require(&#39;express&#39;)
const { response } = require(&#39;express&#39;)
const app = express()
// 这里设置为get则请求方式为GET、&#39;/server&#39;则请求url需要加上这个
app.get(&#39;/server&#39;, (request, response) =&gt; {
  // 设置响应头
  response.setHeader(&#39;Access-Control-Allow-origin&#39;,&#39;*&#39;) // 设置允许跨域
  // 设置响应体
  response.send(&#39;Hello AJAX&#39;)
})
// 在这里接着加上接口
app.listen(8000, () =&gt; {
  console.log(&#39;服务已经启动，8000端口监听中，请访问http://localhost:8000/&#39;)
})</code></pre>
<p>关闭上面那个，将这个启动：</p>
<pre><code class="bash">node server.js</code></pre>
<p>reload包——nodemon</p>
<p>自动检测js代码变化，restart服务</p>
<p>1、安装</p>
<pre><code class="sh">npm install -g nodemon</code></pre>
<p>2、利用nodemon执行文件</p>
<pre><code class="sh">nodemon 文件名.js</code></pre>
<p>例如：</p>
<pre><code class="sh">nodemon server.js</code></pre>
<h2 id="二、快速上手"><a href="#二、快速上手" class="headerlink" title="二、快速上手"></a>二、快速上手</h2><h3 id="1、AJAX基础"><a href="#1、AJAX基础" class="headerlink" title="1、AJAX基础"></a>1、AJAX基础</h3><p>(一个构造函数、两个方法、一个事件)</p>
<p>发送请求</p>
<pre><code class="html">&lt;style&gt;
#result{
    width:200px;
    height:100px;
    border:1px solid skyblue;
}
&lt;/style&gt;
&lt;button id=&quot;btn&quot;&gt;点击发送请求&lt;/button&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;script&gt;
btn.onclick = function(){
  // 涉及到AJAX操作的页面不能使用文件协议访问（文件的方式访问）
  // AJAX是一套API，核心提供的类型：XMLHttpRequest XML--&gt;JSON(现在使用的是JSON格式的了)
  // 1、安装浏览器（用户代理）——创建对象
  var xhr = new XMLHttpRequest() // xhr就类似于浏览器的作用(发送请求接收响应)
  // 2、打开浏览器 输入网址——初始化 设置请求方式和url
  xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server&#39;)  // 这一步只是在搭桥铺路
  // 3、敲回车键 开始请求——发送
  xhr.send()  // send才是开始请求
  /* 上面三个是ajax核心代码 */
}
&lt;/script&gt;</code></pre>
<p>接收响应</p>
<pre><code class="html">&lt;script&gt;
  var xhr = new XMLHttpRequest()
  xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server&#39;) // 方式，url
  xhr.send()
  /* 因为响应需要时间，所以无法通过返回值的方式返回响应 */
  // var response = xhr.send()
  // console.log(response) // undefine

  // 4、等待响应——事件绑定 处理服务端返回的结果
  /* 如果需要捕获状态的变化，需要注意代码的执行顺序的问题(不要出现来不及的情况)
  * 因为客户端永远不知道服务端何时才能返回我们需要的响应，所以AJAX API采用事件的机制(通知的感觉)
  */
  xhr.onreadystatechange = function(){ // 建议事件使用addEventListener方式
    // 这个事件并不是只在响应时触发，XHR状态改变就触发
    console.log(this.readyState)
    if(this.readyState!==4) return
    // 所以下面就是为4的情况
    // 5、看结果
    console.log(this.responseText) // 获取响应内容(响应体)
    result.innerHTML = xhr.response
  }
&lt;/script&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815183735.png" alt="ajax基础操作" class="lazyload"></p>
<h3 id="2、理解readyState"><a href="#2、理解readyState" class="headerlink" title="2、理解readyState"></a>2、理解readyState</h3><p><code>onreadystatechange</code>是XHR状态改变时触发的</p>
<pre><code class="html">&lt;script&gt;
  var xhr = new XMLHttpRequest()
  console.log(xhr.readyState) // 0
  xhr.open(&#39;GET&#39;, &#39;./time.php&#39;)
  console.log(xhr.readyState) // 1
  xhr.send()
  // console.log(xhr.readyState) // 1 取上面那个
  xhr.addEventListener(&#39;readystatechange&#39;, function(){
    // if(this.readyState !== 4) return
    // console.log(this.responseText)
    console.log(this.readyState) // 2 3 4
  })
&lt;/script&gt;</code></pre>
<p>readyState：</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815183844.png" alt="readyState代码" class="lazyload"></p>
<p>new XMLHttpRequest –&gt; 0 初始化 <strong>请求代理对象</strong></p>
<p>1–-&gt; open方法已经调用，<strong>建立</strong>一个与服务端特定端口的<strong>连接</strong></p>
<p>2 –-&gt; 已经<strong>接收</strong>到了响应报文的<strong>响应头</strong> <code>console.log(this.getAllResponseHeaders())</code> 可以拿到响应头，拿不到响应体</p>
<p>拆分：<code>console.log(this.getAllResponseHeaders().splite(‘\n’).splite(‘:’))</code></p>
<p>获取指定键：<code>console.log(this.getAllResponseHeaders(‘data’))</code></p>
<p>3 –-&gt; <strong>正在下载响应报文的响应体</strong>，可能响应体为空或不完整</p>
<p>4 –-&gt; 一切OK，<strong>整个响应报文已经下载下来</strong>了 <code>console.log(this.responseText)</code></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815183915.png" alt="readyState" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815183935.png" alt="image-20200815183934889" class="lazyload"></p>
<p>所以应该<strong>在readyState的值为4</strong>时，才去处理后续的逻辑</p>
<p>可以用<code>xhr.onload</code>替代</p>
<pre><code class="html">&lt;script&gt;
  var xhr = new XMLHttpRequest()
  xhr.open(&#39;GET&#39;, &#39;time.php&#39;)
  xhr.send(null) // send可以传请求体，传null代表没有请求体
  xhr.onload = function (){ // 加载完成 H5中提供的XMLHttpRequest version 2.0定义的
    // 相当于readyState为4之后的
    console.log(this.responseText)
  }
&lt;/script&gt;</code></pre>
<p>ps: console.log(this) 显示readyState是2、3、4可展开来全都是4，这个是console.log的机制问题，展开的时候只会显示此时的状态</p>
<p>例如：</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815184045.png" alt="log机制测试" class="lazyload"></p>
<p>在浏览器上看，不展开没问题显示123，展开的一瞬间都是456</p>
<h3 id="3、AJAX遵循HTTP协议"><a href="#3、AJAX遵循HTTP协议" class="headerlink" title="3、AJAX遵循HTTP协议"></a>3、AJAX遵循HTTP协议</h3><p>HTTP协议(Hypertext Transport Protocol，超文本传输协议)详细规定了浏览器和万维网服务器之间互相通信的规则。</p>
<p>本质上XMLHttpRequest就是JavaScript在web平台中发送HTTP请求的手段，所以我们发送出去的请求仍然是HTTP请求，同样符合HTTP约定的格式</p>
<p>请求报文：</p>
<ul>
<li>请求行 <code>POST /s?ie=utf-8 HTTP/1.1</code></li>
</ul>
<p>​    <code>GET /s?ie=utf-8 HTTP/1.1</code></p>
<ul>
<li>请求头 <code>Host: atguigu.com</code></li>
</ul>
<p>​    <code>Cookie: name=guigu</code></p>
<p>​    <code>Content-Type: application/x-www-form-urlencoded</code></p>
<p>​    <code>User-Agent: chrome 83</code></p>
<ul>
<li><p>空行(必须得有)</p>
</li>
<li><p>请求体 (GET请求这里为空，POST可不为空) <code>username=admin&amp;password=admin</code></p>
</li>
</ul>
<p>响应报文：</p>
<ul>
<li>行  <code>HTTP/1.1 200 OK</code></li>
</ul>
<p>​       404</p>
<p>​       403</p>
<p>​       401</p>
<p>​       500</p>
<ul>
<li><p>头  <code>Content-Type: text/html;charset=utf-8</code></p>
<p> <code>Content-length: 2048</code></p>
<p> <code>Content-encoding: gzip</code></p>
</li>
<li><p>空行 </p>
</li>
<li><p>体  </p>
</li>
</ul>
<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;wallleap&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815184354.png" alt="HTTP响应报文信息" class="lazyload"></p>
<pre><code class="html">&lt;script&gt;
  // 1、创建对象
  var xhr = new XMLHttpRequest()
  // 2、初始化 设置请求方法和url
xhr.open(&#39;POST&#39;, &#39;add.php&#39;) // 设置请求行
  xhr.setRequestHeader(&#39;Foo&#39;, &#39;Bar&#39;) // 设置一个请求头
  // 一旦请求体是urlencoded格式的内容，一定要设置请求头中的Content-Type为下面这个
  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;) // 设置第二请求头
  xhr.send(&#39;key1=value1&amp;key2=value2&#39;) // 以urlencoded格式设置请求体
  // xhr.send(&#39;{&quot;foo&quot;: &quot;123&quot;}&#39;) // 以json格式设置请求体，上面设置application/json
  xhr.onload = function (){
    // 响应行
    console.log(this.status) // 获取响应状态码
    console.log(this.statusText) // 获取响应状态描述
    // 获取响应头信息
    console.log(this.getResponseHeader(&#39;Content-Type&#39;)) // 指定响应头
    console.log(this.getAllResponseHeaders()) // 全部响应头
    // 获取响应体
    console.log(this.responseText) // 文本形式
    console.log(this.responseXML) // XML形式，了解即可
  }
&lt;/script&gt;</code></pre>
<p>补充：</p>
<pre><code class="javascript">xhr.addEventListener(&#39;readystatechange&#39;, function(){
    if(this.readyState === 4 &amp;&amp; this.status === 200){
      console.log(this)
    }
})</code></pre>
<p>可能有的人会同时判断状态码200，事实上没有必要，状态码404也需要处理,可以到里面嵌套，例如：</p>
<pre><code class="javascript">xhr.onreadystatechange=function(){
  if(this.readyState === 4){
    if(this.status &gt;= 200  &amp;&amp; xhr.status &lt; 300){
      // 处理结果
    }else{
      ...
    }
  }
})</code></pre>
<p>Chrome打开开发者模式</p>
<p>点击Network能够看到传输的文件</p>
<p>点击XHR查看</p>
<p>Request Headers——请求头</p>
<p>点击view source可以看到请求行</p>
<p>Response Header——响应头</p>
<p>点击view source可以看到响应行</p>
<p>Response——响应体</p>
<p>Preview——预览，对响应体解析之后的页面</p>
<h2 id="三、具体用法"><a href="#三、具体用法" class="headerlink" title="三、具体用法"></a>三、具体用法</h2><h3 id="1、数据接口的概念"><a href="#1、数据接口的概念" class="headerlink" title="1、数据接口的概念"></a>1、数据接口的概念</h3><p>服务器端返回的响应就是一个JSON内容（返回的就是数据）</p>
<p>对于返回数据的地址一般我们称之为接口（形式上是web形式）</p>
<p><a href="http://api.douban.com/v2/movie/top250" target="_blank" rel="noopener">http://api.douban.com/v2/movie/top250</a></p>
<p>提供一定的能力，有输入有输出就可以称为接口</p>
<h3 id="2、AJAX发送GET请求并传递参数"><a href="#2、AJAX发送GET请求并传递参数" class="headerlink" title="2、AJAX发送GET请求并传递参数"></a>2、AJAX发送GET请求并传递参数</h3><pre><code class="html">&lt;script&gt;
  var xhr = new XMLHttpRequest()
  // GET请求传递参数通常使用URL中的问号传递数据
  xhr.open(&#39;GET&#39;, &#39;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#39;)
  // 一般在GET请求时无需设置响应体，可以传null或者干脆不传
  xhr.send(null)
  xhr.onreadystatechange = function (){
    if(this.readyState !== 4) return
    console.log(this.responseText)
  }
&lt;/script&gt;
&lt;!-- 一般情况下URL传递的都是参数性质的数据，而POST一般都是业务数据 --&gt;</code></pre>
<p>例子：将得到的四个用户名称{}放到ul&gt;li中，点击li能够获取到该用户的年龄</p>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;
&lt;script&gt;
  var listElement = document.getElementById(&#39;list&#39;)
  /* 发送请求获取到列表数据，呈现在页面上 */
  var xhr = new XMLHttpRequest()
  xhr.open(&#39;POST&#39;, &#39;user.php?id=2&#39;)
  xhr.send(null)
  xhr.onreadystatechange = function (){
    if(this.readyState !== 4) return
    var data = JSON.parse(this.responseText)
    // console.log(data)
    for(var i = 0; i &lt; data.length; i++){
      // console.log(data[i])
      var liElement = document.createElement(&#39;li&#39;)
      liElement.innerHTML = data[i].name
      liElement.id = data[i].id
      listElement.appendChild(liElement)
      /* 给每一个li注册点击事件 */
      // 由于li是动态创建的，因此需要移到创建li的时候
      listElement.addEventListener(&#39;click&#39;, function (){
          // TODO: 通过AJAX操作获取服务端对应数据的信息
          // 获取当前被点击元素对应数据的id
          // console.log(this.id)
          var xhr1 = new XMLHttpRequest()
          xhr1.open(&#39;GET&#39;, &#39;users.php?id=&#39; + this.id)
          xhr1.send()
          xhr1.onreadystatechange = function (){
            if(this.readyState !== 4) return
            var obj = JSON.parse(this.responseText)
            alert(obj.age)
          }
      })
    }
  }
&lt;/script&gt;</code></pre>
<h3 id="3、POST请求"><a href="#3、POST请求" class="headerlink" title="3、POST请求"></a>3、POST请求</h3><p>POST请求过程中，都是采用请求体承载需要提交的数据</p>
<pre><code class="javascript">// 1.创建对象
const xhr = new XMLHttpRequest()
// 2.初始化 设置类型与URL(open的第一个参数的作用就是设置请求的method)
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;)
// 设置请求头信息
xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;) // 设置请求头中的Content-Type为application/x-www-form-urlencoded——标识这次请求得请求体格式为urlencoded以便于服务端接收数据
// xhr.setRequestHeader(&#39;name&#39;,&#39;wallleap&#39;) // 也可以自定义
// 3.发送 POST方式需要提交到服务端的数据可以通过send方法的参数传递，格式：key1=value1&amp;key2=value2
xhr.send(&quot;key1=value1&amp;key2=value2&quot;)
// xhr.send(&quot;key1:value1&amp;key2:value2&quot;)
// xhr.send(&quot;value1&quot;)  // ---&gt;可以随意写，但是需要按格式，方便后台处理
// 4.事件绑定
xhr.onreadystatechange = function(){
  // 判断
  if(xhr.readyState===4){
    if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){
      // 处理服务端返回的结果
      result.innerHTML = xhr.response
    }
  }
}</code></pre>
<p>由于<code>server.js</code>中只设置了get的允许跨域，因此需要在文件中加入允许post跨域的代码</p>
<pre><code class="javascript">// app.get(&#39;/server&#39;, (request, response) =&gt; {
app.post(&#39;/server&#39;, (request, response) =&gt; {
  // 设置响应头  设置允许跨域
  response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
  // 设置允许所有头信息，就比如上面设置的自定义响应头会报错，就需要加上这个
  // response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);
  // 设置响应体
  response.send(&#39;HELLO AJAX POST&#39;);
});</code></pre>
<p>可以改为all</p>
<pre><code class="javascript">//可以接收任意类型的请求(get/post/options/...)
app.all(&#39;/server&#39;, (request, response) =&gt; {
  //设置响应头  设置允许跨域
  response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
  //响应头
  response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);
  //设置响应体
  response.send(&#39;HELLO AJAX POST&#39;);
});</code></pre>
<p>测试</p>
<pre><code class="html">&lt;style&gt;
#result{
  width:200px;
  height:100px;
  border:solid 1px #903;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  //获取元素对象
  const result = document.getElementById(&quot;result&quot;);
  //绑定事件
  result.addEventListener(&quot;mouseover&quot;, function(){
    //1. 创建对象
    const xhr = new XMLHttpRequest();
    //2. 初始化 设置类型与 URL
    xhr.open(&#39;POST&#39;, &#39;http://127.0.0.1:8000/server&#39;);
    //设置请求头
    xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;);
    xhr.setRequestHeader(&#39;name&#39;,&#39;wallleap&#39;);
    //3. 发送
    xhr.send(&#39;a=100&amp;b=200&amp;c=300&#39;);
    // xhr.send(&#39;a:100&amp;b:200&amp;c:300&#39;);
    // xhr.send(&#39;1233211234567&#39;);
    //4. 事件绑定
    xhr.onreadystatechange = function(){
      //判断
      if(xhr.readyState === 4){
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){
          //处理服务端返回的结果
          result.innerHTML = xhr.response;
        }
      }
    }
  });
&lt;/script&gt;</code></pre>
<p>例子：点击登录按钮不刷新页面将数据传到后台</p>
<pre><code class="html">&lt;style&gt;
.loading{
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #555;
  text-align: center;
  padding-top: 200px;
  opacity: .5;
}
.loading::after{
  content: &#39;加载中……&#39;;
  font-size: 60px;
  color: #fff;
}
&lt;/style&gt;
&lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;
&lt;table border=&quot;1&quot;&gt;
  &lt;tr&gt;
    &lt;td&gt;用户名&lt;/td&gt;
    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;username&quot;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;密码&lt;/td&gt;
    &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;password&quot;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;button id=&quot;btn&quot;&gt;登录&lt;/button&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;script&gt;
  // 找一个合适的时机，做一件合适的事情(时间、内容)
  // 1、获取界面上的元素 value
  var textUsername = document.getElementById(&#39;username&#39;)
  var textPassword = document.getElementById(&#39;password&#39;)
  var btn = document.getElementById(&#39;btn&#39;)
  var loading = document.querySelector(&#39;.loading&#39;)
  btn.onclick = function (){
    loading.style.display = &#39;block&#39;
    var username = textUsername.value
    var password = textPassword.value
    // 2、通过XHR发送一个POST请求
    var xhr = new XMLHttpRequest
    xhr.open(&#39;POST&#39;, &#39;login.php&#39;)
    // 一定注意：如果请求体是urlencoded格式，必须设置这个请求头！
    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)
    // xhr.send(&#39;username=&#39; + username + &#39;&amp;password=&#39; + password)
    xhr.send(`username=${username}&amp;password=${password}`)
    // 3、根据服务端的反馈，作出界面提示
    xhr.onreadystatechange = function (){
      if(this.readyState !== 4) return
      console.log(this.responseText)
      loading.style.display = &#39;none&#39;
    }
  }
&lt;/script&gt;</code></pre>
<h3 id="4、同步和异步"><a href="#4、同步和异步" class="headerlink" title="4、同步和异步"></a>4、同步和异步</h3><p>生活中：</p>
<p>同步：一个人在同一个时刻只能做一件事情，在执行一些耗时的操作(不需要看管)不去做别的事情，只是等待</p>
<p>异步：在执行一些耗时的操作(不需要看管)去做别的事，而不是等待</p>
<p>xhr.open()第三个参数(async)要求传入的是一个bool值，其作用就是设置此次请求是否采用异步方式执行，默认为true，如果需要同步执行可以通过传递false实现</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815184832.png" alt="image-20200815184831019" class="lazyload"></p>
<p><code>console.time(‘标识’)</code> 启动一个秒表</p>
<p>中间写代码</p>
<p><code>console.timeEnd(‘标识’)</code> 结束这个秒表</p>
<p>这样就能知道用了多长时间(标识名称得相同)</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815184906.png" alt="image-20200815184905369" class="lazyload"></p>
<p>如果采用同步方式执行，则代码会卡死在xhr.send()这一步</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815184921.png" alt="image-20200815184920339" class="lazyload"></p>
<p>send方法会不会出现等待情况(区分同异步)</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815184939.png" alt="image-20200815184938765" class="lazyload"></p>
<p>知道同步模式即可(已被遗弃)</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815184956.png" alt="image-20200815184955646" class="lazyload"></p>
<p>同步模式注册时间时机问题</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185018.png" alt="image-20200815185017871" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185029.png" alt="image-20200815185028276" class="lazyload"></p>
<h3 id="5、响应数据格式"><a href="#5、响应数据格式" class="headerlink" title="5、响应数据格式"></a>5、响应数据格式</h3><p>如果希望服务器返回一个复杂数据，该如何处理：</p>
<p> 服务器发出何种格式的数据，这个格式如何在客户端用JavaScript解析</p>
<p>5.1 XML</p>
<p>一种数据描述手段</p>
<p>老掉牙的东西，现在项目中基本不使用</p>
<p>淘汰的原因：数据冗余太多</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185058.png" alt="image-20200815185057257" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185108.png" alt="image-20200815185106691" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185115.png" alt="image-20200815185114823" class="lazyload"></p>
<p><strong>5.2 JSON</strong></p>
<p>也是一种数据描述手段，类似于JavaScript字面量方式</p>
<p>服务端采用JSON格式返回数据，客户端按照JSON格式解析数据</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185141.png" alt="image-20200815185140660" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185148.png" alt="image-20200815185147671" class="lazyload"></p>
<p>来测试一下json的</p>
<p><code>server.js</code>中添加</p>
<pre><code class="javascript">//JSON 响应
app.all(&#39;/json-server&#39;, (request, response) =&gt; {
  //设置响应头  设置允许跨域
  response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
  //响应头
  response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);
  //响应一个数据
  const data = {
    name: &#39;wallleap&#39;
  };
  //对对象进行字符串转换
  let str = JSON.stringify(data);
  //设置响应体
  response.send(str);
});</code></pre>
<p>测试</p>
<pre><code class="html">&lt;style&gt;
  #result{
    width:200px;
    height:100px;
    border:solid 1px #89b;
  }
&lt;/style&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  //绑定键盘按下事件
  window.onkeydown = function(){
    //发送请求
    const xhr = new XMLHttpRequest();
    //设置响应体数据的类型
    xhr.responseType = &#39;json&#39;; // 自动转换
    //初始化
    xhr.open(&#39;GET&#39;,&#39;http://127.0.0.1:8000/json-server&#39;);
    //发送
    xhr.send();
    //事件绑定
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4){
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){
          // console.log(xhr.response);
          // result.innerHTML = xhr.response;
          // 1. 手动对数据转化
          // let data = JSON.parse(xhr.response);
          // console.log(data);
          // result.innerHTML = data.name;
          // 2. 自动转换
          console.log(xhr.response);
          result.innerHTML = xhr.response.name;
        }
      }
    }
  }
&lt;/script&gt;</code></pre>
<p>注意：</p>
<p>不论是JSON，还是XML，只是在AJAX请求过程中用到，并不代表它们之间有必然的联系，它们只是数据协议罢了</p>
<p>不管服务器使用XML还是JSON本质上都是将数据返回给客户端</p>
<p>服务端应该设置一个合理的Content-Type</p>
<h3 id="6、处理服务器端响应的数据"><a href="#6、处理服务器端响应的数据" class="headerlink" title="6、处理服务器端响应的数据"></a>6、处理服务器端响应的数据</h3><p>动态渲染数据到表格中</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185218.png" alt="image-20200815185217284" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185226.png" alt="image-20200815185225225" class="lazyload"></p>
<p>现在一般都不会这样操作，太繁琐了</p>
<p>模板引擎</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185252.png" alt="image-20200815185251189" class="lazyload"></p>
<p>常见模板引擎列表：<a href="https://github.com/tj/consolidate.js#supported-template-engines" target="_blank" rel="noopener">https://github.com/tj/consolidate.js#supported-template-engines</a></p>
<p>artTemplate： <a href="https://aui.github.io/art-template" target="_blank" rel="noopener">https://aui.github.io/art-template</a></p>
<p>模板引擎实际上就是一个API，模板引擎有很多种，使用方式大同小异，目的为了可以更容易地将数据渲染到HTML中</p>
<pre><code class="html">&lt;table id=&quot;comment&quot; border=&quot;1&quot;&gt;&lt;/table&gt;
&lt;!-- // 1.选择一个模板引擎 https://github.com/tj/consolidate.js#supported-template-engines
// 2、下载模板引擎JS库
// 3、引入到页面中 --&gt;
&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/art-template/4.13.2/lib/template-web.min.js&quot;&gt;&lt;/script&gt;
&lt;!-- 
  script标签的特点：
  1、innerHTML永远不会显示在界面上(display: none;)
  2、如果type属性不是text/javascript，内部的内容不会作为JavaScript执行
 --&gt;
&lt;!-- // 4、准备一个模板 --&gt;
&lt;!-- 
  JavaScript中用变量保存(维护不方便、不能换行)
  ——&gt; HTML中放到一个div中通过样式隐藏(添加误用元素、多余样式)
  ——&gt; script标签type修改之后不会显示在页面中，建议text/x-开头
--&gt;
&lt;script id=&quot;tmpl&quot; type=&quot;text/x-art-template&quot;&gt;
{{each comments}}  
&lt;tr&gt;
  &lt;td&gt;{{$index+1}}&lt;/td&gt;
  &lt;td&gt;{{$value.author}}&lt;/td&gt;
  &lt;td&gt;{{$value.content}}&lt;/td&gt;
  &lt;td&gt;{{$value.created}}&lt;/td&gt;
&lt;/tr&gt;
{{/each}}
&lt;/script&gt;
&lt;script&gt;
var xhr = new XMLHttpRequest()
xhr.open(&#39;GET&#39;, &#39;test.php&#39;)
xhr.send()
xhr.onreadystatechange = function (){
  if(this.readyState !== 4) return
  var res = JSON.parse(this.responseText)
  // // 5、准备一个数据
  var context = {comments: res.data}  // 上面的关键词就是comments
  console.log(context)
  var html = template(&#39;tmpl&#39;, context)
  console.log(html)
  document.getElementById(&#39;comment&#39;).innerHTML = html

  // 6、通过模板引擎的JS提供一个函数将模板和数据整合得到渲染结果HTML
  // 7、将渲染结果的HTML设置到某个元素的innerHTML中
}
&lt;/script&gt;</code></pre>
<h3 id="7、兼容方案"><a href="#7、兼容方案" class="headerlink" title="7、兼容方案"></a>7、兼容方案</h3><p>XMLHttpRequest在老板浏览器(IE5/6)中有兼容问题，可以通过另一种方式代替</p>
<pre><code class="javascript">var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)</code></pre>
<h3 id="8、补充"><a href="#8、补充" class="headerlink" title="8、补充"></a>8、补充</h3><p>(1) response、responseText</p>
<p>都是获取的响应</p>
<p>response: 获取到的结果或根据this.responseType的变化而变化(可以表述二进制数据)</p>
<p>responseText: 永远获取的是字符串形式的响应体</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest
xhr.open(&#39;GET&#39;, &#39;test.php&#39;)
xhr.send()
xhr.responseType = &#39;json&#39;  // 通过代码告诉请求代理对象，服务端响应给我们的是JSON
xhr.onreadystatechange = function (){
  if(this.readyState !== 4) return
  console.log(this)
  console.log(this.response)
  console.log(this.responseText)  // 由于设置了json，因此不存在
}</code></pre>
<p>(2) IE缓存问题：IE浏览器会将ajax返回结果缓存起来，再次发送请求时，显示的是本地缓存，而不是最新的请求到的数据</p>
<p>在服务端添加一个：</p>
<pre><code class="javascript">//针对 IE 缓存
app.get(&#39;/ie&#39;, (request, response) =&gt; {
  //设置响应头  设置允许跨域
  response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
  //设置响应体
  response.send(&#39;HELLO AJAX IE&#39;);
});</code></pre>
<p>解决</p>
<pre><code class="html">&lt;style&gt;
  #result{
    width:200px;
    height:100px;
    border:solid 1px #258;
  }
&lt;/style&gt;
&lt;button&gt;点击发送请求&lt;/button&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  const btn = document.getElementsByTagName(&#39;button&#39;)[0];
  const result = document.querySelector(&#39;#result&#39;);

  btn.addEventListener(&#39;click&#39;, function(){
    const xhr = new XMLHttpRequest();
    xhr.open(&quot;GET&quot;,&#39;http://127.0.0.1:8000/ie?t=&#39;+Date.now()); // 解决方案：加上参数，这样浏览器认为每次请求url都不一样
    xhr.send();
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4){
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300){
          result.innerHTML = xhr.response;
        }
      }
    }
  })
&lt;/script&gt;</code></pre>
<p>(3) 请求超时和网络异常</p>
<p><code>server.js</code>中添加</p>
<pre><code class="javascript">//延时响应
app.all(&#39;/delay&#39;, (request, response) =&gt; {
  //设置响应头  设置允许跨域
  response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
  response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);
  // 手动设置一个延时效果
  setTimeout(() =&gt; {
    //设置响应体
    response.send(&#39;延时响应&#39;);
  }, 1000) // 3000
});</code></pre>
<p>进行处理，在2s内还没有响应则取消</p>
<pre><code class="html">&lt;style&gt;
  #result{
    width:200px;
    height:100px;
    border:solid 1px #90b;
  }
&lt;/style&gt;
&lt;button&gt;点击发送请求&lt;/button&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  const btn = document.getElementsByTagName(&#39;button&#39;)[0];
  const result = document.querySelector(&#39;#result&#39;);
  btn.addEventListener(&#39;click&#39;, function(){
    const xhr = new XMLHttpRequest();
    //超时设置 2s 设置
    xhr.timeout = 2000;
    //超时回调
    xhr.ontimeout = function(){
      alert(&quot;网络异常, 请稍后重试!!&quot;);
    }
    //网络异常回调
    xhr.onerror = function(){
      alert(&quot;你的网络似乎出了一些问题!&quot;);
    }
    xhr.open(&quot;GET&quot;,&#39;http://127.0.0.1:8000/delay&#39;);
    xhr.send();
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4){
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300){
          result.innerHTML = xhr.response;
        }
      }
    }
  })
&lt;/script&gt;</code></pre>
<p>网络异常可以利用浏览器调试中Network一栏，设置为Offline</p>
<p>(3) 取消请求</p>
<p>利用abort()方法取消请求</p>
<pre><code class="html">&lt;button&gt;点击发送&lt;/button&gt;
&lt;button&gt;点击取消&lt;/button&gt;
&lt;script&gt;
  //获取元素对象
  const btns = document.querySelectorAll(&#39;button&#39;);
  let x = null; // 由于第二个按钮也需要用到
  btns[0].onclick = function(){
    x = new XMLHttpRequest();
    x.open(&quot;GET&quot;,&#39;http://127.0.0.1:8000/delay&#39;);
    x.send();
  }
  // abort
  btns[1].onclick = function(){
    x.abort();
  }
&lt;/script&gt;</code></pre>
<p>(3) ajax重复发送请求问题：用户频繁发送请求，对服务器压力很大</p>
<p>请求时，可以判断，如果前面有一条这样的请求，那么将前面的请求取消掉</p>
<pre><code class="html">&lt;button&gt;点击发送&lt;/button&gt;
&lt;script&gt;
  //获取元素对象
  const btns = document.querySelectorAll(&#39;button&#39;);
  let x = null;
  //标识变量
  let isSending = false; // 是否正在发送AJAX请求
  btns[0].onclick = function(){
    //判断标识变量
    if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求
    x = new XMLHttpRequest();
    //修改 标识变量的值
    isSending = true;
    x.open(&quot;GET&quot;,&#39;http://127.0.0.1:8000/delay&#39;);
    x.send();
    x.onreadystatechange = function(){
      if(x.readyState === 4){
        //修改标识变量
        isSending = false;
      }
    }
  }
&lt;/script&gt;</code></pre>
<h2 id="四、封装"><a href="#四、封装" class="headerlink" title="四、封装"></a>四、封装</h2><h3 id="1、AJAX请求封装"><a href="#1、AJAX请求封装" class="headerlink" title="1、AJAX请求封装"></a>1、AJAX请求封装</h3><p>封装的套路：</p>
<p>(1)  写一个相对比较完善的用例</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest
xhr.open(&#39;GET&#39;, &#39;test.php&#39;, true)
xhr.send(null)
xhr.addEventListener(&#39;readystatechange&#39;, function(){
  if(this.readyState !== 4) return
  console.log(this.responseText)
})</code></pre>
<p>(2)  写一个空函数，没有形参，将刚刚的用例直接作为函数的函数体</p>
<pre><code class="javascript">function ajax(){
  var xhr = new XMLHttpRequest
  xhr.open(&#39;GET&#39;, &#39;test.php&#39;, true)
  xhr.send(null)
  xhr.addEventListener(&#39;readystatechange&#39;, function(){
    if(this.readyState !== 4) return
    console.log(this.responseText)
  })
}</code></pre>
<p>(3)  根据使用过程中的需求抽象参数</p>
<pre><code class="javascript">/*
Ajax请求 version1
method: 请求方式 GET/POST
url: 请求地址 &#39;http://xxx.com/api&#39;
*/
function ajax(method, url){
  var xhr = new XMLHttpRequest
  xhr.open(method, url, true)
  xhr.send(data)
  xhr.addEventListener(&#39;readystatechange&#39;, function(){
    if(this.readyState !== 4) return
    console.log(this.responseText)
  })
}
ajax(&#39;GET&#39;, &#39;test.php&#39;)</code></pre>
<p>send需要传参</p>
<pre><code class="javascript">/*
Ajax请求 version2
method: 请求方式 GET/POST
url: 请求地址 &#39;http://xxx.com/api&#39;
params: 键值对字符串
*/
function ajax(method, url, params){
  var xhr = new XMLHttpRequest
  var data = null
  if(method === &#39;GET&#39;){
    url += &#39;?&#39; + params
  }
  xhr.open(method, url, true)
  if(method === &#39;POST&#39;){
    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)
    data = params || null
  }
  xhr.send(data)
  xhr.addEventListener(&#39;readystatechange&#39;, function(){
    if(this.readyState !== 4) return
    console.log(this.responseText)
  })
}
ajax(&#39;GET&#39;, &#39;test.php&#39;)
ajax(&#39;POST&#39;, &#39;post.php&#39;, &#39;key1=value1&amp;key2=value2&#39;)</code></pre>
<p>send实参可以传对象</p>
<pre><code class="javascript">/*
Ajax请求 version3
method: 请求方式 GET/POST
url: 请求地址 &#39;http://xxx.com/api&#39;
params: 对象
*/
function ajax(method, url, params){
  var xhr = new XMLHttpRequest
  // 将Object类型的参数转换为 key1=value1&amp;key2=value2的形式
  if(typeof params === &#39;object&#39;){
    var tempArr = []
    for (var key in params){
      var value = params[key]
      tempArr.push(key + &#39;=&#39; + params[key])
      // tempArr =&gt; [&#39;key1=value1&#39;, &#39;key2=value2&#39;]
    }
    params = tempArr.join(&#39;&amp;&#39;)
    // tempArr =&gt; [&#39;key1=value1&amp;key2=value2&#39;]
  }
  if(method === &#39;GET&#39;){
    params ? url += &#39;?&#39; + params : url
  }
  xhr.open(method, url, true)
  var data = null
  if(method === &#39;POST&#39;){
    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)
    data = params || null
  }
  xhr.send(data)
  xhr.addEventListener(&#39;readystatechange&#39;, function(){
    if(this.readyState !== 4) return
    console.log(this.responseText)
  })
}
ajax(&#39;GET&#39;, &#39;test.php&#39;)
ajax(&#39;GET&#39;, &#39;time.php&#39;, {id: 1})
ajax(&#39;POST&#39;, &#39;post.php&#39;, {key1: &#39;value1&#39;, key2: &#39;value2&#39;, key3: &#39;value3&#39;})
ajax(&#39;POST&#39;, &#39;post.php&#39;, &#39;key1=value1&amp;key2=value2&#39;)</code></pre>
<p>不应该在封装的函数中主观地处理响应结果</p>
<pre><code class="javascript">/*
Ajax请求 version4
method: 请求方式 GET/POST/get/post
url: 请求地址 &#39;http://xxx.com/api&#39;
params: 对象
*/
function ajax(method, url, params){
  var res = null
  method= method.toUpperCase()
  var xhr = new XMLHttpRequest
  // 将Object类型的参数转换为 key1=value1&amp;key2=value2的形式
  if(typeof params === &#39;object&#39;){
    var tempArr = []
    for (var key in params){
      var value = params[key]
      tempArr.push(key + &#39;=&#39; + params[key])
      // tempArr =&gt; [&#39;key1=value1&#39;, &#39;key2=value2&#39;]
    }
    params = tempArr.join(&#39;&amp;&#39;)
    // tempArr =&gt; [&#39;key1=value1&amp;key2=value2&#39;]
  }
  if(method === &#39;GET&#39;){
    params ? url += &#39;?&#39; + params : url
  }
  xhr.open(method, url, false) // 改为同步了
  var data = null
  if(method === &#39;POST&#39;){
    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)
    data = params || null
  }
  xhr.addEventListener(&#39;readystatechange&#39;, function(){
    if(this.readyState !== 4) return
    // console.log(this.responseText)
    // return xhr.responseText // 无法再给外部函数返回结果，利用闭包、原型链
    res = this.responseText
  })
  xhr.send(data)
  // 由于是异步，会先执行(用同步，事件放到send前x不推荐)
  return res
}
console.log(ajax(&#39;post&#39;, &#39;post.php&#39;, {key1: &#39;value1&#39;, key2: &#39;value2&#39;, key3: &#39;value3&#39;}))</code></pre>
<p>不能使用同步模式</p>
<p>补充一个概念：</p>
<p>委托(或回调)</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185828.png" alt="image-20200815185827212" class="lazyload"></p>
<p>函数可以理解为一个想要做的事情，函数体中约定了这件事情做的过程，直到调用时才开始工作。</p>
<p>将函数作为参数传递就像是将一件事情交给别人，这就是委托。</p>
<p>异步编程中回调/委托使用频率很高。（由于是异步的，你先执行，我告诉你做什么，我就不等了——等不及，你执行就行了）</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185846.png" alt="image-20200815185845589" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185858.png" alt="image-20200815185856765" class="lazyload"></p>
<p>回调地狱/黑洞：死循环</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815185914.png" alt="image-20200815185913313" class="lazyload"></p>
<p><font color=red><strong>最终版本</strong></font></p>
<pre><code class="javascript">/*
发送一个Ajax请求 version5
@param (String) method  请求方式 GET/POST/get/post
@param (String) url     请求地址 &#39;http://xxx.com/api&#39;
@param (Object) params  请求参数
@param (Function) done  请求完成过后需要做的事情(委托/回调)
*/
function ajax(method, url, params, done){
  var res = null
  method= method.toUpperCase()
  var xhr = new XMLHttpRequest
  // 将Object类型的参数转换为 key1=value1&amp;key2=value2的形式
  if(typeof params === &#39;object&#39;){
    var tempArr = []
    for (var key in params){
      var value = params[key]
      tempArr.push(key + &#39;=&#39; + params[key])
    }
    params = tempArr.join(&#39;&amp;&#39;)
  }
  if(method === &#39;GET&#39;){
    params ? url += &#39;?&#39; + params : url
  }
  xhr.open(method, url, true)
  var data = null
  if(method === &#39;POST&#39;){
    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)
    data = params || null
  }
  xhr.send(data)
  xhr.addEventListener(&#39;readystatechange&#39;, function(){
    if(this.readyState !== 4) return
    res = this.responseText
    done(res)
  })
}

var ondone = function (res){
  console.log(&#39;准备执行&#39;)
  // console.log(res)
  alert(res)
  console.log(&#39;执行完成了&#39;)
}
ajax(&#39;post&#39;, &#39;post.php&#39;, {key1: &#39;value1&#39;, key2: &#39;value2&#39;}, ondone)
ajax(&#39;get&#39;, &#39;time.php&#39;, {}, function(res){
  console.log(res)
})</code></pre>
<h3 id="2、jQuery中的Ajax"><a href="#2、jQuery中的Ajax" class="headerlink" title="2、jQuery中的Ajax"></a>2、jQuery中的Ajax</h3><p>jQuery中有一套专门针对AJAX的封装，功能十分完善，经常使用，需要注意。</p>
<p><a href="https://www.jquery123.com/category/ajax/" target="_blank" rel="noopener">https://www.jquery123.com/category/ajax/</a></p>
<p>(1)通用方法$.ajax</p>
<p>底层接口(其他接口依赖于这个)</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 1、最基础的调用
$.ajax(&#39;./time.php&#39;, { // url: 
  type: &#39;POST&#39;,  // method: 请求方法
  success: function(res){
    // res =&gt; 拿到的只是响应体
    console.log(res)
  }
})
// 可以把url写到里面去
$.ajax({ 
  url: &#39;./time.php&#39;,// url: 
  type: &#39;POST&#39;,  // method: 请求方法
  data: {id: 1, name: &#39;张三&#39;}, // 用于提交到服务端的参数
  /*
    get方式通过url传递
    post方式按照请求体传递
  */
  success: function(res){
    // res =&gt; 拿到的只是响应体
    console.log(res)
  }
})
// res返回格式
$.ajax({ 
  url: &#39;./json.php&#39;,// url: 请求地址
  type: &#39;get&#39;,  // method: 请求方法
  success: function(res){
    // res会根据服务器响应的Content-Type自动转换为对象
    // 这是jQuery内部实现的
    console.log(res)
  }
})
// 指定响应体类型
$.ajax({ 
  url: &#39;./json.php&#39;,// url: 
  type: &#39;get&#39;,  // method: 请求方法
  // data: {id: 1, name: &#39;张三&#39;}, // 设置请求参数
  dataType: &#39;json&#39;, // 用于设置响应体的类型(与data参数没关系)
  success: function(res){
    // 一旦设置了dataType选项，就不再关心服务端响应的Content-Type了
    // 客户端会主观地认为服务端返回的就是json格式
    console.log(res)
  }
})
&lt;/script&gt;</code></pre>
<p>原生操作中不论请求状态码是多少都会触发回调</p>
<p>jQuery中ajax的回调</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// jQuery中ajax的回调
$.ajax({ 
  url: &#39;./time.php&#39;, // url
  data: {key1:value1, key2:value2}, // 参数
  type: &#39;POST&#39;,  // method: 请求方法
  dataType: &#39;json&#39;, // 响应体结果
  beforeSend: function(xhr){
    // 在所有发送请求得操作(open、send)之前执行
    console.log(&#39;beforeSend&#39;, xhr)
  }
  success: function(res){ // 成功的回调
    // 只有请求成功(状态码为200)才会执行这个函数
    // res =&gt; 拿到的只是响应体
    console.log(res)
  },
  // timeout: 2000, // 超时时间
  error: function(xhr){ // 失败的回调
    // 只有请求不正常才会执行(状态码不为200)
    console.log(&#39;error&#39;,xhr)
  },
  complete: function(xhr){
    // 不管成功还是失败都是完成，都会执行这个complete函数
    console.log(&#39;complete&#39;, xhr)
  }
})
&lt;/script&gt;</code></pre>
<p>(2) 高级封装</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 2、jQuery中ajax的快捷方法
$.get(&#39;time.php&#39;, function(res){
  console.log(res)
})
$.post(&#39;time.php&#39;, function(res){
  console.log(res)
})
// 服务端设置了json能转换对象，没设置不行
$.get(&#39;time.php&#39;, {id: 1}, function(res){
  console.log(res)
})
$.post(&#39;time.php&#39;, {id: 1}, function(res){
  console.log(res)
})
// 无视服务端Content-Type，视作JSON格式
$.getJSON(&#39;json.php&#39;, {id: 1}, function(res){
  console.log(res)
})
$.postJSON(&#39;json.php&#39;, {id: 1}, function(res){
  console.log(res)
})
明确请求的方式，根据方式选择快捷方法
&lt;/script&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190207.png" alt="image-20200815190206531" class="lazyload"></p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 跳转其他页面，会白屏，但是有些页面只是部分不相同，可以局部刷新
$(function($){
  // 有一个独立的作用域，顺便确保页面加载完成执行
  $(&#39;a.item&#39;).on(&#39;click&#39;, function(){
    var url = $(this).attr(&#39;href&#39;)
    $(&#39;#main&#39;).load(url + &#39; #main&gt;*&#39;) // 元素.load(链接+空格+选择器)
    // 阻止a的默认行为
    return false
  })
})
&lt;/script&gt;</code></pre>
<p>将jQuery的几种方式汇总一下：</p>
<p><code>server.js</code>中：</p>
<pre><code class="javascript">//jQuery 服务
app.all(&#39;/jquery-server&#39;, (request, response) =&gt; {
    //设置响应头  设置允许跨域
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);
    // response.send(&#39;Hello jQuery AJAX&#39;);
    const data = {name:&#39;wallleap&#39;};
    response.send(JSON.stringify(data));
});</code></pre>
<p>前端</p>
<pre><code class="html">&lt;link crossorigin=&quot;anonymous&quot; href=&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- crossorigin=&quot;anonymous&quot;：跨域源请求设置，加上之后向这个资源发送请求时不会携带当前域名下的cookie --&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;h2 class=&quot;page-header&quot;&gt;jQuery发送AJAX请求 &lt;/h2&gt;
    &lt;button class=&quot;btn btn-primary&quot;&gt;GET&lt;/button&gt;
    &lt;button class=&quot;btn btn-danger&quot;&gt;POST&lt;/button&gt;
    &lt;button class=&quot;btn btn-info&quot;&gt;通用型方法ajax&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
  $(&#39;button&#39;).eq(0).click(function(){
    $.get(&#39;http://127.0.0.1:8000/jquery-server&#39;, {a:100, b:200}, function(data){
      console.log(data);
    },&#39;json&#39;);
  });
  $(&#39;button&#39;).eq(1).click(function(){
    $.post(&#39;http://127.0.0.1:8000/jquery-server&#39;, {a:100, b:200}, function(data){
      console.log(data);
    });
  });
  $(&#39;button&#39;).eq(2).click(function(){
    $.ajax({
      //url
      url: &#39;http://127.0.0.1:8000/jquery-server&#39;,
      //参数
      data: {a:100, b:200},
      //请求类型
      type: &#39;GET&#39;,
      //响应体结果
      dataType: &#39;json&#39;,
      //成功的回调
      success: function(data){
        console.log(data);
      },
      //超时时间
      timeout: 2000,
      //失败的回调
      error: function(){
        console.log(&#39;出错啦!!&#39;);
      },
      //头信息
      headers: {
        c:300,
        d:400
      }
    });
  });
&lt;/script&gt;</code></pre>
<p>(3) 全局事件及配置NProgress显示加载进度</p>
<pre><code class="html">&lt;style&gt;
  .loading{
    display: none;
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background-color: rgba(85, 85, 85, .5);
    text-align: center;
    padding-top: 200px;
    color: #fff;
    font-size: 50px;
  }
&lt;/style&gt;
&lt;div class=&quot;loading&quot;&gt;正在玩命加载中……&lt;/div&gt;
&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 3、jQuery全局事件处理函数
/*
$.ajax({
  url: &#39;time.php&#39;,
  beforeSend: function(xhr){
    // 显示加载提示
    $(&#39;.loading&#39;).fadeIn()
    console.log(&#39;即将开始请求&#39;)
  },
  complete: function(xhr){
    // 结束提示
    $(&#39;.loading&#39;).fadeOut()
    console.log(&#39;请求结束了&#39;)
  }
})
*/
// 所有的ajax请求开始和结束
$(document).ajaxStart(function(){
  // 只要有ajax请求发生就会执行
  // 显示加载提示
  $(&#39;.loading&#39;).fadeIn()
  console.log(&#39;即将开始请求&#39;)
})
$(document).ajaxStop(function(){
  // 只要有ajax请求发生就会执行
  // 显示加载提示
  $(&#39;.loading&#39;).fadeOut()
  console.log(&#39;请求结束了&#39;)
})
$(&#39;body&#39;).on(&#39;click&#39;, function(){
  // $.ajax({
  //   url: &#39;time.php&#39;
  // })
  $.get(&#39;time.php&#39;)
})
&lt;/script&gt;</code></pre>
<p>可以写成链式的：</p>
<pre><code class="javascript">$(document)
  .ajaxStart(function(){
    ……
  })
  .ajaxStop(function(){
    ……
  })</code></pre>
<p>搭配NProgress</p>
<pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/nprogress@0.2.0/nprogress.css&quot;&gt;
&lt;script src=&quot;https://unpkg.com/nprogress@0.2.0/nprogress.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;margin-top: 100px;text-align: center;&quot;&gt;点击加载&lt;/div&gt;
&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 3、jQuery全局事件处理函数搭配nprogress
// 所有的ajax请求开始和结束
$(document)
  .ajaxStart(function(){
    // 只要有ajax请求发生就会执行
    NProgress.start()
  })
  .ajaxStop(function(){
    // 只要有ajax请求发生就会执行
    NProgress.done()
  })
$(&#39;body&#39;).on(&#39;click&#39;, function(){
  $.get(&#39;time.php&#39;)
})
&lt;/script&gt;
&lt;/body&gt;</code></pre>
<h3 id="3、axios"><a href="#3、axios" class="headerlink" title="3、axios"></a>3、axios</h3><p>(1) 使用教程：<a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/</a></p>
<p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<p>(2) 特性</p>
<ul>
<li>从浏览器中创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequests</a></li>
<li>从 node.js 创建 <a href="http://nodejs.org/api/http.html" target="_blank" rel="noopener">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">XSRF</a></li>
</ul>
<p>(3) 安装</p>
<p>使用 npm:</p>
<pre><code class="sh">$ npm install axios</code></pre>
<p>使用 bower:</p>
<pre><code class="bash">$ bower install axios</code></pre>
<p>使用 cdn:</p>
<pre><code class="html">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>(4) 案例</p>
<p><code>server.js</code></p>
<pre><code class="javascript">//axios 服务
app.all(&#39;/axios-server&#39;, (request, response) =&gt; {
    //设置响应头  设置允许跨域
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);
    // response.send(&#39;Hello jQuery AJAX&#39;);
    const data = {name:&#39;wallleap&#39;};
    response.send(JSON.stringify(data));
});</code></pre>
<p>axios发送Ajax请求</p>
<pre><code class="html">&lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.js&quot;&gt;&lt;/script&gt;
&lt;button&gt;GET&lt;/button&gt;
&lt;button&gt;POST&lt;/button&gt;
&lt;button&gt;AJAX&lt;/button&gt;
&lt;script&gt;
  // https://github.com/axios/axios
  const btns = document.querySelectorAll(&#39;button&#39;);
  //配置 baseURL
  axios.defaults.baseURL = &#39;http://127.0.0.1:8000&#39;;
  btns[0].onclick = function () {
    //GET 请求 get(url, 其它配置)
    // axios.get(&#39;http://127.0.0.1:8000/axios-server&#39;, {
    axios.get(&#39;/axios-server&#39;, { // 配置了baseURL
      //url 参数——&gt;id=100&amp;vip=7
      params: {
        id: 100,
        vip: 7
      },
      //请求头信息
      headers: {
        name: &#39;wallleap&#39;,
        age: 20
      }
    }).then(value =&gt; { // 基于promise 处理返回结果 value.config、data、headers、request、status、statusText
      console.log(value);
    });
  }
  btns[1].onclick = function () {
    // POST请求 post(url, 请求体, 其它配置)
    axios.post(&#39;/axios-server&#39;, { // 请求体
      username: &#39;admin&#39;,
      password: &#39;password&#39;
    }, {
      //url 
      params: {
        id: 200,
        vip: 9
      },
      //请求头参数
      headers: {
        height: 180,
        weight: 180,
      }
    }).then(response=&gt;{
      // 配置
      console.log(response.config);
      // XMLHttpRequest
      console.log(response.request);
      //响应状态码
      console.log(response.status);
      //响应状态字符串
      console.log(response.statusText);
      //响应头信息
      console.log(response.headers);
      //响应体
      console.log(response.data);
    })
  }
  btns[2].onclick = function(){
    // 通用方式 axios(对象) --&gt; {method, url, 参数, 头信息, 请求体参数}
    axios({
      //请求方法
      method : &#39;POST&#39;,
      //url
      url: &#39;/axios-server&#39;,
      //url参数
      params: {
        vip:10,
        level:30
      },
      //头信息
      headers: {
        a:100,
        b:200
      },
      //请求体参数
      data: {
        username: &#39;admin&#39;,
        password: &#39;password&#39;
      }
    }).then(response=&gt;{
      //响应状态码
      console.log(response.status);
      //响应状态字符串
      console.log(response.statusText);
      //响应头信息
      console.log(response.headers);
      //响应体
      console.log(response.data);
    }).catch(function (error) {
      console.log(error);
    })
  }
&lt;/script&gt;</code></pre>
<h2 id="4、fetch"><a href="#4、fetch" class="headerlink" title="4、fetch"></a>4、fetch</h2><p>fetch使用：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></p>
<p>fetch发送AJAX请求</p>
<p><code>server.js</code></p>
<pre><code class="javascript">//fetch 服务
app.all(&#39;/fetch-server&#39;, (request, response) =&gt; {
    //设置响应头  设置允许跨域
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;);
    // response.send(&#39;Hello jQuery AJAX&#39;);
    const data = {name:&#39;wallleap&#39;};
    response.send(JSON.stringify(data));
});</code></pre>
<pre><code class="html">&lt;button&gt;AJAX请求&lt;/button&gt;
&lt;script&gt;
  //文档地址
  //https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch
  const btn = document.querySelector(&#39;button&#39;);
  btn.onclick = function(){
    fetch(&#39;http://127.0.0.1:8000/fetch-server?vip=10&#39;, {
      //请求方法
      method: &#39;POST&#39;,
      //请求头
      headers: {
        name:&#39;atguigu&#39;
      },
      //请求体
      body: &#39;username=admin&amp;password=admin&#39;
    }).then(response =&gt; {
      // return response.text();
      return response.json();
    }).then(response=&gt;{
      console.log(response);
    });
  }
&lt;/script&gt;</code></pre>
<h2 id="五、跨域"><a href="#五、跨域" class="headerlink" title="五、跨域"></a>五、跨域</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>(1) 同源策略(Same-Origin Policy)：最早由Netscape公司提出，是浏览器的一种安全策略，所谓同源是指<strong>协议、域名、端口</strong>完全相同，只有同源的地址才可以相互通过AJAX的方式请求。</p>
<p>下面来一个同源的案例：</p>
<p>重写一个<code>server.js</code></p>
<pre><code class="javascript">const express = require(&#39;express&#39;);
const app = express();
app.get(&#39;/home&#39;, (request, response)=&gt;{
    //响应一个页面
    response.sendFile(__dirname + &#39;/index.html&#39;);
});
app.get(&#39;/data&#39;, (request, response)=&gt;{
    response.send(&#39;用户数据&#39;);
});
app.listen(9000, ()=&gt;{
    console.log(&quot;服务已经启动...&quot;);
});</code></pre>
<p>运行起来</p>
<pre><code class="sh">nodemon server.js</code></pre>
<p>在这个目录下新建<code>index.html</code></p>
<pre><code class="html">&lt;h1&gt;wallleap&lt;/h1&gt;
&lt;button&gt;点击获取用户数据&lt;/button&gt;
&lt;script&gt;
  const btn = document.querySelector(&#39;button&#39;);
  btn.onclick = function(){
    const x = new XMLHttpRequest();
    //这里因为是满足同源策略的, 所以 url 可以简写
    x.open(&quot;GET&quot;,&#39;/data&#39;);
    //发送
    x.send();
    //
    x.onreadystatechange = function(){
      if(x.readyState === 4){
        if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300){
          console.log(x.response);
        }
      }
    }
  }
&lt;/script&gt;</code></pre>
<p>访问<a href="http://127.0.0.1:9000/home，可以访问这个index.html，点击按钮可以获取到数据" target="_blank" rel="noopener">http://127.0.0.1:9000/home，可以访问这个index.html，点击按钮可以获取到数据</a></p>
<p>(2) 同源或者不同源说的是两个地址之间的关系，不同源地址之间请求我们称之为跨域请求。</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190430.png" alt="image-20200815190429165" class="lazyload"></p>
<p>跨域的案例：</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190440.png" alt="image-20200815190439633" class="lazyload"></p>
<p>跨域会报错：</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190456.png" alt="image-20200815190455302" class="lazyload"></p>
<h3 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>不同源地址之间如果需要相互请求，必须服务端和客户端配合才能完成</p>
<p>尝试找到一种可以发送不同源请求的方式</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190529.png" alt="可能可以解决跨域的方法" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190556.png" alt="正常图片标签" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190621.png" alt="尝试使用img标签解决跨域" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190650.png" alt="正常link标签" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190712.png" alt="尝试使用link标签解决跨域" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190738.png" alt="尝试使用script标签解决跨域" class="lazyload"></p>
<p>初级跨域解决方案</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190812.png" alt="服务器端将json用函数包裹返回" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815190858.png" alt="客户端使用该函数拿到数据" class="lazyload"></p>
<p>(1) <strong>JSONP</strong></p>
<p>JSON with Padding，是一种借助于<code>script</code>标签发送跨域请求的技巧。这个是非官方的跨域解决方案，是程序员们机智地想出来的，只支持get请求。</p>
<p>其原理就是在客户端借助<code>script</code>标签请求服务端的一个动态网页(php等)，服务端的这个动态网页返回一段带有函数调用的JavaScript全局函数调用的脚本，将原本需要返回给客户端的数据传递进去。</p>
<p>以后绝大多数情况都是采用JSONP的手段完成不同源地址之间的跨域请求。</p>
<ul>
<li>原理演示：</li>
</ul>
<p>当前目录下，新建<code>js/app.js</code></p>
<pre><code class="javascript">const data = {
    name: &#39;测试jsonp&#39;
};
/* 把这个挪走，到测试的html文件中
//处理数据
    function handle(data) {
        //获取 result 元素
        const result = document.getElementById(&#39;result&#39;);
        result.innerHTML = data.name;
    }
*/
handle(data);</code></pre>
<p>html</p>
<pre><code class="html">&lt;style&gt;
  #result {
    width: 300px;
    height: 100px;
    border: solid 1px #78a;
  }
&lt;/style&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    //处理数据
    function handle(data) {
        //获取 result 元素
        const result = document.getElementById(&#39;result&#39;);
        result.innerHTML = data.name;
    }
&lt;/script&gt;
&lt;!-- &lt;script src=&quot;http://127.0.0.1:5500/jsonp/js/app.js&quot;&gt;&lt;/script&gt; --&gt; &lt;!-- 利用file://方式访问这个html页面 --&gt;
&lt;!-- 进阶版 --&gt;
&lt;script src=&quot;http://127.0.0.1:8000/jsonp-server&quot;&gt;&lt;/script&gt;</code></pre>
<p><code>server.js</code></p>
<pre><code class="javascript">//jsonp服务
app.all(&#39;/jsonp-server&#39;,(request, response) =&gt; {
    // response.send(&#39;console.log(&quot;hello jsonp&quot;)&#39;); // 前端拿到js代码
    const data = {
        name: &#39;测试jsonp&#39;
    };
    //将数据转化为字符串
    let str = JSON.stringify(data);
    //返回结果
    response.end(`handle(${str})`); // 会返回一个函数调用，实参是想返回给前端的数据(前端需要先声明这个函数)
});</code></pre>
<ul>
<li>用php演示一下</li>
</ul>
<p><code>server.php</code></p>
<pre><code class="php">&lt;?php
$conn = mysqli_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;123456&#39;, &#39;demo&#39;);
$query = mysqli_query($conn, &#39;select * from users&#39;);
while ($row = mysqli_fetch_assoc($query)) {
  $data[] = $row;
}
if (empty($_GET[&#39;callback&#39;])) {
  header(&#39;Content-Type: application/json&#39;);
  echo json_encode($data);
  exit();
}
// 如果客户端采用的是 script 标记对我发送的请求
// 一定要返回一段 JavaScript
header(&#39;Content-Type: application/javascript&#39;);
$result = json_encode($data);
$callback_name = $_GET[&#39;callback&#39;];
echo &quot;typeof {$callback_name} === &#39;function&#39; &amp;&amp; {$callback_name}({$result})&quot;;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815191014.png" alt="image-20200815191013064" class="lazyload"></p>
<ul>
<li>原生方式实践jsonp</li>
</ul>
<p><code>server.js</code></p>
<pre><code class="javascript">//用户名检测是否存在
app.all(&#39;/check-username&#39;,(request, response) =&gt; {
    // response.send(&#39;console.log(&quot;hello jsonp&quot;)&#39;);
    const data = {
        exist: 1,
        msg: &#39;用户名已经存在&#39;
    };
    //将数据转化为字符串
    let str = JSON.stringify(data);
    //返回结果
    response.end(`handle(${str})`);
});</code></pre>
<p>前端代码：</p>
<pre><code class="html">用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;p&gt;&lt;/p&gt;
&lt;script&gt;
  //获取 input 元素
  const input = document.querySelector(&#39;input&#39;);
  const p = document.querySelector(&#39;p&#39;);
  //声明 handle 函数
  function handle(data){
    input.style.border = &quot;solid 1px #f00&quot;;
    //修改 p 标签的提示文本
    p.innerHTML = data.msg;
  }
  //绑定事件
  input.onblur = function(){
    //获取用户的输入值
    let username = this.value;
    //向服务器端发送请求 检测用户名是否存在
    //1. 创建 script 标签
    const script = document.createElement(&#39;script&#39;);
    //2. 设置标签的 src 属性
    script.src = &#39;http://127.0.0.1:8000/check-username&#39;;
    //3. 将 script 插入到文档中
    document.body.appendChild(script);
  }
&lt;/script&gt;</code></pre>
<ul>
<li>封装成一个函数</li>
</ul>
<pre><code class="javascript">function jsonp (url, params, callback) {
  var funcName = &#39;jsonp_&#39; + Date.now() + Math.random().toString().substr(2, 5)

  if (typeof params === &#39;object&#39;) {
    var tempArr = []
    for (var key in params) {
      var value = params[key]
      tempArr.push(key + &#39;=&#39; + value)
    }
    params = tempArr.join(&#39;&amp;&#39;)
  }

  var script = document.createElement(&#39;script&#39;)
  script.src = url + &#39;?&#39; + params + &#39;&amp;callback=&#39; + funcName
  document.body.appendChild(script)

  window[funcName] = function (data) {
    callback(data)

    delete window[funcName]
    document.body.removeChild(script)
  }
}

jsonp(&#39;http://localhost/jsonp/server.php&#39;, { id: 123 }, function (res) {
  console.log(res)
})

jsonp(&#39;http://localhost/jsonp/server.php&#39;, { id: 123 }, function (res) {
  console.log(res)
})</code></pre>
<ul>
<li>jQuery方式实践jsonp</li>
</ul>
<p><code>server.js</code></p>
<pre><code class="javascript">// jQuery jsonp
app.all(&#39;/jquery-jsonp-server&#39;,(request, response) =&gt; {
  // response.send(&#39;console.log(&quot;hello jsonp&quot;)&#39;);
  const data = {
    name:&#39;尚硅谷&#39;,
    city: [&#39;北京&#39;,&#39;上海&#39;,&#39;深圳&#39;]
  };
  //将数据转化为字符串
  let str = JSON.stringify(data);
  //接收 callback 参数
  let cb = request.query.callback; // 函数名从前端获取
  //返回结果
  response.end(`${cb}(${str})`);
});</code></pre>
<p>前端代码：</p>
<pre><code class="html">&lt;style&gt;
  #result{
    width:300px;
    height:100px;
    border:solid 1px #089;
  }
&lt;/style&gt;
&lt;script crossorigin=&quot;anonymous&quot; src=&#39;https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js&#39;&gt;&lt;/script&gt;
&lt;button&gt;点击发送 jsonp 请求&lt;/button&gt;
&lt;div id=&quot;result&quot;&gt;

&lt;/div&gt;
&lt;script&gt;
  $(&#39;button&#39;).eq(0).click(function(){
    $.getJSON(&#39;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#39;, function(data){
      $(&#39;#result&#39;).html(`
                名称: ${data.name}&lt;br&gt;
                校区: ${data.city}
            `)
    });
  });
&lt;/script&gt;</code></pre>
<p>(2)CORS</p>
<p>HTTP访问控制（CORS）<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p>
<p>Cross Origin Resource Share，跨域资源共享。CORS是官方的跨域解决方案，它的特点是不需要再客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求(其他也支持)。跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。</p>
<p>CORS是通过设置一个响应头来告诉浏览器，这个请求允许跨域，浏览器收到该响应以后就会对响应放行。</p>
<p><code>server.js</code></p>
<pre><code class="javascript">app.all(&#39;/cors-server&#39;, (request, response)=&gt;{
  //设置响应头
  response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 允许所有源站发送请求
  response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &#39;*&#39;); // 允许携带的响应头
  response.setHeader(&quot;Access-Control-Allow-Method&quot;, &#39;*&#39;); // 允许请求方法
  // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;); // 允许单个
  response.send(&#39;hello CORS&#39;);
});</code></pre>
<p>测试：</p>
<pre><code class="html">&lt;style&gt;
    #result{
        width:200px;
        height:100px;
        border:solid 1px #90b;
    }
&lt;/style&gt;
&lt;button&gt;发送请求&lt;/button&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;script&gt;
  const btn = document.querySelector(&#39;button&#39;);
  btn.onclick = function(){
    //1. 创建对象
    const x = new XMLHttpRequest();
    //2. 初始化设置
    x.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/cors-server&quot;);
    //3. 发送
    x.send();
    //4. 绑定事件
    x.onreadystatechange = function(){
      if(x.readyState === 4){
        if(x.status &gt;= 200 &amp;&amp; x.status &lt; 300){
          //输出响应体
          console.log(x.response);
        }
      }
    }
  }
&lt;/script&gt;</code></pre>
<pre><code class="php">// 允许远端访问(甚至直接打开文件的方式也可以file://……)
header(&#39;Access-Control-Allow-Origin: *&#39;) // 允许所有
header(&#39;Access-Control-Allow-Origin: http://localhost/index.html&#39;) // 允许单个</code></pre>
<p>eg:</p>
<pre><code class="php">&lt;?php

$conn = mysqli_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;123456&#39;, &#39;demo&#39;);

$query = mysqli_query($conn, &#39;select * from users&#39;);

while ($row = mysqli_fetch_assoc($query)) {
  $data[] = $row;
}

// 一行代码搞定
// 允许跨域请求
header(&#39;Access-Control-Allow-Origin: *&#39;);

header(&#39;Content-Type: application/json&#39;);
echo json_encode($data);</code></pre>
<p>客户端</p>
<pre><code class="html">&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $.get(&#39;http://localhost/cors.php&#39;, {}, function (res) {
    console.log(res)
  })
&lt;/script&gt;</code></pre>
<p>这种方案无序客户端作出任何变化(不用改代码)，只是在被请求的服务端响应的时候<strong>添加一个<code>Access-Control-Allow-Origin</code>的响应头</strong>，表示这个资源是否允许指定域请求。</p>
<h2 id="六、XMLHttpRequest2-0"><a href="#六、XMLHttpRequest2-0" class="headerlink" title="六、XMLHttpRequest2.0"></a>六、XMLHttpRequest2.0</h2><blockquote>
<p>暂作了解，无需着重看待</p>
</blockquote>
<p>更易用，更强大。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/12/React/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="React全家桶(技术栈)学习笔记" class="lazyload">
                    <h1>React全家桶(技术栈)学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月12日</a>
            <a><i class="nexmoefont icon-areachart"></i>19.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 101 分钟</a>
        </div>

        <article>
            
                <h1 id="第1章-React入门"><a href="#第1章-React入门" class="headerlink" title="第1章 React入门"></a>第1章 React入门</h1><h2 id="1-1-React的基本认识"><a href="#1-1-React的基本认识" class="headerlink" title="1.1 React的基本认识"></a>1.1 React的基本认识</h2><h3 id="1-1-1-官网"><a href="#1-1-1-官网" class="headerlink" title="1.1.1 官网"></a>1.1.1 官网</h3><p>1)     英文官网:<a href="https://reactjs.org/" target="_blank" rel="noopener"> https://reactjs.org/</a></p>
<p>2)     中文官网: <a href="https://doc.react-china.org/" target="_blank" rel="noopener">https://doc.react-china.org/</a></p>
<h3 id="1-1-2-介绍描述"><a href="#1-1-2-介绍描述" class="headerlink" title="1.1.2 介绍描述"></a>1.1.2 介绍描述</h3><p>1)     用于构建用户界面的 JavaScript 库(只关注于View)</p>
<ul>
<li>JS库：<ul>
<li>jQuery——函数库(方法、函数包装DOM操作)</li>
<li>React 基本上不操作DOM——JS框架</li>
</ul>
</li>
<li>构建用户界面：把数据展现出来</li>
</ul>
<p>2)     由<strong>Facebook</strong>开源</p>
<h3 id="1-1-3-React的特点"><a href="#1-1-3-React的特点" class="headerlink" title="1.1.3 React的特点"></a>1.1.3 React的特点</h3><p>1)     Declarative(声明式编码)</p>
<p>（申请一块内存，只需要声明一个变量即可）不需要亲自操作DOM，只需要告诉它，我要更新，就会帮你更新，只需要更新数据，界面不需要手动更新（以前需要更新DOM）</p>
<p>2)     Component-Based(组件化编码)</p>
<p>简化特别复杂的功能，可以拆分为多个简单的部分（一个小的界面功能就是一个组件），维护也方便</p>
<p>3)     Learn Once, Write Anywhere(支持客户端与服务器渲染)</p>
<p>一次学习，随处编写：不仅能写web应用，还能写React Native打包为Android、IOS应用</p>
<p>4)     高效</p>
<p>5)     单向数据流</p>
<h3 id="1-1-4-React高效的原因-区域、次数——更新界面效率提高"><a href="#1-1-4-React高效的原因-区域、次数——更新界面效率提高" class="headerlink" title="1.1.4 React高效的原因(区域、次数——更新界面效率提高)"></a>1.1.4 React高效的原因(区域、次数——更新界面效率提高)</h3><p>1)     <strong>虚拟(virtual)DOM</strong>,，不总是直接操作DOM</p>
<ul>
<li>虚拟DOM：对象——与组件对应，修改映射到真实的DOM上(批量修改、界面重绘<strong>次数少</strong>)</li>
</ul>
<p>2)     <strong>DOM Diff算法</strong>,，最小化页面重绘</p>
<ul>
<li>界面中组件是否更新(更新<strong>区域小</strong>)</li>
</ul>
<h2 id="1-2-React的基本使用"><a href="#1-2-React的基本使用" class="headerlink" title="1.2 React的基本使用"></a>1.2 React的基本使用</h2><p>注意: 此时只是测试语法使用, 并不是真实项目开发使用</p>
<h3 id="1-2-1-效果"><a href="#1-2-1-效果" class="headerlink" title="1.2.1 效果"></a>1.2.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react1592556203130.png" alt="React基本使用" class="lazyload"></p>
<p>将h1标签利用react放到test中</p>
<h3 id="1-2-3-相关js库"><a href="#1-2-3-相关js库" class="headerlink" title="1.2.3 相关js库"></a>1.2.3 相关js库</h3><p>可以到bootcdn引用地址，访问链接<kbd>Ctrl</kbd>+<kbd>S</kbd>保存到本地</p>
<p>1)     <code>react.js</code>: React的核心库</p>
<ul>
<li>development.js：开发版，开发编写的时候使用</li>
<li>production.min.js：生产版，上线的时候使用，压缩过的</li>
</ul>
<p>2)     <code>react-dom.js</code>: 提供操作DOM的react扩展库</p>
<p>3)     <code>babel.min.js</code>: 解析JSX语法代码转为纯JS语法代码的库,这里不是ES6转ES5(jsx是js扩展语法)</p>
<h3 id="1-2-4-在页面中导入js"><a href="#1-2-4-在页面中导入js" class="headerlink" title="1.2.4 在页面中导入js"></a>1.2.4 在页面中导入js</h3><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<h3 id="1-2-5-编码"><a href="#1-2-5-编码" class="headerlink" title="1.2.5 编码"></a>1.2.5 编码</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;01_HelloWorld&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

  &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/babel&quot;&gt;/*告诉babel.js解析里面的jsx的代码*/
    // 1. 创建虚拟DOM元素对象
    var vDom = &lt;h1&gt;Hello React!&lt;/h1&gt;   // jsx，不是字符串，不能加引号
    // 2. 将虚拟DOM渲染到页面真实DOM容器中
    ReactDOM.render(vDom, document.getElementById(&#39;test&#39;))  // react-dom.js提供的  render——渲染   将vDom加入到#test中
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="1-2-6-使用React开发者工具调试"><a href="#1-2-6-使用React开发者工具调试" class="headerlink" title="1.2.6 使用React开发者工具调试"></a>1.2.6 使用React开发者工具调试</h3><p>​          <img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react2.gif" alt="React开发调试插件" class="lazyload">  </p>
<p>React Developer Tool.crx</p>
<h2 id="1-3-React-JSX"><a href="#1-3-React-JSX" class="headerlink" title="1.3 React JSX"></a>1.3 React JSX</h2><h3 id="1-3-1-效果"><a href="#1-3-1-效果" class="headerlink" title="1.3.1 效果"></a>1.3.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react1592556978982.png" alt="ReactJSX" class="lazyload"></p>
<p>两个#test分别加入相应内容</p>
<p>代码：</p>
<pre><code class="html">&lt;div id=&quot;test1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;

&lt;script src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt; // 还没用到jsx语法，不需要babel
  const msg = &#39;I Like You!&#39;
  const myId = &#39;Atguigu&#39;

  // 1.创建虚拟DOM
  // var element = React.createElement(&#39;h1&#39;, {id:&#39;myTitle&#39;},&#39;hello&#39;)
  const vDom1 = React.createElement(&#39;h2&#39;, {id:myId.toLowerCase()},msg.toUpperCase())
  // 2.渲染虚拟DOM
  ReactDOM.render(vDom1, document.getElementById(&#39;test1&#39;))
&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
  // 1.创建虚拟DOM
  const vDom2 = &lt;h3 id={myId.toUpperCase()}&gt;{msg.toLowerCase()}&lt;/h3&gt;  // 变量用{}括起来
  // 2.渲染虚拟DOM
  ReactDOM.render(vDom2, document.getElementById(&#39;test2&#39;))
&lt;/script&gt;</code></pre>
<h3 id="1-3-2-虚拟DOM"><a href="#1-3-2-虚拟DOM" class="headerlink" title="1.3.2 虚拟DOM"></a>1.3.2 虚拟DOM</h3><p>1)     React提供了一些API来创建一种 <strong>特别</strong> 的一般js对象</p>
<p>a.     <code>var element = React.createElement(&#39;h1&#39;, {id:&#39;myTitle&#39;},&#39;hello&#39;)</code></p>
<p>b.     上面创建的就是一个简单的虚拟DOM对象，babel将会把jsx语法转为上述的形式</p>
<p>2)     虚拟DOM对象最终都会被React<strong>转换为</strong>真实的DOM（虚拟DOM中的对应真实DOM中的标签元素）</p>
<p>3)     我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界面</p>
<p>补充知识：<code>debugger</code>可以在某条js代码处添加断点</p>
<p>虚拟DOM——轻对象，更新虚拟DOM页面不重绘</p>
<p>真实DOM——重对象，更新真实DOM页面会发生变化（页面重绘）</p>
<h3 id="1-3-3-JSX"><a href="#1-3-3-JSX" class="headerlink" title="1.3.3 JSX"></a>1.3.3 JSX</h3><p>1)     全称: JavaScript XML</p>
<p>2)     react定义的一种类似于XML的<strong>JS扩展语法</strong>: XML+JS</p>
<p>3)     作用: 用来创建react虚拟DOM(元素)对象</p>
<ul>
<li><p><code>var ele = &lt;h1&gt;Hello JSX!&lt;/h1&gt;</code></p>
</li>
<li><p>注意1: 它不是字符串, 也不是HTML/XML标签</p>
</li>
<li><p>注意2: 它最终产生的就是一个JS对象</p>
</li>
</ul>
<p>4)     <strong>标签名任意</strong>: HTML标签或其它标签</p>
<p>5)     标签属性任意: HTML标签属性或其它</p>
<p>6)     基本语法规则</p>
<ul>
<li><p><strong>遇到 &lt;开头</strong>的代码, 以<strong>标签</strong>的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析</p>
</li>
<li><p><strong>遇到以 { 开头</strong>的代码，以<strong>JS语法</strong>解析: 标签中的js代码必须用{ }包含</p>
</li>
</ul>
<p>7)     babel.js的作用</p>
<ul>
<li><p>浏览器不能直接解析JSX代码, 需要<strong>babel转译为纯JS的代码</strong>才能运行</p>
</li>
<li><p>只要用了JSX，都要加上<code>type=&quot;text/babel&quot;</code>, 声明需要babel来处理</p>
</li>
</ul>
<h3 id="1-3-4-渲染虚拟DOM-元素"><a href="#1-3-4-渲染虚拟DOM-元素" class="headerlink" title="1.3.4 渲染虚拟DOM(元素)"></a>1.3.4 渲染虚拟DOM(元素)</h3><p>1)     语法: <code>ReactDOM.render(virtualDOM, containerDOM)</code></p>
<p>2)     作用: 将虚拟DOM元素渲染到页面中的真实容器DOM中显示</p>
<p>3)     参数说明</p>
<ul>
<li><p>参数一: 纯js或jsx创建的虚拟dom对象</p>
</li>
<li><p>参数二: 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div)</p>
</li>
</ul>
<h3 id="1-3-5-建虚拟DOM的2种方式"><a href="#1-3-5-建虚拟DOM的2种方式" class="headerlink" title="1.3.5 建虚拟DOM的2种方式"></a>1.3.5 建虚拟DOM的2种方式</h3><p>1)     纯JS(一般不用)</p>
<p><code>React.createElement(&#39;h1&#39;, {id:&#39;myTitle&#39;}, title)</code></p>
<p>2)     <strong>JSX</strong>:</p>
<p><code>&lt;h1 id=&#39;myTitle&#39;&gt;{title}&lt;/h1&gt;</code></p>
<h3 id="1-3-6-JSX练习"><a href="#1-3-6-JSX练习" class="headerlink" title="1.3.6 JSX练习"></a>1.3.6 JSX练习</h3><p>需求: 动态展示列表数据</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react1592558986188.png" alt="JSX" class="lazyload"></p>
<p>代码：</p>
<pre><code class="html">&lt;h2&gt;前端JS框架列表&lt;/h2&gt;
&lt;div id=&quot;example1&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
  /*
    功能: 动态展示列表数据
    - 如何将一个数据的数组，转换为一个标签的数组
      使用数组的map()方法
  */
  // 数据：名称、类型，数组存放
  const names = [&#39;jQuery&#39;, &#39;zepto&#39;, &#39;angular&#39;, &#39;react&#39;, &#39;vue&#39;]
  // 1.创建虚拟DOM，有嵌套结构，最好用小括号括起来
  const ul = (
    &lt;ul&gt;
      {
        names.map((name, index) =&gt; &lt;li key={index}&gt;{name}&lt;/li&gt;)
      }
    &lt;/ul&gt;
  )
  // 2.渲染虚拟DOM
  ReactDOM.render(ul, document.getElementById(&#39;example1&#39;))
&lt;/script&gt;</code></pre>
<h2 id="1-4-模块与组件和模块化与组件化的理解"><a href="#1-4-模块与组件和模块化与组件化的理解" class="headerlink" title="1.4 模块与组件和模块化与组件化的理解"></a>1.4 模块与组件和模块化与组件化的理解</h2><h3 id="1-4-1-模块"><a href="#1-4-1-模块" class="headerlink" title="1.4.1 模块"></a>1.4.1 模块</h3><p>1)     理解: 向外<strong>提供特定功能的</strong>js程序, 一般就是一个<strong>js文件</strong></p>
<p>2)     为什么: js代码更多更复杂</p>
<p>3)     作用: 复用js, 简化js的编写, 提高js运行效率</p>
<p>有特定功能的js文件，内部有数据及对数据的操作</p>
<ul>
<li><p>数据：变量</p>
</li>
<li><p>操作：函数</p>
</li>
</ul>
<p>私有的函数向外暴露</p>
<ul>
<li>暴露一个函数：暴露函数本身</li>
<li>暴露多个函数：以对象形式暴露</li>
</ul>
<h3 id="1-4-2-组件"><a href="#1-4-2-组件" class="headerlink" title="1.4.2 组件"></a>1.4.2 组件</h3><p>1)     理解: 用来<strong>实现特定(局部)功能效果</strong>的<strong>代码</strong>集合(html/css/js)</p>
<p>2)     为什么: 一个界面的功能更复杂</p>
<p>3)     作用: 复用编码, 简化项目编码, 提高运行效率</p>
<h3 id="1-4-3-模块化"><a href="#1-4-3-模块化" class="headerlink" title="1.4.3 模块化"></a>1.4.3 模块化</h3><p>当应用的<strong>js都以模块来编写</strong>的, 这个应用就是一个模块化的应用</p>
<p>形容项目或编码</p>
<h3 id="1-4-4-组件化"><a href="#1-4-4-组件化" class="headerlink" title="1.4.4 组件化"></a>1.4.4 组件化</h3><p>当应用是以多组件的方式实现, 这个应用就是一个组件化的应用</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react1592560823655.png" alt="component" class="lazyload"></p>
<h1 id="第2章-React面向组件编程"><a href="#第2章-React面向组件编程" class="headerlink" title="第2章 React面向组件编程"></a>第2章 React面向组件编程</h1><p>面向对象——面向模块——面向组件</p>
<h2 id="2-1-基本理解和使用"><a href="#2-1-基本理解和使用" class="headerlink" title="2.1 基本理解和使用"></a>2.1 基本理解和使用</h2><h3 id="2-1-1-效果"><a href="#2-1-1-效果" class="headerlink" title="2.1.1 效果"></a>2.1.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react1592561100045.png" alt="组件" class="lazyload"></p>
<p>组件标签：可以随便取的标签，首字母大写，与HTML标签区分开</p>
<h3 id="2-1-2-自定义组件-Component"><a href="#2-1-2-自定义组件-Component" class="headerlink" title="2.1.2 自定义组件(Component) :"></a>2.1.2 自定义组件(Component) :</h3><p>1)     定义组件(2种方式)</p>
<p>  方式1: <strong>工厂函数组件(简单组件：没有状态的组件)</strong>——效率高，不需要创建对象</p>
<pre><code>function MyComponent(){
    return &lt;h2&gt;工厂函数组件(简单组件)&lt;/h2&gt;
}</code></pre><p>方式2: <strong>ES6类组件(复杂组件)</strong>——需要创建对象，有了状态只能使用这种方式</p>
<pre><code class="javascript">class MyComponent2 extends React.Component{
  render(){
    console.log(this)  // 组件类对象 MyComponent2{...}
    return &lt;h2&gt;ES6类组件(复杂组件)&lt;/h2&gt;
  }
}</code></pre>
<p>2)     渲染组件标签</p>
<pre><code class="JavaScript">ReactDOM.render(&lt;MyComponent  /&gt;, document.getElementById(&#39;example1&#39;))
ReactDOM.render(&lt;MyComponent2  /&gt;, document.getElementById(&#39;example2&#39;))</code></pre>
<h3 id="2-1-3-注意"><a href="#2-1-3-注意" class="headerlink" title="2.1.3 注意"></a>2.1.3 注意</h3><p>1)     组件名必须首字母大写</p>
<p>2)     虚拟DOM元素只能有一个根元素</p>
<p>3)     虚拟DOM元素必须有结束标签</p>
<h3 id="2-1-4-render-渲染组件标签的基本流程"><a href="#2-1-4-render-渲染组件标签的基本流程" class="headerlink" title="2.1.4 render()渲染组件标签的基本流程"></a>2.1.4 render()渲染组件标签的基本流程</h3><p>1)     React内部会创建组件实例对象</p>
<p>2)     得到包含的虚拟DOM并解析为真实DOM</p>
<p>3)     插入到指定的页面元素内部</p>
<h2 id="2-2-组件三大属性1-state"><a href="#2-2-组件三大属性1-state" class="headerlink" title="2.2 组件三大属性1: state"></a>2.2 组件三大属性1: state</h2><h3 id="2-2-1-效果"><a href="#2-2-1-效果" class="headerlink" title="2.2.1 效果"></a>2.2.1 效果</h3><p> <img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/Like%E7%BB%84%E4%BB%B6.gif" alt="state" class="lazyload"></p>
<h3 id="2-2-2-理解"><a href="#2-2-2-理解" class="headerlink" title="2.2.2 理解"></a>2.2.2 理解</h3><p>1)     state是组件对象最重要的属性, 值是对象(可以包含多个数据)</p>
<p>2)     组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</p>
<h3 id="2-2-3-编码操作"><a href="#2-2-3-编码操作" class="headerlink" title="2.2.3 编码操作"></a>2.2.3 编码操作</h3><p>1)     初始化状态:</p>
<pre><code class="javascript">constructor (props) {
  super(props)
  this.state = {
   stateProp1 : value1,
   stateProp2 : value2
  }
}</code></pre>
<p>2)     读取某个状态值</p>
<pre><code class="javascript">this.state.statePropertyName</code></pre>
<p>3)     更新状态—-&gt;组件界面更新</p>
<pre><code class="javascript">this.setState({
  stateProp1 : value1,
  stateProp2 : value2
})</code></pre>
<h3 id="2-2-4-代码"><a href="#2-2-4-代码" class="headerlink" title="2.2.4 代码"></a>2.2.4 代码</h3><pre><code class="html">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
  /*
  需求: 自定义组件, 功能说明如下
    1. 显示h2标题, 初始文本为: 你喜欢我
    2. 点击标题更新为: 我喜欢你
  */
  // 1.定义组件
  class Like extends React.Component {
    constructor(props){
      super(props)
      // 初始化状态
      this.state = {
        isLikeMe: false
      }

      // 将新增方法中的this强制绑定为组件对象
      this.handleClick = this.handleClick.bind(this) // 也可以不在这里绑定
    }

    handleClick(){
      // console.log(this) // handleClick是新添加方法，内部this默认不是组件对象，而是undefined  render是重写组件类的方法 到上面或下面绑定this
      // 得到状态，并取反
      const isLikeMe = !this.state.isLikeMe
      // 更新状态
      this.setState({isLikeMe}) // isLikeMe: isLikeMe
    }
    render() {
      // 读取状态
      // const isLikeMe = this.state.isLikeMe
      const {isLikeMe} = this.state // 解构赋值
      return &lt;h2 onClick={this.handleClick}&gt;{isLikeMe?&#39;你喜欢我&#39;:&#39;我喜欢你&#39;}&lt;/h2&gt; // this——组件对象 // this.handleClick.bind(this) —— 在这里绑定也可以
    }
  }
  // 2.渲染组件标签
  ReactDOM.render(&lt;Like /&gt;, document.getElementById(&#39;example&#39;))
&lt;/script&gt;</code></pre>
<h2 id="2-3-组件三大属性2-props"><a href="#2-3-组件三大属性2-props" class="headerlink" title="2.3 组件三大属性2: props"></a>2.3 组件三大属性2: props</h2><h3 id="2-3-1-效果"><a href="#2-3-1-效果" class="headerlink" title="2.3.1 效果"></a>2.3.1 效果</h3><pre><code>需求: 自定义用来显示一个人员信息的组件
  1). 姓名必须指定
  2). 如果性别没有指定, 默认为男
  3). 如果年龄没有指定, 默认为18</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react-4.png" alt="props" class="lazyload"></p>
<h3 id="2-3-2-理解"><a href="#2-3-2-理解" class="headerlink" title="2.3.2 理解"></a>2.3.2 理解</h3><p>1)     每个组件对象都会有props(properties的简写)属性</p>
<p>2)     组件标签的所有属性都保存在props中</p>
<h3 id="2-3-3-作用"><a href="#2-3-3-作用" class="headerlink" title="2.3.3 作用"></a>2.3.3 作用</h3><p>1)     通过标签属性从组件外向组件内传递变化的数据</p>
<p>2)     注意: 组件内部不要修改props数据</p>
<h3 id="2-3-4-编码操作"><a href="#2-3-4-编码操作" class="headerlink" title="2.3.4 编码操作"></a>2.3.4 编码操作</h3><p>1)     内部读取某个属性值</p>
<p><code>this.props.propertyName</code></p>
<p>2)     对props中的属性值进行类型限制和必要性限制</p>
<blockquote>
<p>注意：</p>
<p>自 React v15.5 起，<code>React.PropTypes</code> 已移入另一个包中。请使用 <a href="https://www.npmjs.com/package/prop-types" target="_blank" rel="noopener"><code>prop-types</code> 库</a> 代替。需要先引入该库。</p>
<p>我们提供了一个 <a href="https://react.docschina.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes" target="_blank" rel="noopener">codemod 脚本</a>来做自动转换。</p>
</blockquote>
<pre><code class="javascript">Person.propTypes = {
    name: React.PropTypes.string.isRequired,
    age: React.PropTypes.number.isRequired
}</code></pre>
<p>3)     扩展属性: 将对象的所有属性通过props传递</p>
<p><code>&lt;Person {...person}/&gt;</code></p>
<p>4)     默认属性值</p>
<pre><code class="javascript">Person.defaultProps = {
    name: &#39;Mary&#39;
}</code></pre>
<p>5)     组件类的构造函数</p>
<pre><code class="javascript">constructor (props) {
    super(props)
    console.log(props) // 查看所有属性

}</code></pre>
<h3 id="2-3-5-代码"><a href="#2-3-5-代码" class="headerlink" title="2.3.5 代码"></a>2.3.5 代码</h3><pre><code class="html">&lt;div id=&quot;example1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;example2&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt; &lt;!-- 验证类型和必要性 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;

  /*
需求: 自定义用来显示一个人员信息的组件, 效果如页面. 说明
  1). 如果性别没有指定, 默认为男
  2). 如果年龄没有指定, 默认为18
  */

  // 1、定义组件
  /*function Person(props){
    return (
      &lt;ul&gt;
        &lt;li&gt;姓名：{props.name}&lt;/li&gt;
        &lt;li&gt;性别：{props.sex}&lt;/li&gt;
        &lt;li&gt;年龄：{props.age}&lt;/li&gt;
      &lt;/ul&gt;
    )
  }*/
  class Person extends React.Component{
    render(){
      return (
        &lt;ul&gt;
          &lt;li&gt;姓名：{this.props.name}&lt;/li&gt;  // this——组件对象
          &lt;li&gt;性别：{this.props.sex}&lt;/li&gt;
          &lt;li&gt;年龄：{this.props.age}&lt;/li&gt;
        &lt;/ul&gt;
      )
    }
  }
  // 指定属性默认值
  Person.defaultProps = {
    sex: &#39;男&#39;,
    age: 18
  }
  // 指定属性值的类型和必要性
  Person.propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number
  }

  // 2、渲染组件标签
  const p1 = {
    name: &#39;Tom&#39;,
    sex: &#39;女&#39;,
    age: 18
  }
  // ReactDOM.render(&lt;Person name={p1.name} sex={p1.sex} age={p1.age}/&gt;, document.getElementById(&#39;example1&#39;))
  ReactDOM.render(&lt;Person {...p1}/&gt;, document.getElementById(&#39;example1&#39;)) // ...作用：1.打包：function fn(...as){} fun(1,2,3) 2.解包：const arr1=[1,2,3] const arr2=[6,...arr1,9] 这里也是在解包
  const p2 = {
    name: &#39;JACK&#39;,
    age: 17
  }
  ReactDOM.render(&lt;Person name={p2.name} age={p2.age}/&gt;, document.getElementById(&#39;example2&#39;))
&lt;/script&gt;</code></pre>
<h3 id="2-3-6-面试题"><a href="#2-3-6-面试题" class="headerlink" title="2.3.6 面试题"></a>2.3.6 面试题</h3><p>问题: 请区别一下组件的props和state属性</p>
<p>1)     state: <strong>组件自身内部可变化的数据</strong></p>
<p><em>2)</em>    props: 从组件外部向组件内部<strong>传递数据</strong>，组件内部只读不修改</p>
<h2 id="2-4-组件三大属性3-refs与事件处理"><a href="#2-4-组件三大属性3-refs与事件处理" class="headerlink" title="2.4 组件三大属性3: refs与事件处理"></a>2.4 组件三大属性3: refs与事件处理</h2><h3 id="2-4-1-效果"><a href="#2-4-1-效果" class="headerlink" title="2.4.1 效果"></a>2.4.1 效果</h3><p>需求: 自定义组件, 功能说明如下:</p>
<ol start="2">
<li>点击按钮, 提示第一个输入框中的值</li>
<li>当第2个输入框失去焦点时, 提示这个输入框中的值</li>
</ol>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/props_event.gif" alt="props_event" class="lazyload"></p>
<h3 id="2-4-2-组件的3大属性之二-refs属性"><a href="#2-4-2-组件的3大属性之二-refs属性" class="headerlink" title="2.4.2 组件的3大属性之二: refs属性"></a>2.4.2 组件的3大属性之二: refs属性</h3><p>1)     组件内的标签都可以定义ref属性来标识自己</p>
<p>a.     &lt;input type=”text” ref={input =&gt; this.msgInput = input}/&gt;</p>
<p>b.     回调函数在组件初始化渲染完或卸载时自动调用</p>
<p>2)     在组件中可以通过this.msgInput来得到对应的真实DOM元素</p>
<p>3)     作用: 通过ref获取组件内容特定标签对象, 进行读取其相关数据</p>
<h3 id="2-4-3-事件处理"><a href="#2-4-3-事件处理" class="headerlink" title="2.4.3 事件处理"></a>2.4.3 事件处理</h3><p>1)     通过onXxx属性指定组件的事件处理函数(注意大小写)</p>
<p>a.     React使用的是自定义(合成)事件, 而不是使用的原生DOM事件</p>
<p>b.     React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)</p>
<p>2)     通过event.target得到发生事件的DOM元素对象</p>
<pre><code>handleFocus(event) {
 event.target // 返回input对象
}</code></pre><h3 id="2-4-4-强烈注意"><a href="#2-4-4-强烈注意" class="headerlink" title="2.4.4 强烈注意"></a>2.4.4 强烈注意</h3><p>1)     组件内置的方法中的this为组件对象</p>
<p>2)     在组件类中自定义的方法中this为null</p>
<p>a.     强制绑定this: 通过函数对象的bind()</p>
<p>b.     箭头函数(ES6模块化编码时才能使用)</p>
<h3 id="2-4-5-代码"><a href="#2-4-5-代码" class="headerlink" title="2.4.5 代码"></a>2.4.5 代码</h3><pre><code class="html">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
  /*
  需求: 自定义组件, 功能说明如下:
    1. 界面如果页面所示
    2. 点击按钮, 提示第一个输入框中的值
    3. 当第2个输入框失去焦点时, 提示这个输入框中的值
 */
  // 1、定义组件 // React中必须要结束标签
  class MyComponent extends React.Component{

    constructor(props){
      super(props)
      this.showInput = this.showInput.bind(this)
      this.handleBlur = this.handleBlur.bind(this)
    }

    showInput(){
      const input = this.refs.content
      // alert(input.value)
      alert(this.input.value)
    }

    handleBlur(event){
      alert(event.target.value)
    }

    render(){
      return(
        &lt;div&gt;
          &lt;input type=&quot;text&quot; ref=&quot;content&quot;/&gt;&amp;nbsp;&amp;nbsp;
          &lt;input type=&quot;text&quot; ref={input =&gt; this.input = input}/&gt;&amp;nbsp;&amp;nbsp;
          &lt;button onClick={this.showInput}&gt;提示输入&lt;/button&gt;&amp;nbsp;&amp;nbsp;
          &lt;input type=&quot;text&quot; placeholder=&quot;失去焦点提示内容&quot; onBlur={this.handleBlur}/&gt;
        &lt;/div&gt;
      )
    }
  }

  // 2、渲染组件标签
  ReactDOM.render(&lt;MyComponent/&gt;, document.getElementById(&#39;example&#39;))
&lt;/script&gt;</code></pre>
<h3 id="2-4-6-区别"><a href="#2-4-6-区别" class="headerlink" title="2.4.6 区别"></a>2.4.6 区别</h3><ol>
<li>state</li>
<li>props</li>
<li>refs</li>
</ol>
<h2 id="2-5-组件的组合"><a href="#2-5-组件的组合" class="headerlink" title="2.5 组件的组合"></a>2.5 组件的组合</h2><h3 id="2-5-1-效果"><a href="#2-5-1-效果" class="headerlink" title="2.5.1 效果"></a>2.5.1 效果</h3><pre><code>功能: 组件化实现此功能
  1. 显示所有todo列表
  2. 输入文本, 点击按钮显示到列表的首位, 并清除输入的文本</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/component%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8.gif" alt="component组合使用" class="lazyload"></p>
<h3 id="2-5-2-功能界面的组件化编码流程-无比重要"><a href="#2-5-2-功能界面的组件化编码流程-无比重要" class="headerlink" title="2.5.2 功能界面的组件化编码流程(无比重要)"></a>2.5.2 功能界面的组件化编码流程(无比重要)</h3><p>1)     拆分组件: 拆分界面,抽取组件</p>
<p>2)     实现静态组件: 使用组件实现静态页面效果(只有静态界面，没有动态数据和交互)</p>
<p>3)     实现动态组件</p>
<ul>
<li><p>实现初始化数据动态显示</p>
</li>
<li><p>实现交互功能(从绑定事件监听开始)</p>
</li>
</ul>
<h3 id="2-5-3-代码"><a href="#2-5-3-代码" class="headerlink" title="2.5.3 代码"></a>2.5.3 代码</h3><pre><code class="html">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  // 静态组件——&gt;动态组件
  /*
  * -名称、类型：todos、数组，Add需要、List需要
  * -数据保存在哪个组件内？
  *   放到App
  *   看数据是某个组件需要(给这个)，还是某些组件需要(给共同的父组件)
  * -需要在子组件中改变父组件的状态
  *    子组件中不能直接改变父组件的状态
  *    状态在哪个组件，更新状态的行为就应该定义在哪个组件，由子组件来调用(通过组件属性传递)
  *    父组件定义函数，传递给子组件，子组件调用
  */
  class App extends React.Component{

    constructor(props){
      super(props)
      // 初始化状态
      this.state = {
        todos: [&#39;吃饭&#39;, &#39;睡觉&#39;, &#39;敲代码&#39;, &#39;打游戏&#39;]
      }

      this.addTodo = this.addTodo.bind(this)  // 没定义加上bind
    }

    addTodo(todo){
      // this.state.todos.unshift(todo) // 不能这样做
      const {todos} = this.state
      todos.unshift(todo)
      // 更新状态
      this.setState({todos})
    }

    render(){
      const {todos} = this.state
      return(
        &lt;div&gt;
          &lt;h1&gt;Simple TODO List&lt;/h1&gt;
          &lt;Add count={todos.length} addTodo={this.addTodo}/&gt;
          &lt;List todos={todos}/&gt;
        &lt;/div&gt;
      )
    //  &lt;List todos={this.state.todos}/&gt; 前面赋值了
    }
  }

  class Add extends React.Component{
    constructor(props){
      super(props)
      this.add = this.add.bind(this)
    }
    add(){
      // 1、读取输入的数据
      const todo = this.todoInput.value.trim()
      // 2、检查合法性
      if(!todo){
        return
      }
      // 3、添加
      this.props.addTodo(todo)
      // 4、清除输入
      this.todoInput.value = &#39;&#39;
    }
    render(){
      return(
        &lt;div&gt;
          &lt;input type=&quot;text&quot; ref={input =&gt; this.todoInput=input}/&gt;
          &lt;button onClick={this.add}&gt;add #{this.props.count+1}&lt;/button&gt;
        &lt;/div&gt;
      )
    }
  }
  Add.propTypes = {
    count: PropTypes.number.isRequired,
    addTodo: PropTypes.func.isRequired
  }

  class List extends React.Component{
    render(){
      return(
        &lt;ul&gt;
          {
            this.props.todos.map((todo, index) =&gt; &lt;li key={index}&gt;{todo}&lt;/li&gt;)
          }
        &lt;/ul&gt;
      )
      /*this.props.todos.map((todo, index) =&gt; {return &lt;li key={index}&gt;{todo}&lt;/li&gt;})*/
      /* 加了大括号需要加return */
    }
  }

  List.protoTypes = {
    todos: PropTypes.array.isRequired
  }


  ReactDOM.render(&lt;App /&gt;,document.getElementById(&#39;example&#39;))
&lt;/script&gt;</code></pre>
<h2 id="2-6-收集表单数据"><a href="#2-6-收集表单数据" class="headerlink" title="2.6 收集表单数据"></a>2.6 收集表单数据</h2><h3 id="2-6-1-效果"><a href="#2-6-1-效果" class="headerlink" title="2.6.1 效果"></a>2.6.1 效果</h3><pre><code>需求: 自定义包含表单的组件
  1. 输入用户名密码后, 点击登陆提示输入信息
  3. 不提交表单</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/component%E8%A1%A8%E5%8D%95.gif" alt="component表单 (2)" class="lazyload"></p>
<h3 id="2-6-2-理解"><a href="#2-6-2-理解" class="headerlink" title="2.6.2 理解"></a>2.6.2 理解</h3><p>1)     问题: 在react应用中, 如何收集表单输入数据</p>
<p>2)     包含表单的组件分类</p>
<p>a.     受控组件: 表单项输入数据能自动收集成状态</p>
<p>b.     非受控组件: 需要时才手动读取表单输入框中的数据</p>
<h3 id="2-6-3-代码"><a href="#2-6-3-代码" class="headerlink" title="2.6.3 代码"></a>2.6.3 代码</h3><pre><code class="html">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  /*
  需求: 自定义包含表单的组件
    1. 界面如下所示
    2. 输入用户名密码后, 点击登陆提示输入信息
    3. 不提交表单
  */
  class LoginForm extends React.Component{
    constructor(props){
      super(props)
      // 初始化状态
      this.state  = {
        pwd: &#39;&#39;
      }
      this.handleSubmit = this.handleSubmit.bind(this)
      this.handleChange = this.handleChange.bind(this)
    }

    handleSubmit(event){
      const name = this.nameInput.value // 非受控组件
      const {pwd} = this.state // 受控组件
      alert(`准备提交的用户名为${name}，密码为${pwd}`)
      // 阻止事件的默认行为
      event.preventDefault()
    }
    // 当事件和标签是同一个时，使用event更方便

    handleChange(event){
      // 读取输入的值
      const pwd = event.target.value
      // 更新pwd的状态
      this.setState({pwd})
    }

    render(){
      return(
        &lt;form action=&quot;/test&quot; onSubmit={this.handleSubmit}&gt;
          用户名：&lt;input type=&quot;text&quot; ref={input =&gt; this.nameInput = input}/&gt;
          密码：&lt;input type=&quot;password&quot; value={this.state.pwd} onChange={this.handleChange}/&gt;
          &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;
        &lt;/form&gt;
      )
    }
    // 原生jsonChange事件是在失去焦点时触发，react中是输入则触发
  }

  ReactDOM.render(&lt;LoginForm /&gt;, document.getElementById(&#39;example&#39;))
&lt;/script&gt;</code></pre>
<h2 id="2-7-组件生命周期"><a href="#2-7-组件生命周期" class="headerlink" title="2.7 组件生命周期"></a>2.7 组件生命周期</h2><h3 id="2-7-1-效果"><a href="#2-7-1-效果" class="headerlink" title="2.7.1 效果"></a>2.7.1 效果</h3><pre><code>需求: 自定义组件
  1. 让指定的文本做显示/隐藏的渐变动画
  2. 切换持续时间为2S
  3. 点击按钮从界面中移除组件界面</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/component%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.gif" alt="component生命周期" class="lazyload"></p>
<h3 id="2-7-2-理解"><a href="#2-7-2-理解" class="headerlink" title="2.7.2 理解"></a>2.7.2 理解</h3><p>1)     组件对象从创建到死亡它会经历特定的生命周期阶段</p>
<p>2)     React组件对象包含一系列的勾子函数(生命周期回调函数), 在生命周期特定时刻回调</p>
<p>3)     我们在定义组件时, 可以重写特定的生命周期回调函数, 做特定的工作</p>
<h3 id="2-7-3-生命周期流程图"><a href="#2-7-3-生命周期流程图" class="headerlink" title="2.7.3 生命周期流程图"></a>2.7.3 生命周期流程图</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/reactlife.png" alt="生命周期流程图" class="lazyload"></p>
<p>Mount：挂载，将虚拟标签放到容器(页面)中</p>
<p>render()渲染</p>
<p>左边初始化过程，这些方法称为声明周期回调函数，或称为生命周期的勾子，这些方法在特定的时刻调用</p>
<p>(回调函数：你定义的，你没有调用，但是最终执行了；声明式编程,流程设定好,、命令式编程jQuery,每一步自己操作)</p>
<p>will将、did完成</p>
<h3 id="2-7-4-生命周期详述"><a href="#2-7-4-生命周期详述" class="headerlink" title="2.7.4 生命周期详述"></a>2.7.4 生命周期详述</h3><p>1)     组件的三个生命周期状态:</p>
<ul>
<li><p>Mount：插入真实 DOM</p>
</li>
<li><p>Update：被重新渲染</p>
</li>
<li><p>Unmount：被移出真实 DOM</p>
</li>
</ul>
<p>2)     React 为每个状态都提供了勾子(hook)函数，可重写</p>
<ul>
<li><p><code>componentWillMount()</code></p>
</li>
<li><p><code>componentDidMount()</code></p>
</li>
<li><p><code>componentWillUpdate()</code></p>
</li>
<li><p><code>componentDidUpdate()</code></p>
</li>
<li><p><code>componentWillUnmount()</code></p>
</li>
</ul>
<p>3)    生命周期流程:</p>
<p>a.     第一次初始化渲染显示: ReactDOM.render()</p>
<ul>
<li><p>constructor(): 创建对象初始化state</p>
</li>
<li><p>componentWillMount() : 将要插入回调</p>
</li>
<li><p>render() : 用于插入虚拟DOM回调</p>
</li>
<li><p>componentDidMount() : 已经插入回调</p>
</li>
</ul>
<p>b.     每次更新state: this.setSate()</p>
<ul>
<li><p>componentWillUpdate() : 将要更新回调</p>
</li>
<li><p>render() : 更新(重新渲染)</p>
</li>
<li><p>componentDidUpdate() : 已经更新回调</p>
</li>
</ul>
<p>c.     移除组件: ReactDOM.unmountComponentAtNode(containerDom)</p>
<ul>
<li>componentWillUnmount() : 组件将要被移除回调</li>
</ul>
<p>三个阶段，可以都打印一下，看下方法执行的过程(与写的顺序无关)</p>
<h3 id="2-7-5-重要的勾子"><a href="#2-7-5-重要的勾子" class="headerlink" title="2.7.5 重要的勾子"></a>2.7.5 重要的勾子</h3><p>1)     render(): 初始化渲染或更新渲染调用</p>
<p>2)     componentDidMount(): 开启监听, 发送ajax请求</p>
<p>3)     componentWillUnmount(): 做一些收尾工作, 如: 清理定时器</p>
<p>4)     componentWillReceiveProps(): 后面需要时讲</p>
<h3 id="2-7-6-代码"><a href="#2-7-6-代码" class="headerlink" title="2.7.6 代码"></a>2.7.6 代码</h3><pre><code class="html">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  /*
  需求: 自定义组件
    1. 让指定的文本做显示/隐藏的动画
    2. 切换时间为2S
    3. 点击按钮从界面中移除组件界面
   */
  class Life extends React.Component{

    constructor(props){
      super(props)
      // 初始化状态
      this.state = {
        opacity: 1
      }

      this.distroyComponent = this.distroyComponent.bind(this)
    }

    distroyComponent(){
      ReactDOM.unmountComponentAtNode(document.getElementById(&#39;example&#39;))
    }

    // 重写方法
    componentDidMount(){
      // 启动循环定时器
      this.intervalId = setInterval(function () { // 两个函数需要同一个变量，放到上一层共同组件上
        console.log(&#39;定时器执行……&#39;)
        let {opacity} = this.state
        opacity -= 0.1
        if(opacity&lt;=0){
          opacity = 1
        }
        // 更新状态
        this.setState({opacity})
      }.bind(this), 200) // componentDidMount的this
    }
    componentWillUnmount(){
      // 清理定时器
      clearInterval(this.intervalId)
    }

    render(){ // 一旦改变，就会重新调用;永远写在其他下方，构造器在最上方
      const {opacity} = this.state
      return(
        &lt;div&gt;
          &lt;h2 style={{opacity: opacity}}&gt;{this.props.msg}&lt;/h2&gt;
          &lt;button onClick={this.distroyComponent}&gt;不活了&lt;/button&gt;
        &lt;/div&gt;
      )
    }// style中两个大括号，外面的代表写的是js代码，里面的是对象（样式名：值，也可以写ES6）
  }

  ReactDOM.render(&lt;Life msg=&quot;react太难了&quot;/&gt;, document.getElementById(&#39;example&#39;))
&lt;/script&gt;</code></pre>
<h2 id="2-8-虚拟DOM与DOM-Diff算法"><a href="#2-8-虚拟DOM与DOM-Diff算法" class="headerlink" title="2.8 虚拟DOM与DOM Diff算法"></a>2.8 虚拟DOM与DOM Diff算法</h2><p>虚拟DOM：减少操作真实DOM的次数，更新界面次数变少</p>
<p>DOM Diff算法：计算哪里需要更新，哪里不需要更新，减少更新界面的区域</p>
<p>共同提高更新界面的效率</p>
<h3 id="2-8-1-效果"><a href="#2-8-1-效果" class="headerlink" title="2.8.1 效果"></a>2.8.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/vDOM.gif" alt="component虚拟DOM" class="lazyload"></p>
<pre><code class="html">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
&lt;br&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
  /*
  验证:
  虚拟DOM+DOM Diff算法: 最小化页面重绘
  */

  class HelloWorld extends React.Component {
    constructor(props) {
      super(props)
      this.state = {
          date: new Date()
      }
    }

    componentDidMount () {
      setInterval(() =&gt; {
        this.setState({
            date: new Date()
        })
      }, 1000)
    }

    render () {
      console.log(&#39;render()&#39;)
      return (
        &lt;p&gt;
          Hello, &lt;input type=&quot;text&quot; placeholder=&quot;Your name here&quot;/&gt;!&amp;nbsp;
          &lt;span&gt;It is {this.state.date.toTimeString()}&lt;/span&gt;
        &lt;/p&gt;
      )
    }
  }

  ReactDOM.render(
    &lt;HelloWorld/&gt;,
    document.getElementById(&#39;example&#39;)
  )
&lt;/script&gt;</code></pre>
<p> 只有时间更新，其他不更新</p>
<h3 id="2-8-2-基本原理图"><a href="#2-8-2-基本原理图" class="headerlink" title="2.8.2 基本原理图"></a>2.8.2 基本原理图</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react-5.png" alt="基本原理" class="lazyload"></p>
<ul>
<li><p>初始化：虚拟DOM树(div&gt;p&gt;span……)，更新虚拟DOM界面不会变——&gt;更新真实DOM界面才会变化(更新状态)</p>
</li>
<li><p>更新(关键)：调用setState()更新状态(会进行对比)——&gt;根据差异更新真实DOM、重绘页面变化的区域</p>
</li>
</ul>
<h1 id="第3章-react应用-基于react脚手架"><a href="#第3章-react应用-基于react脚手架" class="headerlink" title="第3章 react应用(基于react脚手架)"></a>第3章 react应用(基于react脚手架)</h1><h2 id="3-1-使用create-react-app创建react应用"><a href="#3-1-使用create-react-app创建react应用" class="headerlink" title="3.1 使用create-react-app创建react应用"></a>3.1 使用create-react-app创建react应用</h2><h3 id="3-1-1-react脚手架"><a href="#3-1-1-react脚手架" class="headerlink" title="3.1.1 react脚手架"></a>3.1.1 react脚手架</h3><p>1)     xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目</p>
<ul>
<li><p>包含了所有需要的配置</p>
</li>
<li><p>指定好了所有的依赖</p>
</li>
<li><p>可以直接安装/编译/运行一个简单效果</p>
</li>
</ul>
<p>2)     react提供了一个用于创建react项目的脚手架库: create-react-app</p>
<p>3)     项目的整体技术架构为: react + webpack + es6 + eslint</p>
<p>4)     使用脚手架开发的项目的特点: 模块化、组件化、工程化</p>
<h3 id="3-1-2-创建项目并启动"><a href="#3-1-2-创建项目并启动" class="headerlink" title="3.1.2 创建项目并启动"></a>3.1.2 创建项目并启动</h3><p><code>npm install -g create-react-app</code> 全局下载</p>
<p><code>create-react-app hello-react</code></p>
<p><code>cd hello-react</code></p>
<p><code>npm start</code></p>
<p>浏览器访问<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a></p>
<p>注：</p>
<p><code>npm root -g</code> 查看全局下载目录<br>C:\Users\Shinelon\AppData\Roaming\npm\node_modules</p>
<h3 id="3-1-3-react脚手架项目结构"><a href="#3-1-3-react脚手架项目结构" class="headerlink" title="3.1.3 react脚手架项目结构"></a>3.1.3 react脚手架项目结构</h3><pre><code>ReactNews

 |--node_modules---第三方依赖模块文件夹

 |--public

   |-- index.html-----------------主页面

 |--scripts

   |-- build.js-------------------build打包引用配置

   |-- start.js-------------------start运行引用配置

 |--src------------源码文件夹

   |--components-----------------react组件

      |-- app.jsx

   |--index.css

   |--index.js-------------------应用入口js(main.js)

 |--.gitignore------git版本管制忽略的配置

 |--package.json----应用包配置文件 

 |--README.md-------应用描述说明的readme文件</code></pre><p> <code>package.json</code></p>
<ul>
<li><code>&quot;dependencies&quot;</code>：运行时依赖</li>
<li><code>&quot;devDependencies&quot;</code>：开发时依赖，编译打包时需要，开发时不需要，编译打包时工具包</li>
</ul>
<p><code>public/index.html</code>主界面</p>
<ul>
<li>只有一个<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>，依靠组件</li>
</ul>
<p><code>src/index.js</code>应用入口</p>
<ul>
<li>引入包(<code>import * from &quot;*&quot;</code>)、CSS(<code>import &quot;*.css&quot;</code>)</li>
<li>渲染组件</li>
</ul>
<p><code>README.md</code>对项目的说明文件</p>
<p>SPA(Single Page Application)：单应用</p>
<ul>
<li>index.html</li>
</ul>
<pre><code class="html">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></pre>
<ul>
<li><code>src/components/app.jsx</code></li>
</ul>
<pre><code class="jsx">import React, {Component} from &#39;react&#39;
import logo from &#39;../logo.svg&#39;

export default class App extends Component {
  render() {
    return(
      &lt;div&gt;
        &lt;img className=&#39;logo&#39; src={logo} alt=&quot;logo&quot;/&gt;
        &lt;p className=&quot;title&quot;&gt;react组件&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<ul>
<li><code>src/index.js</code></li>
</ul>
<pre><code class="javascript">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import App from &#39;./components/app&#39;

import &#39;./index.css&#39;

ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))</code></pre>
<ul>
<li><code>src/index.css</code></li>
</ul>
<pre><code class="css">.logo{
  width: 200px;
  height: 200px;
}
.title{
  color: red;
  font-size: 25px;
}</code></pre>
<p><code>cd react_app</code><br><code>npm start</code>或<code>npm run start</code></p>
<h2 id="3-2-demo-评论管理"><a href="#3-2-demo-评论管理" class="headerlink" title="3.2 demo: 评论管理"></a>3.2 demo: 评论管理</h2><h3 id="3-2-1-效果"><a href="#3-2-1-效果" class="headerlink" title="3.2.1 效果"></a>3.2.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/demo_comment.gif" alt="demo_comment" class="lazyload"></p>
<h3 id="3-2-2-拆分组件"><a href="#3-2-2-拆分组件" class="headerlink" title="3.2.2 拆分组件"></a>3.2.2 拆分组件</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200708170522553.png" alt="image-20200708170522553" class="lazyload"></p>
<p>应用组件: App</p>
<ul>
<li>state: comments/array</li>
</ul>
<p>添加评论组件: CommentAdd</p>
<ul>
<li><p>state: username/string, content/string</p>
</li>
<li><p>props: add/func</p>
</li>
</ul>
<p>评论列表组件: CommentList</p>
<ul>
<li>props: comment/object, delete/func, index/number</li>
</ul>
<p>评论项组件: CommentItem</p>
<ul>
<li>props: comments/array, delete/func</li>
</ul>
<h3 id="3-2-3-实现静态组件"><a href="#3-2-3-实现静态组件" class="headerlink" title="3.2.3 实现静态组件"></a>3.2.3 实现静态组件</h3><p>render(){return}中的内容</p>
<ul>
<li><code>src/index.js</code></li>
</ul>
<pre><code class="javascript">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import App from &#39;./components/app/app&#39;

ReactDOM.render(&lt;App/&gt;, document.getElementById(&#39;root&#39;))</code></pre>
<ul>
<li><code>src/components/app/app.jsx</code></li>
</ul>
<pre><code class="jsx">import React from &#39;react&#39;
import CommentAdd from &#39;../comment-add/comment-add&#39;
import CommentList from &#39;../comment-list/comment-list&#39;

export default class App extends React.Component {

  constructor (props) {
    super(props)

    this.state = {
      comments: []
    }

    this.delete = this.delete.bind(this)
  }

  componentDidMount () {
    //模拟异步获取数据
    setTimeout(() =&gt; {
      const comments = [
        {
          username: &quot;Tom&quot;,
          content: &quot;ReactJS好难啊!&quot;,
          id: Date.now()
        },
        {
          username: &quot;JACK&quot;,
          content: &quot;ReactJS还不错!&quot;,
          id: Date.now() + 1
        }
      ]
      this.setState({
        comments
      })
    }, 1000)
  }

  add = (comment) =&gt; {
    let comments = this.state.comments
    comments.unshift(comment)
    this.setState({ comments })
  }

  delete (index) {
    let comments = this.state.comments
    comments.splice(index, 1)
    this.setState({ comments })
  }

  render () {
    return (
      &lt;div&gt;
        &lt;header className=&quot;site-header jumbotron&quot;&gt;
          &lt;div className=&quot;container&quot;&gt;
            &lt;div className=&quot;row&quot;&gt;
              &lt;div className=&quot;col-xs-12&quot;&gt;
                &lt;h1&gt;请发表对React的评论&lt;/h1&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/header&gt;
        &lt;div className=&quot;container&quot;&gt;
          &lt;CommentAdd add={this.add}/&gt;
          &lt;CommentList comments={this.state.comments} delete={this.delete}/&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

// export default App 可以写到上面</code></pre>
<ul>
<li><code>src/components/comment-add/comment-add.jsx</code></li>
</ul>
<pre><code class="jsx">import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;

class CommentAdd extends React.Component {
  constructor (props) {
    super(props)
    this.state = {
      username: &#39;&#39;,
      content: &#39;&#39;
    }
    this.addComment = this.addComment.bind(this)
    this.changeUsername = this.changeUsername.bind(this)
    this.changeContent = this.changeContent.bind(this)
  }

  addComment () {
    // 根据输入的数据创建评论对象
    let { username, content } = this.state
    let comment = { username, content }
    // 添加到comments中, 更新state
    this.props.add(comment)
    // 清除输入的数据
    this.setState({
      username: &#39;&#39;,
      content: &#39;&#39;
    })
  }

  changeUsername (event) {
    this.setState({
      username: event.target.value
    })
  }

  changeContent (event) {
    this.setState({
      content: event.target.value
    })
  }

  render () {
    return (
      &lt;div className=&quot;col-md-4&quot;&gt;
        &lt;form className=&quot;form-horizontal&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label&gt;用户名&lt;/label&gt;
            &lt;input type=&quot;text&quot; className=&quot;form-control&quot; placeholder=&quot;用户名&quot;
                   value={this.state.username} onChange={this.changeUsername}/&gt;
          &lt;/div&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label&gt;评论内容&lt;/label&gt;
            &lt;textarea className=&quot;form-control&quot; rows=&quot;6&quot; placeholder=&quot;评论内容&quot;
                      value={this.state.content} onChange={this.changeContent}&gt;&lt;/textarea&gt;
          &lt;/div&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;div className=&quot;col-sm-offset-2 col-sm-10&quot;&gt;
              &lt;button type=&quot;button&quot; className=&quot;btn btn-default pull-right&quot; onClick={this.addComment}&gt;提交&lt;/button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    )
  }
}
CommentAdd.propTypes = {
  add: PropTypes.func.isRequired
}

export default CommentAdd</code></pre>
<ul>
<li><code>src/components/comment-list/comment-list.css</code></li>
</ul>
<pre><code class="css">.reply {
  margin-top: 0px;
}</code></pre>
<ul>
<li><code>src/components/comment-list/comment-list.jsx</code></li>
</ul>
<pre><code class="jsx">import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import CommentItem from &#39;../comment-item/comment-item&#39;
import &#39;./commentList.css&#39;
class CommentList extends React.Component {
  constructor (props) {
    super(props)
  }
  render () {
    let comments = this.props.comments
    let display = comments.length &gt; 0 ? &#39;none&#39; : &#39;block&#39;</code></pre>
<p>下面h2中由于用了双大括号，一直报错，因此请直接到github看源码</p>
<pre><code class="jsx">    return (
      &lt;div className=&quot;col-md-8&quot;&gt;
        &lt;h3 className=&quot;reply&quot;&gt;评论回复：&lt;/h3&gt;
        &lt;h2 style=双大括号 display: display 双大括号&gt;暂无评论，点击左侧添加评论&lt;/h2&gt;
        &lt;ul className=&quot;list-group&quot;&gt;
          {
            comments.map((comment, index) =&gt; {
              console.log(comment)
              return &lt;CommentItem comment={comment} key={index} index={index} delete={this.props.delete}/&gt;
            })
          }
        &lt;/ul&gt;
      &lt;/div&gt;
    )
    }
}
CommentList.propTypes = {
  comments: PropTypes.array.isRequired,
  delete: PropTypes.func.isRequired
}
export default CommentList</code></pre>
<ul>
<li><code>src/components/comment-item/comment-item.css</code></li>
</ul>
<pre><code class="css">li {
  transition: .5s;
  overflow: hidden;
}

.handle {
  width: 40px;
  border: 1px solid #ccc;
  background: #fff;
  position: absolute;
  right: 10px;
  top: 1px;
  text-align: center;
}

.handle a {
  display: block;
  text-decoration: none;
}

.list-group-item .centence {
  padding: 0px 50px;
}

.user {
  font-size: 22px;
}</code></pre>
<ul>
<li><code>src/components/comment-item/comment-item.jsx</code></li>
</ul>
<pre><code class="jsx">import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import &#39;./commentItem.css&#39;

class CommentItem extends React.Component {
  constructor (props) {
    super(props)
    this.deleteComment = this.deleteComment.bind(this)
  }

  deleteComment () {
    let username = this.props.comment.username
    if (window.confirm(`确定删除${username}的评论吗?`)) {
      this.props.delete(this.props.index)
    }
  }

  render () {
    let comment = this.props.comment
    return (
      &lt;li className=&quot;list-group-item&quot;&gt;
        &lt;div className=&quot;handle&quot;&gt;
          &lt;a href=&quot;javascript:&quot; onClick={this.deleteComment}&gt;删除&lt;/a&gt;
        &lt;/div&gt;
        &lt;p className=&quot;user&quot;&gt;&lt;span &gt;{comment.username}&lt;/span&gt;&lt;span&gt;说:&lt;/span&gt;&lt;/p&gt;
        &lt;p className=&quot;centence&quot;&gt;{comment.content}&lt;/p&gt;
      &lt;/li&gt;
    )
  }
}
CommentItem.propTypes = {
  comment: PropTypes.object.isRequired,
  index: PropTypes.number.isRequired,
  delete: PropTypes.func.isRequired
}

export default CommentItem</code></pre>
<h3 id="3-2-4-实现动态组件"><a href="#3-2-4-实现动态组件" class="headerlink" title="3.2.4 实现动态组件"></a>3.2.4 实现动态组件</h3><p>动态展示初始化数据</p>
<ul>
<li><p>初始化状态数据</p>
</li>
<li><p>传递属性数据</p>
</li>
</ul>
<p>响应用户操作, 更新组件界面</p>
<ul>
<li><p>绑定事件监听, 并处理</p>
</li>
<li><p>更新state</p>
</li>
</ul>
<h1 id="第4章-react-ajax"><a href="#第4章-react-ajax" class="headerlink" title="第4章 react ajax"></a>第4章 react ajax</h1><h2 id="4-1-理解"><a href="#4-1-理解" class="headerlink" title="4.1 理解"></a>4.1 理解</h2><h3 id="4-1-1-前置说明"><a href="#4-1-1-前置说明" class="headerlink" title="4.1.1 前置说明"></a>4.1.1 前置说明</h3><p>1)     React本身只关注于界面, 并不包含发送ajax请求的代码</p>
<p>2)     前端应用需要通过ajax请求与后台进行交互(json数据)</p>
<p>3)     react应用中需要集成第三方ajax库(或自己封装)</p>
<h3 id="4-1-2-常用的ajax请求库"><a href="#4-1-2-常用的ajax请求库" class="headerlink" title="4.1.2 常用的ajax请求库"></a>4.1.2 常用的ajax请求库</h3><p>1)     jQuery: 比较重, 如果需要另外引入不建议使用</p>
<p>2)     <strong>axios</strong>: 轻量级, 建议使用</p>
<p>​    a.     封装XmlHttpRequest对象的ajax</p>
<p>​    b.     promise风格</p>
<p>​    c.     可以用在浏览器端和node服务器端</p>
<p>3)     fetch: 原生函数, 但老版本浏览器不支持</p>
<p>​    a.     不再使用XmlHttpRequest对象提交ajax请求</p>
<p>​    b.     为了兼容低版本的浏览器, 可以引入兼容库fetch.js</p>
<h3 id="4-1-3-效果"><a href="#4-1-3-效果" class="headerlink" title="4.1.3 效果"></a>4.1.3 效果</h3><pre><code>需求:
  1. 界面效果如下
  2. 根据指定的关键字在github上搜索匹配的最受关注的库
  3. 显示库名, 点击链接查看库
4. 测试接口: https://api.github.com/search/repositories?q=r&amp;sort=stars
</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/ajax.gif" alt="ajax" class="lazyload"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;11_ajax&lt;/title&gt;
  &lt;style&gt;
    h2{
      text-align: center;
      margin-top: 200px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
  /*
  需求:
    1. 界面效果如下
    2. 根据指定的关键字在github上搜索匹配的最受关注的库
    3. 显示库名, 点击链接查看库
    4. 测试接口: https://api.github.com/search/repositories?q=r&amp;sort=stars
  */
  class MostStarRepo extends React.Component{
    state = {
      repoName: &#39;&#39;,
      repoUrl: &#39;&#39;
    }

    componentDidMount(){
      // 使用axios发送异步的ajax请求
      const url = `https://api.github.com/search/repositories?q=re&amp;sort=stars`
      axios.get(url)
          .then(response =&gt; {
            const result = response.data
            // console.log(response)
            // 得到数据
            const {name, html_url} = result.items[0]
            // 更新状态
            this.setState({repoName:name, repoUrl: html_url})
          })
          .catch((error) =&gt; {
            alert(error.message)
          })
      // 使用fetch发送异步的ajax请求
      /*fetch(url)
          .then(response =&gt; {
            return response.json()
          })
          .then(data =&gt; {
            // 得到数据
            const {name, html_url} = data.items[0]
            // 更新状态
            this.setState({repoName:name, repoUrl: html_url})
          })
      */
    }

    render(){
      const {repoName, repoUrl} = this.state
      if(!repoName){
        return(
          &lt;h2&gt;LOADING...&lt;/h2&gt;
        )
      }else{
        return(
          &lt;h2&gt;Most star repo is &lt;a href={repoUrl}&gt;{repoName}&lt;/a&gt;&lt;/h2&gt;
        )
      }

    }
  }
  ReactDOM.render(&lt;MostStarRepo /&gt;, document.getElementById(&#39;example&#39;))
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="4-2-axios"><a href="#4-2-axios" class="headerlink" title="4.2 axios"></a>4.2 axios</h2><h3 id="4-2-1-文档"><a href="#4-2-1-文档" class="headerlink" title="4.2.1 文档"></a>4.2.1 文档</h3><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p>
<h3 id="4-2-2-相关API"><a href="#4-2-2-相关API" class="headerlink" title="4.2.2 相关API"></a>4.2.2 相关API</h3><p>1)     GET请求</p>
<pre><code class="javascript">axios.get(&#39;/user?ID=12345&#39;)
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });

axios.get(&#39;/user&#39;, {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
</code></pre>
<p>2)     POST请求</p>
<pre><code class="javascript">axios.post(&#39;/user&#39;, {
    firstName: &#39;Fred&#39;,
axios.post(&#39;/user&#39;, {
    firstName: &#39;Fred&#39;,
    lastName: &#39;Flintstone&#39;
})
.then(function (response) {
  console.log(response);
})
.catch(function (error) {
  console.log(error);
});
</code></pre>
<h2 id="4-3-Fetch"><a href="#4-3-Fetch" class="headerlink" title="4.3 Fetch"></a>4.3 Fetch</h2><h3 id="4-3-1-文档"><a href="#4-3-1-文档" class="headerlink" title="4.3.1 文档"></a>4.3.1 文档</h3><p>1)     <a href="https://github.github.io/fetch/" target="_blank" rel="noopener">https://github.github.io/fetch/</a></p>
<p>2)     <a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003810652</a></p>
<h3 id="4-3-2-相关API"><a href="#4-3-2-相关API" class="headerlink" title="4.3.2 相关API"></a>4.3.2 相关API</h3><p>1)     GET请求</p>
<pre><code class="javascript">fetch(url).then(function(response) {
  return response.json()
}).then(function(data) {
  console.log(data)
}).catch(function(e) {
  console.log(e)
});
</code></pre>
<p>2)     POST请求</p>
<pre><code class="javascript">fetch(url, {
  method: &quot;POST&quot;,
  body: JSON.stringify(data),
}).then(function(data) {
  console.log(data)
}).catch(function(e) {
  console.log(e)
})</code></pre>
<h2 id="4-4-demo-github-users"><a href="#4-4-demo-github-users" class="headerlink" title="4.4 demo: github users"></a>4.4 demo: github users</h2><h3 id="4-4-1-效果"><a href="#4-4-1-效果" class="headerlink" title="4.4.1 效果"></a>4.4.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/demo_users.gif" alt="demo_users" class="lazyload"></p>
<h3 id="4-4-2-拆分组件"><a href="#4-4-2-拆分组件" class="headerlink" title="4.4.2 拆分组件"></a>4.4.2 拆分组件</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200711091558440.png" alt="image-20200711091558440" class="lazyload"></p>
<p>App</p>
<p>​       * state: searchName/string</p>
<p>  Search</p>
<p>​      * props: setSearchName/func</p>
<p>  List</p>
<p>​      * props: searchName/string</p>
<p>​      * state: firstView/bool, loading/bool, users/array, errMsg/string</p>
<h3 id="4-4-3-编写静态组件"><a href="#4-4-3-编写静态组件" class="headerlink" title="4.4.3 编写静态组件"></a>4.4.3 编写静态组件</h3><h3 id="4-4-4-编写动态组件"><a href="#4-4-4-编写动态组件" class="headerlink" title="4.4.4 编写动态组件"></a>4.4.4 编写动态组件</h3><p>componentWillReceiveProps(nextProps): 监视接收到新的props, 发送ajax</p>
<p>​     使用axios库发送ajax请求</p>
<ul>
<li><code>public/index.html</code></li>
</ul>
<pre><code class="html">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></pre>
<ul>
<li><code>src/index.js</code></li>
</ul>
<pre><code class="javascript">import React from &#39;react&#39;
import { render } from &#39;react-dom&#39;

import App from &#39;./components/app&#39;
import &#39;./index.css&#39;

render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))</code></pre>
<ul>
<li><code>src/index.css</code></li>
</ul>
<pre><code class="css">.album {
  min-height: 50rem; /* Can be removed; just added for demo purposes */
  padding-top: 3rem;
  padding-bottom: 3rem;
  background-color: #f7f7f7;
}

.card {
  float: left;
  width: 33.333%;
  padding: .75rem;
  margin-bottom: 2rem;
  border: 1px solid #efefef;
  text-align: center;
}

.card &gt; img {
  margin-bottom: .75rem;
  border-radius: 100px;
}

.card-text {
  font-size: 85%;
}
</code></pre>
<ul>
<li><code>src/componets/app.jsx</code></li>
</ul>
<pre><code class="jsx">import React from &#39;react&#39;
import Search from &#39;./search&#39;
import UserList from &#39;./user-list&#39;

export default class App extends React.Component {

  state = {
    searchName: &#39;&#39;
  }

  refreshName = (searchName) =&gt; this.setState({searchName})

  render() {
    return (
      &lt;div className=&quot;container&quot;&gt;
        &lt;section className=&quot;jumbotron&quot;&gt;
          &lt;h3 className=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;
          &lt;Search refreshName={this.refreshName}/&gt;
        &lt;/section&gt;
        &lt;UserList searchName={this.state.searchName}/&gt;
      &lt;/div&gt;
    )
  }

}
</code></pre>
<ul>
<li><code>src/componets/search.jsx</code></li>
</ul>
<pre><code class="jsx">/**
 * 上部的搜索模块
 */
import React, {Component} from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;

class Search extends Component {

  static propTypes = {
    refreshName: PropTypes.func.isRequired
  }

  search = () =&gt; {
    var name = this.nameInput.value
    this.props.refreshName(name)
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot;
               ref={(input =&gt; this.nameInput = input)}/&gt;
        &lt;button onClick={this.search}&gt;Search&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

export default Search</code></pre>
<ul>
<li><code>src/componets/user-list.jsx</code></li>
</ul>
<pre><code class="jsx">/**
 * 下部的用户列表模块
 */
import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import axios from &#39;axios&#39;
// npm install axios --save 

class UserList extends React.Component {

  static propTypes = {
    searchName: PropTypes.string.isRequired
  }

  state = {
    firstView: true,
    loading: false,
    users: null,
    error: null
  }

  async componentWillReceiveProps(nextProps)  {
    let searchName = nextProps.searchName
    console.log(&#39;发送ajax请求&#39;, searchName)
    const url = `https://api.github.com/search/users?q=${searchName}`
    this.setState({ firstView: false, loading: true })

    // 使用axios库
    axios.get(url)
      .then((response) =&gt; {
        console.log(response)
        this.setState({ loading: false, users: response.data.items })
      })
      .catch((error)=&gt;{
        // debugger
        console.log(&#39;error&#39;, error.response.data.message, error.message)
        this.setState({ loading: false, error: error.message })
      })

    try {
      const result = await axios.get(url)
      this.setState({ loading: false, users: result.data.items })
    } catch(err) {
      // debugger
      console.log(&#39;----&#39;, err.message)
    }
  }

  render () {

    if (this.state.firstView) {
      return &lt;h2&gt;Enter name to search&lt;/h2&gt;
    } else if (this.state.loading) {
      return &lt;h2&gt;Loading result...&lt;/h2&gt;
    } else if (this.state.error) {
      return &lt;h2&gt;{this.state.error}&lt;/h2&gt;
    } else {
      return (
        &lt;div className=&quot;row&quot;&gt;
          {
            this.state.users.map((user) =&gt; (
              &lt;div className=&quot;card&quot; key={user.html_url}&gt;
                &lt;a href={user.html_url} target=&quot;_blank&quot;&gt;
                  &lt;img src={user.avatar_url} style={{width: '100px'}} alt=&#39;user&#39;/&gt;
                &lt;/a&gt;
                &lt;p className=&quot;card-text&quot;&gt;{user.login}&lt;/p&gt;
              &lt;/div&gt;
            ))
          }
        &lt;/div&gt;
      )
    }
  }
}

export default UserList</code></pre>
<h1 id="第5章-几个重要技术总结"><a href="#第5章-几个重要技术总结" class="headerlink" title="第5章 几个重要技术总结"></a>第5章 几个重要技术总结</h1><h2 id="5-1-组件间通信"><a href="#5-1-组件间通信" class="headerlink" title="5.1 组件间通信"></a>5.1 组件间通信</h2><h3 id="5-1-1-方式一-通过props传递"><a href="#5-1-1-方式一-通过props传递" class="headerlink" title="5.1.1 方式一: 通过props传递"></a>5.1.1 方式一: 通过props传递</h3><p>1)     共同的数据放在父组件上, 特有的数据放在自己组件内部(state)</p>
<p>2)     通过props可以传递一般数据和函数数据, 只能一层一层传递</p>
<p>3)     一般数据–&gt;父组件传递数据给子组件–&gt;子组件读取数据</p>
<p>4)     函数数据–&gt;子组件传递数据给父组件–&gt;子组件调用函数</p>
<p>父组件传到孙组件、兄弟组件之间不能直接通信，经过子组件、服务器传递</p>
<h3 id="5-1-2-方式二-使用消息订阅-subscribe-发布-publish-机制"><a href="#5-1-2-方式二-使用消息订阅-subscribe-发布-publish-机制" class="headerlink" title="5.1.2 方式二: 使用消息订阅(subscribe)-发布(publish)机制"></a>5.1.2 方式二: 使用消息订阅(subscribe)-发布(publish)机制</h3><p>1)     工具库: PubSubJS</p>
<p>2)     下载: <code>npm install pubsub-js --save</code></p>
<p>3)     使用: </p>
<pre><code class="javascript">import PubSub from &#39;pubsub-js&#39; //引入
PubSub.publish(&#39;delete&#39;, data) //发布消息
// 消息名，消息
PubSub.subscribe(&#39;delete&#39;, function(msg, data){ }); //订阅
// 消息名，回调函数</code></pre>
<p>以上一个demo为例(用户搜索的)，search和userlist(main)之间需要通信，它们是兄弟组件</p>
<p>在这里是通过父组件，利用props进行通信</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200714161016458.png" alt="props-search" class="lazyload"></p>
<p>这是以前的app.ejs</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200714161302225.png" alt="app.ejs" class="lazyload"></p>
<p>现在不通过父组件来通信</p>
<p><code>src/components/app.ejs</code></p>
<pre><code class="ejs">import React from &#39;react&#39;
import Search from &#39;./search&#39;
import UserList from &#39;./user-list&#39;

export default class App extends React.Component {

  render() {
    return (
      &lt;div className=&quot;container&quot;&gt;
        &lt;section className=&quot;jumbotron&quot;&gt;
          &lt;h3 className=&quot;jumbotron-heading&quot;&gt;Search Github Users&lt;/h3&gt;
          &lt;Search/&gt;
        &lt;/section&gt;
        &lt;UserList/&gt;
      &lt;/div&gt;
    )
  }

}</code></pre>
<p><code>src/components/search.ejs</code></p>
<pre><code class="ejs">/**
 * 上部的搜索模块
 */
import React, {Component} from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import PubSub from &#39;pubsub-js&#39; //引入
class Search extends Component {
  search = () =&gt; {
    var searchName = this.nameInput.value
    if(searchName){
      // 搜索
      // 发布消息 search
PubSub.publish(&#39;search&#39;, searchName)
    }
  }
  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot;
               ref={(input =&gt; this.nameInput = input)}/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Search&quot; onClick={this.search} /&gt;
      &lt;/div&gt;
    )
  }
}
export default Search</code></pre>
<p><code>src/components/user-list.ejs</code></p>
<pre><code class="ejs">/**
 * 下部的用户列表模块
 */
import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import axios from &#39;axios&#39;
import PubSub from &#39;pubsub-js&#39; //引入
class UserList extends React.Component {
  static propTypes = {
    searchName: PropTypes.string.isRequired
  }
  state = {
    firstView: true,
    loading: false,
    users: null,
    error: null
  }
  componentDidMount(){
    // 订阅消息 search
   PubSub.subscribe(&#39;search&#39;, (msg, searchName) =&gt; { // 指定了新的name，需要请求    
      this.setState({ firstView: false, loading: true })
      // 使用axios库
      const url = `https://api.github.com/search/users?q=${searchName}`
      axios.get(url)
        .then((response) =&gt; {
    console.log(response)
          this.setState({ loading: false, users: response.data.items })
        })
        .catch((error)=&gt;{
          // debugger       console.log(&#39;error&#39;, error.response.data.message, error.message)
          this.setState({ loading: false, error: error.message })
        })
      try {
        const result = axios.get(url)
        this.setState({ loading: false, users: result.data.items })
      } catch(err) {
        // debugger
        console.log(&#39;----&#39;, err.message)
      }
    })
  }
  render () {
    if (this.state.firstView) {
      return &lt;h2&gt;Enter name to search&lt;/h2&gt;
    } else if (this.state.loading) {
      return &lt;h2&gt;Loading result...&lt;/h2&gt;
    } else if (this.state.error) {
      return &lt;h2&gt;{this.state.error}&lt;/h2&gt;
    } else {
      return (
        &lt;div className=&quot;row&quot;&gt;
          {         this.state.users.map((user) =&gt; (
              &lt;div className=&quot;card&quot; key={user.html_url}&gt;
                &lt;a href={user.html_url} target=&quot;_blank&quot;&gt;
                  &lt;img src={user.avatar_url} style={{width: '100px'}} alt=&#39;user&#39;/&gt;
                &lt;/a&gt;
                &lt;p className=&quot;card-text&quot;&gt;{user.login}&lt;/p&gt;
              &lt;/div&gt;
            ))
          }
        &lt;/div&gt;
      )
    }
  }
}
export default UserList</code></pre>
<p>再以之前的评论的为例</p>
<p>App.ejs中有个删除评论的函数，传给了List组件(并没有用到)，接着传给Item</p>
<pre><code class="jsx">delete={this.delete}</code></pre>
<h3 id="5-1-3-方式三-redux"><a href="#5-1-3-方式三-redux" class="headerlink" title="5.1.3 方式三: redux"></a>5.1.3 方式三: redux</h3><p>后面专门讲解</p>
<h2 id="5-2-事件监听理解"><a href="#5-2-事件监听理解" class="headerlink" title="5.2 事件监听理解"></a>5.2 事件监听理解</h2><h3 id="5-2-1-原生DOM事件"><a href="#5-2-1-原生DOM事件" class="headerlink" title="5.2.1 原生DOM事件"></a>5.2.1 原生DOM事件</h3><p>1)     绑定事件监听</p>
<p>a.     事件名(类型): 只有有限的几个, 不能随便写</p>
<p>b.     回调函数</p>
<p>2)         触发事件</p>
<p>a.     用户操作界面</p>
<p>b.     事件名(类型)</p>
<p>c.     数据</p>
<h3 id="5-2-2-自定义事件-消息机制"><a href="#5-2-2-自定义事件-消息机制" class="headerlink" title="5.2.2 自定义事件(消息机制)"></a>5.2.2 自定义事件(消息机制)</h3><p>1)     绑定事件监听</p>
<p>a.     事件名(类型): 任意</p>
<p>b.     回调函数: 通过形参接收数据, 在函数体处理事件</p>
<p>2)     触发事件(编码)</p>
<p>a.     事件名(类型): 与绑定的事件监听的事件名一致</p>
<p>b.     数据: 会自动传递给回调函数</p>
<h2 id="5-3-ES6常用新语法"><a href="#5-3-ES6常用新语法" class="headerlink" title="5.3 ES6常用新语法"></a>5.3 ES6常用新语法</h2><p>1)     定义常量/变量: <code>const/let</code></p>
<p>2)     解构赋值:<code>let {a, b} = this.props</code>  <code>import {aa} from &#39;xxx&#39;</code></p>
<p>3)     对象的简洁表达: <code>{a, b}</code></p>
<p>4)     箭头函数: </p>
<p>a.     常用场景</p>
<ul>
<li><p>组件的自定义方法: <code>xxx = () =&gt; {}</code></p>
</li>
<li><p>参数匿名函数</p>
</li>
</ul>
<p>b.     优点:</p>
<p>​          * 简洁</p>
<p>​          * 没有自己的this,使用引用this查找的是外部this</p>
<p>5)     扩展(三点)运算符: 拆解对象<code>(const MyProps = {}, &lt;Xxx {...MyProps}&gt;)</code></p>
<p>6)     类: <code>class/extends/constructor/super</code></p>
<p>7)     ES6模块化: <code>export default | import</code></p>
<h1 id="第6章-react-router4"><a href="#第6章-react-router4" class="headerlink" title="第6章 react-router4"></a>第6章 react-router4</h1><h2 id="6-1-相关理解"><a href="#6-1-相关理解" class="headerlink" title="6.1 相关理解"></a>6.1 相关理解</h2><h3 id="6-1-1-react-router的理解"><a href="#6-1-1-react-router的理解" class="headerlink" title="6.1.1 react-router的理解"></a>6.1.1 react-router的理解</h3><p>1)     react的一个插件库(依赖/基于React)</p>
<p>2)     专门用来实现一个SPA应用</p>
<p>3)     基于react的项目基本都会用到此库</p>
<h3 id="6-1-2-SPA的理解"><a href="#6-1-2-SPA的理解" class="headerlink" title="6.1.2 SPA的理解"></a>6.1.2 SPA的理解</h3><p>1)     单页Web应用（single page web application，SPA）</p>
<p>2)     整个应用只有一个完整的页面</p>
<p>3)     点击页面中的链接不会刷新页面, 本身也不会向服务器发请求</p>
<p>4)     当点击路由链接时, 只会做页面的<strong>局部更新</strong></p>
<p>5)     数据都需要通过<strong>ajax请求</strong>获取, 并在前端<strong>异步展现</strong></p>
<h3 id="6-1-3-路由的理解"><a href="#6-1-3-路由的理解" class="headerlink" title="6.1.3 路由的理解"></a>6.1.3 路由的理解</h3><p>1)     什么是路由?</p>
<p>a.     一个路由就是一个<strong>映射关系(key:value)</strong></p>
<p>b.     key为<strong>路由路径(path)</strong>, value可能是function(后台路由)/<strong>component(前台路由)</strong></p>
<p>2)     路由分类</p>
<p>a.     后台路由: node服务器端路由, value是function, 用来处理客户端提交的请求并返回一个响应数据</p>
<p>b.     前台路由: 浏览器端路由, value是component, 当请求的是路由path时, 浏览器端前没有发送http请求, 但界面会更新显示对应的组件 </p>
<p>3)     后台路由</p>
<p>a.     注册路由: <code>router.get(path, function(req, res))</code></p>
<p>b.     当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p>
<p>4)         前端路由</p>
<p>a.     注册路由: <code>&lt;Route path=&quot;/about&quot; component={About}&gt;</code></p>
<p>b.     当浏览器的<strong>hash</strong>变为<code>#about</code>时, 当前路由组件就会变为About组件</p>
<h3 id="6-1-4-前端路由的实现"><a href="#6-1-4-前端路由的实现" class="headerlink" title="6.1.4 前端路由的实现"></a>6.1.4 前端路由的实现</h3><p>(底层实现)</p>
<p>1)     history库</p>
<p>a.     网址: <a href="https://github.com/ReactTraining/history" target="_blank" rel="noopener">https://github.com/ReactTraining/history</a></p>
<p>b.     管理浏览器会话历史(history)的工具库</p>
<p>c.     包装的是原生BOM中<code>window.history</code>和<code>window.location.hash</code></p>
<p>2)     history API</p>
<p>a.     <code>History.createBrowserHistory()</code>: 得到封装window.history的管理对象</p>
<p>b.     <code>History.createHashHistory()</code>: 得到封装window.location.hash的管理对象</p>
<p>c.     <code>history.push()</code>: 添加一个新的历史记录</p>
<p>d.     <code>history.replace()</code>: 用一个新的历史记录替换当前的记录</p>
<p>e.     <code>history.goBack()</code>: 回退到上一个历史记录</p>
<p>f.     <code>history.goForword()</code>: 前进到下一个历史记录</p>
<p>g.     <code>history.listen(function(location){})</code>: 监视历史记录的变化</p>
<p>3)     测试</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/history-%E6%96%B9%E5%BC%8F1.gif" alt="history-方式1" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/history-%E6%96%B9%E5%BC%8F2.gif" alt="history-方式2" class="lazyload"></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;history test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

  &lt;p&gt;&lt;input type=&quot;text&quot;&gt;&lt;/p&gt;
  &lt;a href=&quot;/test1&quot; onclick=&quot;return push(&#39;/test1&#39;)&quot;&gt;test1&lt;/a&gt;&lt;br&gt;&lt;br&gt;
  &lt;button onClick=&quot;push(&#39;/test2&#39;)&quot;&gt;push test2&lt;/button&gt;&lt;br&gt;&lt;br&gt;
  &lt;button onClick=&quot;back()&quot;&gt;回退&lt;/button&gt;&lt;br&gt;&lt;br&gt;
  &lt;button onClick=&quot;forword()&quot;&gt;前进&lt;/button&gt;&lt;br&gt;&lt;br&gt;
  &lt;button onClick=&quot;replace(&#39;/test3&#39;)&quot;&gt;replace test3&lt;/button&gt;&lt;br&gt;&lt;br&gt;

  &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/history/4.7.2/history.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    let history = History.createBrowserHistory() // 方式一
    history = History.createHashHistory() // 方式二
    // console.log(history)

    function push (to) {
      history.push(to)
      return false
    } // 可以返回

    function back() {
      history.goBack()
    }

    function forword() {
      history.goForward()
    }

    function replace (to) {
      history.replace(to)
    } // 不能返回

    history.listen((location) =&gt; {
      console.log(&#39;请求路由路径变化了&#39;, location)
    })
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="6-2-react-router相关API"><a href="#6-2-react-router相关API" class="headerlink" title="6.2 react-router相关API"></a>6.2 react-router相关API</h2><p><a href="https://reactrouter.com/" target="_blank" rel="noopener">react_router</a></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200714181151269.png" alt="react-router" class="lazyload"></p>
<p><a href="https://reactrouter.com/web/guides/quick-start" target="_blank" rel="noopener">web</a></p>
<h3 id="6-2-1-组件"><a href="#6-2-1-组件" class="headerlink" title="6.2.1 组件"></a>6.2.1 组件</h3><p>1)     <code>&lt;BrowserRouter&gt;</code>：BrowserRouter是react路由的容器</p>
<p>2)     <code>&lt;HashRouter&gt;</code>：这个是用来兼容老浏览器的</p>
<p>3)     <code>&lt;Route&gt;</code>：Route的作用就是用来渲染路由匹配的组件。路由渲染有三种方式，每一种方式都可以传递match,location,history对象</p>
<p>4)     <code>&lt;Redirect&gt;</code>：路由重定向</p>
<p>5)     <code>&lt;Link&gt;</code>：Link的作用和a标签类似</p>
<p>6)     <code>&lt;NavLink&gt;</code>：NavLink和Link一样最终都是渲染成a标签，NavLink可以给这个a标签添加额外的属性</p>
<p>7)     <code>&lt;Switch&gt;</code>：Switch组件内部可以是Route或者Redirect，只会渲染第一个匹配的元素</p>
<h3 id="6-2-2-其它"><a href="#6-2-2-其它" class="headerlink" title="6.2.2 其它"></a>6.2.2 其它</h3><p>1)     <strong><code>history</code>对象</strong>：这里的history对象是使用history插件生成的，<a href="http://www.cnblogs.com/ye-hcj/p/7741742.html已经详细讲过了" target="_blank" rel="noopener">http://www.cnblogs.com/ye-hcj/p/7741742.html已经详细讲过了</a><br>记住一点，再使用location做对比的使用，通过history访问的location是动态变化的，最好通过Route访问location</p>
<p>2)     <code>match</code>对象：match对象表示当前的路由地址是怎么跳转过来的</p>
<p>3)     <code>withRouter</code>函数：当一个非路由组件也想访问到当前路由的match,location,history对象，那么withRouter将是一个非常好的选择</p>
<h2 id="6-3-基本路由使用"><a href="#6-3-基本路由使用" class="headerlink" title="6.3 基本路由使用"></a>6.3 基本路由使用</h2><h3 id="6-3-1-效果"><a href="#6-3-1-效果" class="headerlink" title="6.3.1 效果"></a>6.3.1 效果</h3><p>![react-router demo1 (3)](<a href="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react-router" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react-router</a> demo1 (3).gif)</p>
<p>并没有刷新页面</p>
<h3 id="6-3-2-准备"><a href="#6-3-2-准备" class="headerlink" title="6.3.2 准备"></a>6.3.2 准备</h3><p>1)     下载react-router: <code>npm install --save react-router@4</code></p>
<p>我们只需要web版本：<code>npm install --save react-router-dom</code></p>
<p>2)     由于使用到了BootStrap，因此在index.html中引入bootstrap.css: <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;</code></p>
<p><code>public/index.html</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;
    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt;
    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot;&gt;
    &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt;
    &lt;title&gt;React-router&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>一般会将路由组件和非路由组件分开写</p>
<p>pages/views存放路由组件</p>
<p>components存放其他组件</p>
<h3 id="6-3-3-路由组件-views-about-jsx"><a href="#6-3-3-路由组件-views-about-jsx" class="headerlink" title="6.3.3 路由组件: views/about.jsx"></a>6.3.3 路由组件: <code>views/about.jsx</code></h3><pre><code class="jsx">import React,{Component} from &#39;react&#39;
export default class About extends Component{
  render(){
    return(
        &lt;div&gt;About组件内容&lt;/div&gt;
      )
  }
}</code></pre>
<h3 id="6-3-4-路由组件-views-home-jsx"><a href="#6-3-4-路由组件-views-home-jsx" class="headerlink" title="6.3.4 路由组件: views/home.jsx"></a>6.3.4 路由组件: <code>views/home.jsx</code></h3><pre><code class="jsx">import React, {Component} from &#39;react&#39;

export default class Home extends Component{
  render(){
    return (
        &lt;div&gt;Home组件内容&lt;/div&gt;
      )
  }
}</code></pre>
<h3 id="6-3-5-包装NavLink组件-components-my-nav-link-jsx"><a href="#6-3-5-包装NavLink组件-components-my-nav-link-jsx" class="headerlink" title="6.3.5 包装NavLink组件: components/my-nav-link.jsx"></a>6.3.5 包装NavLink组件: <code>components/my-nav-link.jsx</code></h3><p>由于每个NavLink都需要自定义active样式(加入属性activeClassName)，因此提出来</p>
<pre><code class="jsx">import React, {Component} from &#39;react&#39;
import {NavLink} from &#39;react-router-dom&#39;

export default class MyNavLink extends Component {
  render(){
    // 利用this.props三点运算符接受所有的属性
    return(
      &lt;NavLink {...this.props} activeClassName=&#39;activeClass&#39;/&gt;
    )
  }
}</code></pre>
<h3 id="6-3-6-应用组件-components-app-jsx"><a href="#6-3-6-应用组件-components-app-jsx" class="headerlink" title="6.3.6 应用组件: components/app.jsx"></a>6.3.6 应用组件: <code>components/app.jsx</code></h3><pre><code class="jsx">import React from &#39;react&#39;
import {NavLink, Route, Switch, Redirect} from &#39;react-router-dom&#39;
import MyNavLink from &#39;./my-nav-link&#39;
import About from &#39;../views/about&#39;
import Home from &#39;../views/home&#39;

export default class App extends React.Component {

  render() {
    return (
      &lt;div&gt;
        &lt;div className=&quot;row&quot;&gt;
          &lt;div className=&quot;col-xs-offset-2 col-xs-8&quot;&gt;
            &lt;div className=&quot;page-header&quot;&gt;
              &lt;h2&gt;React Router Demo&lt;/h2&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div className=&quot;row&quot;&gt;
          &lt;div className=&quot;col-xs-2 col-xs-offset-2&quot;&gt;
            &lt;div className=&quot;list-group&quot;&gt;
              {/*导航路由链接，不能使用a标签，to指向的path*/}
              &lt;MyNavLink className=&quot;list-group-item&quot; to=&#39;/about&#39;&gt;About&lt;/MyNavLink&gt;
              &lt;MyNavLink className=&quot;list-group-item&quot; to=&#39;/home&#39;&gt;Home&lt;/MyNavLink&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div className=&quot;col-xs-6&quot;&gt;
            &lt;div className=&quot;panel&quot;&gt;
              &lt;div className=&quot;panel-body&quot;&gt;
                {/*可切换的路由组件，使用switch只有匹配才显示，route的path对应上方的to、component对应路由组件，Redirect自动重定向到about、默认到about组件*/}
                &lt;Switch&gt;
                  &lt;Route path=&#39;/about&#39; component={About}/&gt;
                  &lt;Route path=&#39;/home&#39; component={Home}/&gt;
                  &lt;Redirect to=&#39;/about&#39;/&gt;
                &lt;/Switch&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h3 id="6-3-7-自定义样式-index-css"><a href="#6-3-7-自定义样式-index-css" class="headerlink" title="6.3.7 自定义样式: index.css"></a>6.3.7 自定义样式: <code>index.css</code></h3><pre><code class="css">activeClass{
  color: red !important;
}</code></pre>
<h3 id="6-3-8-入口JS-index-js"><a href="#6-3-8-入口JS-index-js" class="headerlink" title="6.3.8 入口JS: index.js"></a>6.3.8 入口JS: <code>index.js</code></h3><pre><code class="javascript">import React from &#39;react&#39;
//import ReactDOM from &#39;react-dom&#39;
import {render} from &#39;react-dom&#39;
import {BrowserRouter, HashRouter} from &#39;react-router-dom&#39;
import App from &#39;./components/app&#39;

import &#39;./index.css&#39;

// ReactDOM.render(
render(
  (
    &lt;BrowserRouter&gt;
      &lt;App/&gt;
    &lt;/BrowserRouter&gt;
    /* 组件需要用路由器组件包含起来，两者任选一个 */
    /*&lt;HashRouter&gt;
      &lt;App /&gt;
    &lt;/HashRouter&gt;*/
  ),
  document.getElementById(&#39;root&#39;)
)</code></pre>
<p>总结：如何编写路由效果？</p>
<ol>
<li>编写路由组件</li>
<li>在父路由组件中指定<ul>
<li>路由连接：<code>&lt;NavLink&gt;&lt;/NavLink&gt;</code></li>
<li>路由：<code>&lt;Route&gt;&lt;/Route&gt;</code></li>
</ul>
</li>
</ol>
<h2 id="6-4-嵌套路由使用"><a href="#6-4-嵌套路由使用" class="headerlink" title="6.4 嵌套路由使用"></a>6.4 嵌套路由使用</h2><p>嵌套路由——路由组件中的路由</p>
<h3 id="6-4-1-效果"><a href="#6-4-1-效果" class="headerlink" title="6.4.1 效果"></a>6.4.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react-router-demo2.gif" alt="react-router demo2" class="lazyload"></p>
<h3 id="6-4-2-二级路由组件-views-news-jsx"><a href="#6-4-2-二级路由组件-views-news-jsx" class="headerlink" title="6.4.2 二级路由组件: views/news.jsx"></a>6.4.2 二级路由组件: <code>views/news.jsx</code></h3><pre><code class="jsx">import React from &#39;react&#39;

export default class News extends React.Component {
  state = {
    newsArr: [&#39;news001&#39;, &#39;news002&#39;, &#39;news003&#39;]
  }

  render () {
    return (
      &lt;div&gt;
        &lt;ul&gt;
          {
            this.state.newsArr.map((news, index) =&gt; &lt;li key={index}&gt;{news}&lt;/li&gt;)
          }
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h3 id="6-4-3-二级路由组件-views-message-jsx"><a href="#6-4-3-二级路由组件-views-message-jsx" class="headerlink" title="6.4.3 二级路由组件: views/message.jsx"></a>6.4.3 二级路由组件: <code>views/message.jsx</code></h3><pre><code class="jsx">import React from &#39;react&#39;
import {Link, Route} from &#39;react-router-dom&#39;

export default class Message extends React.Component {
  state = {
    messages: []
  }

  componentDidMount () {
    // 模拟发送ajax请求
    setTimeout(() =&gt; {
      const data = [
        {id: 1, title: &#39;Message001&#39;},
        {id: 3, title: &#39;Message003&#39;},
        {id: 6, title: &#39;Message006&#39;},
      ]
      this.setState({
        messages: data
      })
    }, 1000)
  }

  render () {
    const path = this.props.match.path

    return (
      &lt;div&gt;
        &lt;ul&gt;
          {
            this.state.messages.map((m, index) =&gt; {
              return (
                &lt;li key={index}&gt;
                   &lt;a href=&#39;???&#39;&gt;{m.title}&lt;/a&gt;
                &lt;/li&gt;
              )
            })
          }
        &lt;/ul&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h3 id="6-4-4-一级路由组件-views-home-jsx"><a href="#6-4-4-一级路由组件-views-home-jsx" class="headerlink" title="6.4.4 一级路由组件: views/home.jsx"></a>6.4.4 一级路由组件: <code>views/home.jsx</code></h3><pre><code class="jsx">import React, {Component} from &#39;react&#39;
import {Switch, Route, Redirect} from &#39;react-router-dom&#39;
import MyNavLink from &#39;../components/my-nav-link&#39;
import News from &#39;./news&#39;
import Message from &#39;./message&#39;

export default class Home extends Component{
  render(){
    return (
      &lt;div&gt;
        &lt;h2&gt;Home组件内容&lt;/h2&gt;
        &lt;div&gt;
          &lt;ul className=&quot;nav nav-tabs&quot;&gt;
            &lt;li&gt;
              &lt;MyNavLink to=&#39;/home/news&#39;&gt;News&lt;/MyNavLink&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;MyNavLink to=&quot;/home/message&quot;&gt;Message&lt;/MyNavLink&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
          &lt;Switch&gt;
            &lt;Route path=&#39;/home/news&#39; component={News} /&gt;
            &lt;Route path=&#39;/home/message&#39; component={Message} /&gt;
            &lt;Redirect to=&#39;/home/news&#39;/&gt;
          &lt;/Switch&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h2 id="6-5-向路由组件传递参数数据"><a href="#6-5-向路由组件传递参数数据" class="headerlink" title="6.5 向路由组件传递参数数据"></a>6.5 向路由组件传递参数数据</h2><p>传递的是id值</p>
<h3 id="6-5-1-效果"><a href="#6-5-1-效果" class="headerlink" title="6.5.1 效果"></a>6.5.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react-router-demo3.gif" alt="react-router demo3 (2)" class="lazyload"></p>
<h3 id="6-5-2-三级路由组件-views-message-detail-jsx"><a href="#6-5-2-三级路由组件-views-message-detail-jsx" class="headerlink" title="6.5.2 三级路由组件: views/message-detail.jsx"></a>6.5.2 三级路由组件: <code>views/message-detail.jsx</code></h3><pre><code class="jsx">import React from &#39;react&#39;

const messageDetails = [
  {id: 1, title: &#39;Message001&#39;, content: &#39;中国，你是最棒的&#39;},
  {id: 3, title: &#39;Message003&#39;, content: &#39;对的，没错，非常赞成楼上&#39;},
  {id: 6, title: &#39;Message006&#39;, content: &#39;我也赞成&#39;},
]

// 函数的组件
export default function MessageDetail(props) {

  const id = props.match.params.id
  const md = messageDetails.find(md =&gt; md.id===id*1)

  return (
    &lt;ul&gt;
      &lt;li&gt;ID: {md.id}&lt;/li&gt;
      &lt;li&gt;TITLE: {md.title}&lt;/li&gt;
      &lt;li&gt;CONTENT: {md.content}&lt;/li&gt;
    &lt;/ul&gt;
  )
}</code></pre>
<h3 id="6-5-3-二级路由组件-views-message-jsx"><a href="#6-5-3-二级路由组件-views-message-jsx" class="headerlink" title="6.5.3 二级路由组件: views/message.jsx"></a>6.5.3 二级路由组件: <code>views/message.jsx</code></h3><pre><code class="jsx">import React from &#39;react&#39;
import {Link, Route} from &#39;react-router-dom&#39;
import MessageDetail from &quot;./message-detail&quot;

export default class Message extends React.Component {
  state = {
    messages: []
  }

  componentDidMount () {
    // 模拟发送ajax请求
    setTimeout(() =&gt; {
      const data = [
        {id: 1, title: &#39;Message001&#39;},
        {id: 3, title: &#39;Message003&#39;},
        {id: 6, title: &#39;Message006&#39;},
      ]
      this.setState({
        messages: data
      })
    }, 1000)
  }

  render () {
    const path = this.props.match.path

    return (
      &lt;div&gt;
        &lt;ul&gt;
          {
            this.state.messages.map((m, index) =&gt; {
              return (
                &lt;li key={index}&gt;
                  &lt;Link to={`${path}/${m.id}`}&gt;{m.title}&lt;/Link&gt;
                &lt;/li&gt;
              )
            })
          }
        &lt;/ul&gt;
        &lt;Route path={`${path}/:id`} component={MessageDetail}&gt;&lt;/Route&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<p>路由链接与非路由链接：是否发了请求(路由连接不发)</p>
<p><code>&lt;NavLink to=&#39;&#39;&gt;&lt;/NavLink&gt;`` &lt;Link to=&#39;&#39;&gt;&lt;/Link&gt;</code></p>
<p><code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="6-6-多种路由跳转方式"><a href="#6-6-多种路由跳转方式" class="headerlink" title="6.6 多种路由跳转方式"></a>6.6 多种路由跳转方式</h2><p>前面讲的路由切换都是通过点击链接的方式切换的，不是链接也能够</p>
<h3 id="6-6-1-效果"><a href="#6-6-1-效果" class="headerlink" title="6.6.1 效果"></a>6.6.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/react-router-demo4.gif" alt="react-router demo4" class="lazyload"></p>
<h3 id="6-6-2-二级路由-views-message-jsx"><a href="#6-6-2-二级路由-views-message-jsx" class="headerlink" title="6.6.2 二级路由: views/message.jsx"></a>6.6.2 二级路由: views/message.jsx</h3><pre><code class="jsx">import React from &#39;react&#39;
import {Link, Route} from &#39;react-router-dom&#39;
import MessageDetail from &quot;./message-detail&quot;

export default class Message extends React.Component {
  state = {
    messages: []
  }

  componentDidMount () {
    // 模拟发送ajax请求
    setTimeout(() =&gt; {
      const data = [
        {id: 1, title: &#39;Message001&#39;},
        {id: 3, title: &#39;Message003&#39;},
        {id: 6, title: &#39;Message006&#39;},
      ]
      this.setState({
        messages: data
      })
    }, 1000)
  }

  // props中有history属性，它由push等方法
  ShowDetail = (id) =&gt; {
    this.props.history.push(`/home/message/${id}`)
  }

  ShowDetail2 = (id) =&gt; {
    this.props.history.replace(`/home/message/${id}`)
  }

  back = () =&gt; {
    this.props.history.goBack()
  }

  forward = () =&gt; {
    this.props.history.goForward()
  }

  render () {
    const path = this.props.match.path

    return (
      &lt;div&gt;
        &lt;ul&gt;
          {
            this.state.messages.map((m, index) =&gt; {
              return (
                &lt;li key={index}&gt;
                  &lt;Link to={`${path}/${m.id}`}&gt;{m.title}&lt;/Link&gt;
                  &amp;nbsp;&amp;nbsp;&amp;nbsp;
                  &lt;button onClick={() =&gt; this.ShowDetail(m.id)}&gt;查看详情(push)&lt;/button&gt;&amp;nbsp;
                  &lt;button onClick={() =&gt; this.ShowDetail2(m.id)}&gt;查看详情(replace)&lt;/button&gt;
                &lt;/li&gt;
              )
            })
          }
        &lt;/ul&gt;
        &lt;p&gt;
          &lt;button onClick={this.back}&gt;返回&lt;/button&gt;&amp;nbsp;
          &lt;button onClick={this.forward}&gt;前进&lt;/button&gt;&amp;nbsp;
        &lt;/p&gt;
        &lt;hr/&gt;
        &lt;Route path={`${path}/:id`} component={MessageDetail}&gt;&lt;/Route&gt;
        {/*&lt;Route path={`home/message/meassagedetail/:id`} component={MessageDetail}&gt;&lt;/Route&gt;*/}
      &lt;/div&gt;
    )
  }
}</code></pre>
<p> 总结：</p>
<ul>
<li>路由器标签<ul>
<li><code>&lt;BrowserRouter&gt;</code>：BrowserRouter是react路由的容器</li>
<li><code>&lt;HashRouter&gt;</code>：多了一个#号</li>
</ul>
</li>
<li>路由<ul>
<li><code>&lt;Route&gt;</code>：Route的作用就是用来渲染路由匹配的组件。路由渲染有三种方式，每一种方式都可以传递match,location,history对象</li>
</ul>
</li>
<li><code>&lt;Redirect&gt;</code>：路由重定向</li>
<li>链接<ul>
<li><code>&lt;Link&gt;</code>：Link的作用和a标签类似</li>
<li><code>&lt;NavLink&gt;</code>：可以添加其他属性，例如activeClassName</li>
</ul>
</li>
<li><ul>
<li><code>&lt;Switch&gt;</code>：Switch组件内部可以是Route或者Redirect，只会渲染第一个匹配的元素</li>
</ul>
</li>
</ul>
<ul>
<li>this.props.<ul>
<li>match<ul>
<li>params</li>
</ul>
</li>
<li>history<ul>
<li>push()</li>
<li>replace()</li>
<li>goback()</li>
<li>goforward()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第7章-react-ui"><a href="#第7章-react-ui" class="headerlink" title="第7章 react-ui"></a>第7章 react-ui</h1><h2 id="7-1-最流行的开源React-UI组件库"><a href="#7-1-最流行的开源React-UI组件库" class="headerlink" title="7.1 最流行的开源React UI组件库"></a>7.1 最流行的开源React UI组件库</h2><h3 id="7-1-1-material-ui-国外"><a href="#7-1-1-material-ui-国外" class="headerlink" title="7.1.1 material-ui(国外)"></a>7.1.1 material-ui(国外)</h3><p>1)     官网: <a href="http://www.material-ui.com/#/" target="_blank" rel="noopener">http://www.material-ui.com/#/</a></p>
<p>2)     github: <a href="https://github.com/callemall/material-ui" target="_blank" rel="noopener">https://github.com/callemall/material-ui</a></p>
<h3 id="7-1-2-ant-design-国内蚂蚁金服"><a href="#7-1-2-ant-design-国内蚂蚁金服" class="headerlink" title="7.1.2 ant-design(国内蚂蚁金服)"></a>7.1.2 ant-design(国内蚂蚁金服)</h3><p>1)     PC官网: <a href="https://ant.design/index-cn" target="_blank" rel="noopener">https://ant.design/index-cn</a></p>
<p>2)     移动官网: <a href="https://mobile.ant.design/index-cn" target="_blank" rel="noopener">https://mobile.ant.design/index-cn</a></p>
<p>3)     Github: <a href="https://github.com/ant-design/ant-design/" target="_blank" rel="noopener">https://github.com/ant-design/ant-design/</a></p>
<p>4)     Github: <a href="https://github.com/ant-design/ant-design-mobile/" target="_blank" rel="noopener">https://github.com/ant-design/ant-design-mobile/</a></p>
<h2 id="7-2-ant-design-mobile使用入门"><a href="#7-2-ant-design-mobile使用入门" class="headerlink" title="7.2 ant-design-mobile使用入门"></a>7.2 ant-design-mobile使用入门</h2><h3 id="7-2-1-效果"><a href="#7-2-1-效果" class="headerlink" title="7.2.1 效果"></a>7.2.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/antd-mobile.gif" alt="antd-mobile" class="lazyload"></p>
<h3 id="7-2-2-使用create-react-app创建react应用"><a href="#7-2-2-使用create-react-app创建react应用" class="headerlink" title="7.2.2 使用create-react-app创建react应用"></a>7.2.2 使用create-react-app创建react应用</h3><pre><code class="bash">npm install create-react-app -g
create-react-app antm-demo
cd antm-demo
npm start</code></pre>
<h3 id="7-2-3-搭建antd-mobile的基本开发环境"><a href="#7-2-3-搭建antd-mobile的基本开发环境" class="headerlink" title="7.2.3 搭建antd-mobile的基本开发环境"></a>7.2.3 搭建antd-mobile的基本开发环境</h3><p>1)     下载</p>
<p><code>npm install antd-mobile --save</code></p>
<p>2)     <code>src/components/App.jsx</code></p>
<pre><code class="jsx">import React, {Component} from &#39;react&#39;
import {Button, Toast} from &#39;antd-mobile&#39;
export default class App extends Component {
  handleClick = () =&gt; {
    Toast.info(&#39;提交成功&#39;, 2)
  }

  render() {
    return (
        &lt;div&gt;
          &lt;Button type=&quot;primary&quot; onClick={this.handleClick}&gt;提交&lt;/Button&gt;
        &lt;/div&gt;   
      )
  }
  /* type值不同样式不同 */
}</code></pre>
<p>3)     <code>src/index.js</code></p>
<pre><code class="javascript">import React from &#39;react&#39;;
import {render} from &#39;react-dom&#39;
import App from &quot;./components/App&quot;
// 引入整体css
import &#39;antd-mobile/dist/antd-mobile.css&#39;

render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))
</code></pre>
<p>4)     <code>index.html</code></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;
    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt;
    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot;&gt;
    &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt;
    &lt;title&gt;React ant design mobile&lt;/title&gt;
    &lt;script src=&quot;https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      if (&#39;addEventListener&#39; in document) {
        document.addEventListener(&#39;DOMContentLoaded&#39;, function() {
          FastClick.attach(document.body);
        }, false);
      }
      if(!window.Promise) {
        document.writeln(&#39;&lt;script src=&quot;https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js&quot;&#39;+&#39;&gt;&#39;+&#39;&lt;&#39;+&#39;/&#39;+&#39;script&gt;&#39;);
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="7-2-4-实现按需打包-组件js-css"><a href="#7-2-4-实现按需打包-组件js-css" class="headerlink" title="7.2.4 实现按需打包(组件js/css)"></a>7.2.4 实现按需打包(组件js/css)</h3><p>1)     下载依赖包</p>
<pre><code class="bash">yarn add react-app-rewired --dev
yarn add babel-plugin-import --dev</code></pre>
<p>2)     修改默认配置: </p>
<p>l package.json</p>
<pre><code class="json">{
  &quot;name&quot;: &quot;react_ui&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;antd-mobile&quot;: &quot;^2.1.3&quot;,
    &quot;react&quot;: &quot;^16.2.0&quot;,
    &quot;react-dom&quot;: &quot;^16.2.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;babel-plugin-import&quot;: &quot;^1.6.3&quot;,
    &quot;react-app-rewired&quot;: &quot;^1.4.0&quot;,
    &quot;react-scripts&quot;: &quot;1.0.17&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-app-rewired start&quot;,
    &quot;build&quot;: &quot;react-app-rewired build&quot;,
    &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;
  }
}</code></pre>
<p>l config-overrides.js</p>
<pre><code class="javascript">const {injectBabelPlugin} = require(&#39;react-app-rewired&#39;);
module.exports = function override(config, env) {
  config = injectBabelPlugin([&#39;import&#39;, {libraryName: &#39;antd-mobile&#39;, style: &#39;css&#39;}], config);
  return config;
};</code></pre>
<p>3)     编码</p>
<pre><code class="jsx">// import &#39;antd-mobile/dist/antd-mobile.css&#39;
// import Button from &#39;antd-mobile/lib/button&#39;
// import Toast from &#39;antd-mobile/lib/toast&#39; 
import {Button, Toast} from &#39;antd-mobile&#39;</code></pre>
<h1 id="第8章-redux"><a href="#第8章-redux" class="headerlink" title="第8章 redux"></a>第8章 redux</h1><h2 id="8-1-redux理解"><a href="#8-1-redux理解" class="headerlink" title="8.1 redux理解"></a>8.1 redux理解</h2><h3 id="8-1-1-学习文档"><a href="#8-1-1-学习文档" class="headerlink" title="8.1.1 学习文档"></a>8.1.1 学习文档</h3><p>1)     英文文档: <a href="https://redux.js.org/" target="_blank" rel="noopener">https://redux.js.org/</a></p>
<p>2)     中文文档: <a href="http://www.redux.org.cn/" target="_blank" rel="noopener">http://www.redux.org.cn/</a></p>
<p>3)     Github: <a href="https://github.com/reactjs/redux" target="_blank" rel="noopener">https://github.com/reactjs/redux</a></p>
<h3 id="8-1-2-redux是什么"><a href="#8-1-2-redux是什么" class="headerlink" title="8.1.2 redux是什么?"></a>8.1.2 redux是什么?</h3><p>1)     redux是一个独立专门用于做<strong>状态管理</strong>的<strong>JS库</strong>(不是react插件库)</p>
<p>2)     它可以用在react, angular, vue等项目中, 但基本与react配合使用</p>
<p>3)     作用: <strong>集中式管理</strong>react应用中多个组件共享的状态</p>
<h3 id="8-1-3-redux工作流程"><a href="#8-1-3-redux工作流程" class="headerlink" title="8.1.3 redux工作流程"></a>8.1.3 redux工作流程</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200715104120743.png" alt="redux" class="lazyload"></p>
<h3 id="8-1-4-什么情况下需要使用redux"><a href="#8-1-4-什么情况下需要使用redux" class="headerlink" title="8.1.4 什么情况下需要使用redux"></a>8.1.4 什么情况下需要使用redux</h3><p>1)     总体原则: 能不用就不用, 如果不用比较吃力才考虑使用</p>
<p>2)     某个组件的状态，需要共享</p>
<p>3)     某个状态需要在任何地方都可以拿到</p>
<p>4)     一个组件需要改变全局状态</p>
<p>5)     一个组件需要改变另一个组件的状态</p>
<h2 id="8-2-redux的核心API"><a href="#8-2-redux的核心API" class="headerlink" title="8.2 redux的核心API"></a>8.2 redux的核心API</h2><h3 id="8-2-1-createStore"><a href="#8-2-1-createStore" class="headerlink" title="8.2.1 createStore()"></a>8.2.1 <code>createStore()</code></h3><p>1)     作用:  创建包含指定reducer的store对象</p>
<p>2)     编码:</p>
<pre><code>import {createStore} from &#39;redux&#39;
import counter from &#39;./reducers/counter&#39;
const store = createStore(counter)</code></pre><h3 id="8-2-2-store对象"><a href="#8-2-2-store对象" class="headerlink" title="8.2.2 store对象"></a>8.2.2 <code>store</code>对象</h3><p>1)     作用: </p>
<p>redux库最核心的管理对象</p>
<p>2)     它内部维护着:</p>
<ul>
<li><p><code>state</code></p>
</li>
<li><p><code>reducer</code></p>
</li>
</ul>
<p>3)     核心方法:</p>
<ul>
<li><p><code>getState()</code></p>
</li>
<li><p><code>dispatch(action)</code></p>
</li>
<li><p><code>subscribe(listener)</code></p>
</li>
</ul>
<p>4)     编码:</p>
<pre><code>store.getState()
store.dispatch({type:&#39;INCREMENT&#39;, number})
store.subscribe(render)</code></pre><h3 id="8-2-3-applyMiddleware"><a href="#8-2-3-applyMiddleware" class="headerlink" title="8.2.3 applyMiddleware()"></a>8.2.3 <code>applyMiddleware()</code></h3><p>1)     作用:</p>
<p>应用上基于redux的中间件(插件库)</p>
<p>2)     编码:</p>
<pre><code>import {createStore, applyMiddleware} from &#39;redux&#39;
import thunk from &#39;redux-thunk&#39; // redux异步中间件
const store = createStore(
 counter,
 applyMiddleware(thunk) // 应用上异步中间件
)</code></pre><h3 id="8-2-4-combineReducers"><a href="#8-2-4-combineReducers" class="headerlink" title="8.2.4 combineReducers()"></a>8.2.4 <code>combineReducers()</code></h3><p>1)     作用:</p>
<p>合并多个reducer函数</p>
<p>2)     编码:</p>
<pre><code>export default combineReducers({
 user,
 chatUser,
 chat
})</code></pre><h2 id="8-3-redux的三个核心概念"><a href="#8-3-redux的三个核心概念" class="headerlink" title="8.3 redux的三个核心概念"></a>8.3 redux的三个核心概念</h2><h3 id="8-3-1-action"><a href="#8-3-1-action" class="headerlink" title="8.3.1 action"></a>8.3.1 <code>action</code></h3><p>1)     标识要执行行为的对象</p>
<p>2)     包含2个方面的属性</p>
<p>a.     type: 标识属性, 值为字符串, 唯一, 必要属性</p>
<p>b.     xxx: 数据属性, 值类型任意, 可选属性</p>
<p>3)     例子:</p>
<pre><code>const action = {
    type: &#39;INCREMENT&#39;,
    data: 2
}</code></pre><p>4)     Action Creator(创建Action的工厂函数)</p>
<pre><code>const increment = (number) =&gt; ({type: &#39;INCREMENT&#39;, data: number})</code></pre><h3 id="8-3-2-reducer"><a href="#8-3-2-reducer" class="headerlink" title="8.3.2 reducer"></a>8.3.2 <code>reducer</code></h3><p>1)     根据老的state和action, 产生新的state的纯函数</p>
<p>2)     样例</p>
<pre><code>export default function counter(state = 0, action) {
  switch (action.type) {
     case &#39;INCREMENT&#39;:
        return state + action.data
     case &#39;DECREMENT&#39;:
        return state - action.data
     default:
        return state
  }
}</code></pre><p>3)     注意</p>
<p>a.     返回一个新的状态</p>
<p>b.     不要修改原来的状态</p>
<h3 id="8-3-3-store"><a href="#8-3-3-store" class="headerlink" title="8.3.3 store"></a>8.3.3 <code>store</code></h3><p>1)     将state,action与reducer联系在一起的对象</p>
<p>2)     如何得到此对象?</p>
<pre><code>import {createStore} from &#39;redux&#39;
import reducer from &#39;./reducers&#39;
const store = createStore(reducer)</code></pre><p>3)     此对象的功能?</p>
<ul>
<li><p>getState(): 得到state</p>
</li>
<li><p>dispatch(action): 分发action, 触发reducer调用, 产生新的state</p>
</li>
<li><p>subscribe(listener): 注册监听, 当产生了新的state时, 自动调用</p>
</li>
</ul>
<h2 id="8-4-使用redux编写应用"><a href="#8-4-使用redux编写应用" class="headerlink" title="8.4 使用redux编写应用"></a>8.4 使用redux编写应用</h2><h3 id="8-4-1-效果"><a href="#8-4-1-效果" class="headerlink" title="8.4.1 效果"></a>8.4.1 效果</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/redux.gif" alt="redux" class="lazyload"></p>
<p>使用react实现</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200715112226383.png" alt="app.jsx" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/image-20200715112313127.png" alt="index.js" class="lazyload"></p>
<h3 id="8-4-2-下载依赖包"><a href="#8-4-2-下载依赖包" class="headerlink" title="8.4.2 下载依赖包"></a>8.4.2 下载依赖包</h3><p><code>npm install --save redux</code></p>
<h3 id="8-4-3-src-redux-action-types-js"><a href="#8-4-3-src-redux-action-types-js" class="headerlink" title="8.4.3 src/redux/action-types.js"></a>8.4.3 <code>src/redux/action-types.js</code></h3><pre><code class="javascript">/*
Action对象的type常量名称模块
 */
export const INCREMENT = &#39;increment&#39;
export const DECREMENT = &#39;decrement&#39;</code></pre>
<h3 id="8-4-4-src-redux-actions-js"><a href="#8-4-4-src-redux-actions-js" class="headerlink" title="8.4.4 src/redux/actions.js"></a>8.4.4 <code>src/redux/actions.js</code></h3><pre><code class="javascript">/*
action creator模块
 */
import {INCREMENT, DECREMENT} from &#39;./action-types&#39;

export const increment = number =&gt; ({type: INCREMENT, number})
export const decrement = number =&gt; ({type: DECREMENT, number})</code></pre>
<h3 id="8-4-5-src-redux-reducers-js"><a href="#8-4-5-src-redux-reducers-js" class="headerlink" title="8.4.5 src/redux/reducers.js"></a>8.4.5 <code>src/redux/reducers.js</code></h3><pre><code class="javascript">/*
包含n个reducer函数的模块
根据老的state和指定action, 处理返回一个新的state
 */
import {INCREMENT, DECREMENT} from &#39;./action-types&#39;

export function counter(state = 0, action) {
  console.log(&#39;counter&#39;, state, action)
  switch (action.type) {
    case INCREMENT:
      return state + action.number
    case DECREMENT:
      return state - action.number
    default:
      return state
  }
}</code></pre>
<h3 id="8-4-6-src-components-app-jsx"><a href="#8-4-6-src-components-app-jsx" class="headerlink" title="8.4.6 src/components/app.jsx"></a>8.4.6 <code>src/components/app.jsx</code></h3><pre><code class="jsx">/*
应用组件
 */
import React, {Component} from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import * as actions from &#39;../redux/actions&#39;
import { INCREMENT } from &#39;../redux/action-types&#39;

export default class App extends Component {

  static propTypes = {
    store: PropTypes.object.isRequired,
  }

  increment = () =&gt; {
    // 1.得到选择增加数量
    const number = this.refs.numSelect.value * 1
    // 2.调用store的方法更新状态
    this.props.store.dispatch(actions.increment(number))
  }

  decrement = () =&gt; {
    // 1.得到选择减小数量
    const number = this.refs.numSelect.value * 1
    // 2.调用store的方法更新状态
    this.props.store.dispatch(actions.decrement(number))
  }

  incrementIfOdd = () =&gt; {
    // 1.得到选择增加数量
    const number = this.refs.numSelect.value * 1
    // 2.得到原本的count状态
    let count = this.props.store.getState()
    // 判断，满足条件猜更新状态
    if (count % 2 === 1) {
      // 调用store的方法更新状态
      this.props.store.dispatch(actions.increment(number))
    }
  }

  incrementAsync = () =&gt; {
    // 1.得到选择增加数量
    const number = this.refs.numSelect.value * 1
    // 2.启动延时定时器，模拟异步
    setTimeout(() =&gt; {
      // 3.调用store的方法更新状态
      this.props.store.dispatch(actions.increment(number))
    }, 1000)
  }

  render() {
    const count = this.props.store.getState()
    return (
      &lt;div&gt;
        &lt;p&gt;
          click {count} times {&#39; &#39;}
        &lt;/p&gt;
        &lt;select ref=&quot;numSelect&quot;&gt;
          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
        &lt;/select&gt;{&#39; &#39;}
        &lt;button onClick={this.increment}&gt;+&lt;/button&gt;
        {&#39; &#39;}
        &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;
        {&#39; &#39;}
        &lt;button onClick={this.incrementIfOdd}&gt;increment if odd&lt;/button&gt;
        {&#39; &#39;}
        &lt;button onClick={this.incrementAsync}&gt;increment async&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h3 id="8-4-7-src-index-js"><a href="#8-4-7-src-index-js" class="headerlink" title="8.4.7 src/index.js"></a>8.4.7 <code>src/index.js</code></h3><pre><code class="javascript">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import {createStore} from &#39;redux&#39;

import App from &#39;./components/app&#39;
import {counter} from &#39;./redux/reducers&#39;

// 根据counter函数创建store对象
const store = createStore(counter) // 内部会第一次调用reduer函数，得到初始state

// 定义渲染根组件标签的函数
const render = () =&gt; {
  ReactDOM.render(
    &lt;App store={store}/&gt;,
    document.getElementById(&#39;root&#39;)
  )
}
// 初始化渲染
render()

// 注册(订阅)监听, 一旦状态发生改变, 自动重新渲染
store.subscribe(render)</code></pre>
<p>也可以把index.js中store提取出来</p>
<ul>
<li><code>src/redux/store.js</code></li>
</ul>
<pre><code class="javascript">import {createStore} from &#39;redux&#39;
import {counter} from &#39;./reducers&#39;
// 根据counter函数创建store对象
const store = createStore(counter)  // // 内部会第一次调用reduer函数，得到初始state

export default store</code></pre>
<ul>
<li><code>src/index.js</code></li>
</ul>
<pre><code class="javascript">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;

import App from &#39;./components/app&#39;
import store from &#39;./redux/store&#39;

// 定义渲染根组件标签的函数
const render = () =&gt; {
  ReactDOM.render(
    &lt;App store={store}/&gt;,
    document.getElementById(&#39;root&#39;)
  )
}
// 初始化渲染
render()

// 注册(订阅)监听, 一旦状态发生改变, 自动重新渲染
store.subscribe(render)</code></pre>
<h3 id="8-4-8-问题"><a href="#8-4-8-问题" class="headerlink" title="8.4.8 问题"></a>8.4.8 问题</h3><p>1)     redux与react组件的代码耦合度太高(大多数地方用到store)</p>
<p>2)     编码不够简洁</p>
<h2 id="8-5-react-redux"><a href="#8-5-react-redux" class="headerlink" title="8.5 react-redux"></a>8.5 react-redux</h2><h3 id="8-5-1-理解"><a href="#8-5-1-理解" class="headerlink" title="8.5.1 理解"></a>8.5.1 理解</h3><p>1)     一个<strong>react插件库</strong></p>
<p>2)     专门用来简化react应用中使用redux</p>
<h3 id="8-5-2-React-Redux将所有组件分成两大类"><a href="#8-5-2-React-Redux将所有组件分成两大类" class="headerlink" title="8.5.2 React-Redux将所有组件分成两大类"></a>8.5.2 React-Redux将所有组件分成两大类</h3><p>1)     UI组件</p>
<p>​    a.     只负责 UI 的呈现，不带有任何业务逻辑</p>
<p>​    b.     通过props接收数据(一般数据和函数)</p>
<p>​    c.     不使用任何 Redux 的 API</p>
<p>​    d.     一般保存在<code>components</code>文件夹下</p>
<p>2)     容器组件</p>
<p>​    a.     负责管理数据和业务逻辑，不负责UI的呈现</p>
<p>​    b.     使用 Redux 的 API</p>
<p>​    c.     一般保存在<code>containers</code>文件夹下</p>
<h3 id="8-5-3-相关API"><a href="#8-5-3-相关API" class="headerlink" title="8.5.3 相关API"></a>8.5.3 相关API</h3><p>1)     <code>Provider</code></p>
<p>让所有组件都可以得到state数据</p>
<pre><code>&lt;Provider store={store}&gt;
   &lt;App /&gt;
&lt;/Provider&gt;</code></pre><p>2)     <code>connect()</code></p>
<p>用于包装 UI 组件生成容器组件</p>
<pre><code>import { connect } from &#39;react-redux&#39;
connect(
   mapStateToprops,
   mapDispatchToProps
)(Counter)</code></pre><p>3)     <code>mapStateToprops()</code></p>
<p>将外部的数据（即state对象）转换为UI组件的标签属性</p>
<pre><code>const mapStateToprops = function (state) {
  return {
   value: state
  }
}</code></pre><p>4)     <code>mapDispatchToProps()</code></p>
<p>将分发action的函数转换为UI组件的标签属性</p>
<p>简洁语法可以直接指定为actions对象或包含多个action方法的对象</p>
<h3 id="8-5-4-使用react-redux"><a href="#8-5-4-使用react-redux" class="headerlink" title="8.5.4 使用react-redux"></a>8.5.4 使用react-redux</h3><p>1)     下载依赖包</p>
<p><code>npm install --save react-redux</code></p>
<p>2)     <code>redux/action-types.js</code></p>
<p>不变</p>
<p>3)     <code>redux/actions.js</code></p>
<p>不变</p>
<p>4)     <code>redux/reducers.js</code></p>
<p>不变</p>
<p>5)     <code>components/counter.jsx</code></p>
<pre><code class="jsx">/*
UI组件: 不包含任何redux API
 */
import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;

export default class Counter extends React.Component {

  static propTypes = {
    count: PropTypes.number.isRequired,
    increment: PropTypes.func.isRequired,
    decrement: PropTypes.func.isRequired
  }

  increment = () =&gt; {
    const number = this.refs.numSelect.value * 1
    this.props.increment(number)
  }

  decrement = () =&gt; {
    const number = this.refs.numSelect.value * 1
    this.props.decrement(number)
  }

  incrementIfOdd = () =&gt; {
    const number = this.refs.numSelect.value * 1
    let count = this.props.count
    if (count % 2 === 1) {
      this.props.increment(number)
    }
  }

  incrementAsync = () =&gt; {
    const number = this.refs.numSelect.value * 1
    setTimeout(() =&gt; {
      this.props.increment(number)
    }, 1000)
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;
          click {this.props.count} times {&#39; &#39;}
        &lt;/p&gt;
        &lt;select ref=&quot;numSelect&quot;&gt;
          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
        &lt;/select&gt;{&#39; &#39;}
        &lt;button onClick={this.increment}&gt;+&lt;/button&gt;
        {&#39; &#39;}
        &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;
        {&#39; &#39;}
        &lt;button onClick={this.incrementIfOdd}&gt;increment if odd&lt;/button&gt;
        {&#39; &#39;}
        &lt;button onClick={this.incrementAsync}&gt;increment async&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<p>6)     <code>containters/app.jsx</code></p>
<pre><code class="jsx">/*
包含Counter组件的容器组件
 */
import React from &#39;react&#39;
// 引入连接函数
import {connect} from &#39;react-redux&#39;
// 引入action函数
import {increment, decrement} from &#39;../redux/actions&#39;

import Counter from &#39;../components/counter&#39;

// 向外暴露连接App组件的包装组件
export default connect(
  state =&gt; ({count: state}),
  {increment, decrement}
)(Counter)</code></pre>
<p>7)     <code>store.js</code></p>
<p>不变</p>
<p>8)     <code>index.js</code></p>
<pre><code class="javascript">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import {Provider} from &#39;react-redux&#39;

import App from &#39;./containers/app&#39;
import store from &#39;./redux/store&#39;

// 定义渲染根组件标签的函数
ReactDOM.render(
  (
    &lt;Provider store={store}&gt;
      &lt;App/&gt;
    &lt;/Provider&gt;
  ),
  document.getElementById(&#39;root&#39;)
)</code></pre>
<h3 id="8-5-5-问题"><a href="#8-5-5-问题" class="headerlink" title="8.5.5 问题"></a>8.5.5 问题</h3><p>1)    redux默认是不能进行异步处理的, （前面的都是react实现的）</p>
<p>2)    应用中又需要在redux中执行异步任务(ajax, 定时器)</p>
<h2 id="8-6-redux异步编程"><a href="#8-6-redux异步编程" class="headerlink" title="8.6 redux异步编程"></a>8.6 redux异步编程</h2><h3 id="8-6-1-下载redux插件-异步中间件"><a href="#8-6-1-下载redux插件-异步中间件" class="headerlink" title="8.6.1 下载redux插件(异步中间件)"></a>8.6.1 下载redux插件(异步中间件)</h3><p><code>npm install --save redux-thunk</code></p>
<h3 id="8-6-2-redux-store-js"><a href="#8-6-2-redux-store-js" class="headerlink" title="8.6.2 redux/store.js"></a>8.6.2 <code>redux/store.js</code></h3><pre><code class="javascript">import React from &#39;react&#39;
import {createStore, applyMiddleware} from &#39;redux&#39;
import thunk from &#39;redux-thunk&#39;
import {composeWithDevTools} from &#39;redux-devtools-extension&#39;

import reducers from &#39;./reducers&#39;

// 根据counter函数创建store对象
export default createStore(
  reducers,
  applyMiddleware(thunk) // 应用上异步中间件
)</code></pre>
<h3 id="8-6-3-index-js"><a href="#8-6-3-index-js" class="headerlink" title="8.6.3 index.js"></a>8.6.3 <code>index.js</code></h3><pre><code class="javascript">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import {Provider} from &#39;react-redux&#39;

import App from &#39;./containers/app&#39;
import store from &#39;./redux/store&#39;

// 定义渲染根组件标签的函数
ReactDOM.render(
  (
    &lt;Provider store={store}&gt;
      &lt;App/&gt;
    &lt;/Provider&gt;
  ),
  document.getElementById(&#39;root&#39;)
)</code></pre>
<h3 id="8-6-4-redux-actions-js"><a href="#8-6-4-redux-actions-js" class="headerlink" title="8.6.4 redux/actions.js"></a>8.6.4 <code>redux/actions.js</code></h3><pre><code class="jsx">/*
action creator模块
 */
import {
  INCREMENT,
  DECREMENT
} from &#39;./action-types&#39;

export const increment = number =&gt; ({type: INCREMENT, number})

export const decrement = number =&gt; ({type: DECREMENT, number})

// 异步action creator(返回一个函数)
export const incrementAsync = number =&gt; {
  return dispatch =&gt; { // 要在这返回一个函数，得在store中应用上异步中间件
    // 异步的代码
    setTimeout(() =&gt; {
      // 1s之后才分发一个增加的action
      dispatch(increment(number))
    }, 1000)
  }
}</code></pre>
<p> 同步的action都返回一个对象</p>
<p>异步的action返回的是一个函数</p>
<h3 id="8-6-5-components-counter-jsx"><a href="#8-6-5-components-counter-jsx" class="headerlink" title="8.6.5 components/counter.jsx"></a>8.6.5 <code>components/counter.jsx</code></h3><pre><code class="jsx">/*
包含Counter组件的容器组件
 */
import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;

export default class Counter extends React.Component {

  static propTypes = {
    count: PropTypes.number.isRequired,
    increment: PropTypes.func.isRequired,
    decrement: PropTypes.func.isRequired
  }

  increment = () =&gt; {
    const number = this.refs.numSelect.value*1
    this.props.increment(number)
  }

  decrement = () =&gt; {
    const number = this.refs.numSelect.value*1
    this.props.decrement(number)
  }

  incrementIfOdd = () =&gt; {
    const number = this.refs.numSelect.value*1
    let count = this.props.count
    if(count%2===1) {
      this.props.increment(number)
    }
  }

  // Async
  incrementAsync = () =&gt; {
    const number = this.refs.numSelect.value*1
    this.props.incrementAsync(number)
  }

  render () {
    return (
      &lt;div&gt;
        &lt;p&gt;
          click {this.props.count} times {&#39; &#39;}
        &lt;/p&gt;
        &lt;select ref=&quot;numSelect&quot;&gt;
          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
        &lt;/select&gt;{&#39; &#39;}
        &lt;button onClick={this.increment}&gt;+&lt;/button&gt;{&#39; &#39;}
        &lt;button onClick={this.decrement}&gt;-&lt;/button&gt;{&#39; &#39;}
        &lt;button onClick={this.incrementIfOdd}&gt;increment if odd&lt;/button&gt;{&#39; &#39;}
        &lt;button onClick={this.incrementAsync}&gt;increment async&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h3 id="8-6-6-containers-app-jsx"><a href="#8-6-6-containers-app-jsx" class="headerlink" title="8.6.6 containers/app.jsx"></a>8.6.6 <code>containers/app.jsx</code></h3><pre><code class="jsx">/*
包含Counter组件的容器组件
 */
import React from &#39;react&#39;
// 引入连接函数
import {connect} from &#39;react-redux&#39;
// 引入action函数
import {increment, decrement, incrementAsync} from &#39;../redux/actions&#39;
import Counter from &#39;../components/counter&#39;

// 向外暴露连接App组件的包装组件
export default connect(
  state =&gt; ({count: state.counter}),
  {increment, decrement, incrementAsync}
)(Counter)
</code></pre>
<p><code>redux/action-types.js</code></p>
<pre><code class="javascript">export const INCREMENT = &#39;increment&#39;
export const DECREMENT = &#39;decrement&#39;</code></pre>
<h2 id="8-7-使用上redux调试工具"><a href="#8-7-使用上redux调试工具" class="headerlink" title="8.7 使用上redux调试工具"></a>8.7 使用上redux调试工具</h2><h3 id="8-7-1-安装chrome浏览器插件"><a href="#8-7-1-安装chrome浏览器插件" class="headerlink" title="8.7.1 安装chrome浏览器插件"></a>8.7.1 安装chrome浏览器插件</h3><p><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Redux DevTools</a></p>
<h3 id="8-7-2-下载工具依赖包"><a href="#8-7-2-下载工具依赖包" class="headerlink" title="8.7.2 下载工具依赖包"></a>8.7.2 下载工具依赖包</h3><pre><code>npm install --save-dev redux-devtools-extension</code></pre><h3 id="8-7-3-编码"><a href="#8-7-3-编码" class="headerlink" title="8.7.3 编码"></a>8.7.3 编码</h3><pre><code class="javascript">import { composeWithDevTools } from &#39;redux-devtools-extension&#39;
const store = createStore(  counter,  composeWithDevTools(applyMiddleware(thunk))
)</code></pre>
<h2 id="8-8-Redux版评论"><a href="#8-8-Redux版评论" class="headerlink" title="8.8 Redux版评论"></a>8.8 Redux版评论</h2><h3 id="8-8-1-需求"><a href="#8-8-1-需求" class="headerlink" title="8.8.1 需求"></a>8.8.1 需求</h3><p>使用react_redux和中间件实现异步评论功能</p>
<h3 id="8-8-2-安装"><a href="#8-8-2-安装" class="headerlink" title="8.8.2 安装"></a>8.8.2 安装</h3><pre><code class="bash">……
npm install --save react-redux
npm install --save redux-thunk
npm install --save-dev redux-devtools-extension</code></pre>
<h3 id="8-8-3-目录结构"><a href="#8-8-3-目录结构" class="headerlink" title="8.8.3 目录结构"></a>8.8.3 目录结构</h3><blockquote>
<ul>
<li>REACT_REDUX<ul>
<li>public<ul>
<li>css<ul>
<li>bootstrap.css</li>
</ul>
</li>
<li>index.html</li>
</ul>
</li>
<li>src<ul>
<li>components<ul>
<li>app<ul>
<li>app.jsx</li>
</ul>
</li>
<li>comment-add<ul>
<li>comment-add.jsx</li>
</ul>
</li>
<li>comment-item<ul>
<li>comment-item.jsx</li>
<li>comment-item.css</li>
</ul>
</li>
<li>comment-list<ul>
<li>comment-list.jsx</li>
<li>comment-list.css</li>
</ul>
</li>
</ul>
</li>
<li>redux<ul>
<li>action-types.js</li>
<li>actions.js</li>
<li>reducers.js</li>
<li>store.js</li>
</ul>
</li>
<li>index.js</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8-8-4-文件内容"><a href="#8-8-4-文件内容" class="headerlink" title="8.8.4 文件内容"></a>8.8.4 文件内容</h3><ul>
<li><code>public/index.html</code></li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;
    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt;
    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot;&gt;
    &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt;
    &lt;title&gt;React App&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<ul>
<li><code>src/index.js</code></li>
</ul>
<pre><code class="javascript">import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import {Provider} from &#39;react-redux&#39;

import App from &#39;./components/app/app&#39;
import store from &#39;./redux/store&#39;

// 定义渲染根组件标签的函数
ReactDOM.render(
  (
    &lt;Provider store={store}&gt;
      &lt;App/&gt;
    &lt;/Provider&gt;
  ),
  document.getElementById(&#39;root&#39;)
)
</code></pre>
<ul>
<li><code>src/componets/app/app.jsx</code></li>
</ul>
<pre><code class="jsx">import React from &#39;react&#39;
import {connect} from &#39;react-redux&#39;
import CommentAdd from &#39;../comment-add/comment-add&#39;
import CommentList from &#39;../comment-list/comment-list&#39;
import {getComments} from &#39;../../redux/actions&#39;

class App extends React.Component {

  componentDidMount() {
    //模拟异步获取数据
    this.props.getComments()
  }

  render() {
    return (
      &lt;div&gt;
        &lt;header className=&quot;site-header jumbotron&quot;&gt;
          &lt;div className=&quot;container&quot;&gt;
            &lt;div className=&quot;row&quot;&gt;
              &lt;div className=&quot;col-xs-12&quot;&gt;
                &lt;h1&gt;请发表对React的评论&lt;/h1&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/header&gt;
        &lt;div className=&quot;container&quot;&gt;
          &lt;CommentAdd/&gt;
          &lt;CommentList/&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

export default connect(
  null,
  {getComments}
)(App)</code></pre>
<ul>
<li><code>src/componets/comment-add/comment-add.jsx</code><pre><code class="jsx">import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import {connect} from &#39;react-redux&#39;
import {addComment} from &#39;../../redux/actions&#39;
class CommentAdd extends React.Component {
constructor (props) {
  super(props)
  this.state = {
    username: &#39;&#39;,
    content: &#39;&#39;
  }
  this.addComment = this.addComment.bind(this)
  this.changeUsername = this.changeUsername.bind(this)
  this.changeContent = this.changeContent.bind(this)
}
addComment () {
  // 根据输入的数据创建评论对象
  let { username, content } = this.state
  let comment = { username, content }
  // 添加到comments中, 更新state
  this.props.addComment(comment)
  // 清除输入的数据
  this.setState({
    username: &#39;&#39;,
    content: &#39;&#39;
  })
}
changeUsername (event) {
  this.setState({
    username: event.target.value
  })
}
changeContent (event) {
  this.setState({
    content: event.target.value
  })
}
render () {
  return (
    &lt;div className=&quot;col-md-4&quot;&gt;
      &lt;form className=&quot;form-horizontal&quot;&gt;
        &lt;div className=&quot;form-group&quot;&gt;
          &lt;label&gt;用户名&lt;/label&gt;
          &lt;input type=&quot;text&quot; className=&quot;form-control&quot; placeholder=&quot;用户名&quot;
                 value={this.state.username} onChange={this.changeUsername}/&gt;
        &lt;/div&gt;
        &lt;div className=&quot;form-group&quot;&gt;
          &lt;label&gt;评论内容&lt;/label&gt;
          &lt;textarea className=&quot;form-control&quot; rows=&quot;6&quot; placeholder=&quot;评论内容&quot;
                    value={this.state.content} onChange={this.changeContent}&gt;&lt;/textarea&gt;
        &lt;/div&gt;
        &lt;div className=&quot;form-group&quot;&gt;
          &lt;div className=&quot;col-sm-offset-2 col-sm-10&quot;&gt;
            &lt;button type=&quot;button&quot; className=&quot;btn btn-default pull-right&quot; onClick={this.addComment}&gt;提交&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  )
}
}
CommentAdd.propTypes = {
addComment: PropTypes.func.isRequired
}
export default connect(
null,
{addComment}
)(CommentAdd)</code></pre>
</li>
</ul>
<ul>
<li><code>src/componets/comment-item/comment-item.jsx</code><pre><code class="jsx">import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import {connect} from &#39;react-redux&#39;
import &#39;./commentItem.css&#39;
import {deleteComment} from &#39;../../redux/actions&#39;
class CommentItem extends React.Component {
constructor(props) {
  super(props)
}
deleteComment = () =&gt; {
  let username = this.props.comment.username
  if (window.confirm(`确定删除${username}的评论吗?`)) {
    this.props.deleteComment(this.props.index)
  }
}
render() {
  let comment = this.props.comment
  return (
    &lt;li className=&quot;list-group-item&quot;&gt;
      &lt;div className=&quot;handle&quot;&gt;
        &lt;a href=&quot;javascript:&quot; onClick={this.deleteComment}&gt;删除&lt;/a&gt;
      &lt;/div&gt;
      &lt;p className=&quot;user&quot;&gt;&lt;span&gt;{comment.username}&lt;/span&gt;&lt;span&gt;说:&lt;/span&gt;&lt;/p&gt;
      &lt;p className=&quot;centence&quot;&gt;{comment.content}&lt;/p&gt;
    &lt;/li&gt;
  )
}
}
CommentItem.propTypes = {
comment: PropTypes.object.isRequired,
index: PropTypes.number.isRequired,
deleteComment: PropTypes.func.isRequired
}
export default connect(
null,
{deleteComment}
)(CommentItem)
</code></pre>
</li>
</ul>
<pre><code>






- `src/componets/comment-item/comment-item.css`
```css
li {
  transition: .5s;
  overflow: hidden;
}
.handle {
  width: 40px;
  border: 1px solid #ccc;
  background: #fff;
  position: absolute;
  right: 10px;
  top: 1px;
  text-align: center;
}
.handle a {
  display: block;
  text-decoration: none;
}
.list-group-item .centence {
  padding: 0px 50px;
}
.user {
  font-size: 22px;
}</code></pre><ul>
<li><code>src/componets/comment-list/comment-list.jsx</code><pre><code class="jsx">import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import {connect} from &#39;react-redux&#39;
import CommentItem from &#39;../comment-item/comment-item&#39;
import &#39;./commentList.css&#39;
class CommentList extends React.Component {
render () {
  let comments = this.props.comments
  let display = comments.length &gt; 0 ? &#39;none&#39; : &#39;block&#39;
  return (
    &lt;div className=&quot;col-md-8&quot;&gt;
      &lt;h3 className=&quot;reply&quot;&gt;评论回复：&lt;/h3&gt;
      &lt;h2 style=双大括号 display: display 双大括号&gt;暂无评论，点击左侧添加评论！！！&lt;/h2&gt;
      &lt;ul className=&quot;list-group&quot;&gt;
        {
          comments.map((comment, index) =&gt; {
            console.log(comment)
            return &lt;CommentItem comment={comment} key={index} index={index}/&gt;
          })
        }
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
}
CommentList.propTypes = {
comments: PropTypes.array.isRequired,
}
export default connect(
state =&gt; ({comments: state.comments})
)(CommentList)</code></pre>
</li>
</ul>
<ul>
<li><code>src/componets/comment-list/comment-list.css</code><pre><code class="css">.reply {
margin-top: 0px;
}</code></pre>
</li>
</ul>
<ul>
<li><code>redux/action-types.js</code><pre><code class="javascript">export const ADD_COMMENT = &#39;ADD_COMMENT&#39;
export const DELETE_COMMENT = &#39;DELETE_COMMENT&#39;
export const RECEIVE_COMMENTS = &#39;RECEIVE_COMMENTS&#39;</code></pre>
</li>
</ul>
<ul>
<li><code>redux/actions.js</code><pre><code class="javascript">import {
ADD_COMMENT,
DELETE_COMMENT,
RECEIVE_COMMENTS
} from &#39;./action-types&#39;
export const addComment = (comment) =&gt; ({type: ADD_COMMENT, data: comment})
export const deleteComment = (index) =&gt; ({type: DELETE_COMMENT, data: index})
const receiveComments = (comments) =&gt; ({type: RECEIVE_COMMENTS, data: comments})
export const getComments = () =&gt; {
return dispatch =&gt; {
  setTimeout(() =&gt; {
    const comments = [
      {
        username: &quot;Tom&quot;,
        content: &quot;ReactJS好难啊!&quot;,
        id: Date.now()
      },
      {
        username: &quot;JACK&quot;,
        content: &quot;ReactJS还不错!&quot;,
        id: Date.now() + 1
      }
    ]
    dispatch(receiveComments(comments))
  }, 1000)
}
}</code></pre>
</li>
</ul>
<ul>
<li><code>redux/reducers.js</code></li>
</ul>
<pre><code class="javascript">import {combineReducers} from &#39;redux&#39;
import {
  ADD_COMMENT,
  DELETE_COMMENT,
  RECEIVE_COMMENTS
} from &#39;./action-types&#39;
const initComments = []
function comments(state = initComments, action) {
  switch (action.type) {
    case ADD_COMMENT:
      return [...state, action.data]
    case DELETE_COMMENT:
      return state.filter((c, index) =&gt; index !== action.data)
    case RECEIVE_COMMENTS:
      return action.data
    default:
      return state
  }
}
export default combineReducers({
  comments
})</code></pre>
<ul>
<li><code>redux/store.js</code></li>
</ul>
<pre><code class="javascript">import React from &#39;react&#39;
import {createStore, applyMiddleware} from &#39;redux&#39;
import thunk from &#39;redux-thunk&#39;
import {composeWithDevTools} from &#39;redux-devtools-extension&#39;
import reducers from &#39;./reducers&#39;
// 根据counter函数创建store对象
export default createStore(
  reducers,
  composeWithDevTools(applyMiddleware(thunk)) // 应用上异步中间件
)</code></pre>
<h2 id="8-9-相关重要知识-纯函数和高阶函数"><a href="#8-9-相关重要知识-纯函数和高阶函数" class="headerlink" title="8.9 相关重要知识: 纯函数和高阶函数"></a>8.9 相关重要知识: 纯函数和高阶函数</h2><h3 id="8-9-1-纯函数"><a href="#8-9-1-纯函数" class="headerlink" title="8.9.1 纯函数"></a>8.9.1 纯函数</h3><p>1)     一类特别的函数: 只要是同样的输入，必定得到同样的输出</p>
<p>2)    必须遵守以下一些约束 </p>
<p>a.    不得改写参数</p>
<p>b.    不能调用系统 I/O 的API</p>
<p>c.    能调用Date.now()或者Math.random()等不纯的方法 </p>
<p>3)     reducer函数必须是一个纯函数</p>
<h3 id="8-9-2-高阶函数"><a href="#8-9-2-高阶函数" class="headerlink" title="8.9.2 高阶函数"></a>8.9.2 高阶函数</h3><p>4)     理解: 一类特别的函数</p>
<p>a.     情况1: 参数是函数</p>
<p>b.     情况2: 返回是函数</p>
<p>5)         常见的高阶函数: </p>
<p>a.     定时器设置函数</p>
<p>b.     数组的map()/filter()/reduce()/find()/bind()</p>
<p>c.     react-redux中的connect函数</p>
<p>6)         作用: </p>
<p>​     能实现更加动态, 更加可扩展的功能</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/04/Git/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="Git学习笔记" class="lazyload">
                    <h1>Git学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月04日</a>
            <a><i class="nexmoefont icon-areachart"></i>2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 8 分钟</a>
        </div>

        <article>
            
                <h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="集中式-svn"><a href="#集中式-svn" class="headerlink" title="集中式(svn)"></a>集中式(svn)</h3><p>svn因为每次存的都是差异 需要的硬盘空间会相对的小一点  可是回滚的速度会很慢</p>
<ul>
<li>优点: <pre><code>代码存放在单一的服务器上 便于项目的管理</code></pre></li>
<li>缺点: <pre><code>服务器宕机: 员工写的代码得不到保障
服务器炸了: 整个项目的历史记录都会丢失</code></pre></li>
</ul>
<h3 id="分布式-git"><a href="#分布式-git" class="headerlink" title="分布式(git)"></a>分布式(git)</h3><p>git每次存的都是项目的完整快照 需要的硬盘空间会相对大一点<br>    (Git团队对代码做了极致的压缩 最终需要的实际空间比svn多不了太多 可是Git的回滚速度极快)</p>
<ul>
<li>优点:<pre><code>完全的分布式</code></pre></li>
<li>缺点:    <pre><code>学习起来比SVN陡峭</code></pre></li>
</ul>
<h2 id="Git底层命令"><a href="#Git底层命令" class="headerlink" title="Git底层命令"></a>Git底层命令</h2><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/git.webp" alt="git" class="lazyload"></p>
<h3 id="底层命令"><a href="#底层命令" class="headerlink" title="底层命令"></a>底层命令</h3><pre><code>git对象
    git hash-object -w fileUrl : 生成一个key(hash值):val(压缩后的文件内容)键值对存到.git/objects
tree对象
    git update-index --add --cacheinfo 100644 hash test.txt : 往暂存区添加一条记录(让git对象 对应 上文件名)存到.git/index
    git write-tree : 生成树对象存到.git/objects
commit对象
    echo &#39;first commit&#39; | git commit-tree treehash : 生成一个提交对象存到.git/objects
对以上对象的查询
    git cat-file -p hash       : 拿对应对象的内容
    git cat-file -t hash       : 拿对应对象的类型</code></pre><h3 id="查看暂存区"><a href="#查看暂存区" class="headerlink" title="查看暂存区"></a>查看暂存区</h3><pre><code>git ls-files -s        </code></pre><p>​    </p>
<h2 id="Git高层命令"><a href="#Git高层命令" class="headerlink" title="Git高层命令"></a>Git高层命令</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>git --version</code></pre><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><pre><code>git config --global user.name &quot;damu&quot;
git config --global user.email damu@example.com    
git config --list</code></pre><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><pre><code>git init</code></pre><h3 id="C-新增"><a href="#C-新增" class="headerlink" title="C(新增)"></a>C(新增)</h3><pre><code>在工作目录中新增文件
git status
git add ./
git commit -m &quot;msg&quot;    </code></pre><h3 id="U-修改"><a href="#U-修改" class="headerlink" title="U(修改)"></a>U(修改)</h3><pre><code>在工作目录中修改文件
git status
git add ./
git commit -m &quot;msg&quot;     </code></pre><h3 id="D-删除-amp-重命名"><a href="#D-删除-amp-重命名" class="headerlink" title="D(删除 &amp; 重命名)"></a>D(删除 &amp; 重命名)</h3><p>   git rm 要删除的文件     git mv 老文件 新文件<br>   git  status             git  status<br>   git commit -m “msg”     git commit -m “msg”</p>
<h3 id="R-查询"><a href="#R-查询" class="headerlink" title="R(查询)"></a>R(查询)</h3><p>   git  status   :  查看工作目录中文件的状态(已跟踪(已提交 已暂存 已修改) 未跟踪)<br>   git  diff     :  查看未暂存的修改<br>   git  diff –cache : 查看未提交的暂存<br>   git  log –oneline : 查看提交记录</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code>分支的本质其实就是一个提交对象!!!
HEAD: 
    是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支
    每次有新的提交时 HEAD都会带着当前指向的分支 一起往前移动
git  log --oneline --decorate --graph --all : 查看整个项目的分支图  
git branch : 查看分支列表
git branch -v: 查看分支指向的最新的提交
git branch name : 在当前提交对象上创建新的分支
git branch name commithash: 在指定的提交对象上创建新的分支
git checkout name :     切换分支
git branch -d name : 删除空的分支 删除已经被合并的分支
git branch -D name : 强制删除分支 </code></pre><p>​       </p>
<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><h3 id="git分支本质"><a href="#git分支本质" class="headerlink" title="git分支本质"></a>git分支本质</h3><pre><code>分支本质是一个提交对象,所有的分支都会有机会被HEAD所引用(HEAD一个时刻只会指向一个分支)
当我们有新的提交的时候 HEAD会携带当前持有的分支往前移动</code></pre><h3 id="git分支命令"><a href="#git分支命令" class="headerlink" title="git分支命令"></a>git分支命令</h3><pre><code>创建分支            : git branch branchname
切换分支           : git checkout  branchname
创建&amp;切换分支     : git checkout -b branchname
版本穿梭(时光机) :  git branch branchname commitHash  
普通删除分支      : git  branch -d branchname
强制删除分支      : git  branch -D branchname
合并分支         : git merge branchname
    快进合并 --&gt; 不会产生冲突
    典型合并 --&gt; 有机会产生冲突
    解决冲突 --&gt; 打开冲突的文件 进行修改 add commit </code></pre><p>​    </p>
<pre><code>查看分支列表 : git branch
查看合并到当前分支的分支列表: git branch --merged
    一旦出现在这个列表中 就应该删除
查看没有合并到当前分支的分支列表: git branch --no-merged
    一旦出现在这个列表中 就应该观察一下是否需要合并</code></pre><h3 id="git分支的注意点"><a href="#git分支的注意点" class="headerlink" title="git分支的注意点"></a>git分支的注意点</h3><pre><code>在切换的时候 一定要保证当前分支是干净的!!!
    允许切换分支: 
        分支上所有的内容处于 已提交状态    
        (避免)分支上的内容是初始化创建 处于未跟踪状态
        (避免)分支上的内容是初始化创建 第一次处于已暂存状态
    不允许切分支:
         分支上所有的内容处于 已修改状态  或 第二次以后的已暂存状态  

在分支上的工作做到一半时 如果有切换分支的需求, 我们应该将现有的工作存储起来
    git stash : 会将当前分支上的工作推到一个栈中
    分支切换  进行其他工作 完成其他工作后 切回原分支
    git stash apply : 将栈顶的工作内容还原 但不让任何内容出栈 
    git stash drop  : 取出栈顶的工作内容后 就应该将其删除(出栈)
    git stash pop   :      git stash apply +  git stash drop 
    git stash list : 查看存储</code></pre><h3 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h3><pre><code>撤销工作目录的修改   :  git checkout -- filename
撤销暂存区的修改     :  git reset HEAD  filename
撤销提交             :  git commit --amend</code></pre><h3 id="reset三部曲"><a href="#reset三部曲" class="headerlink" title="reset三部曲"></a>reset三部曲</h3><pre><code>git reset --soft commithash    ---&gt; 用commithash的内容重置HEAD内容
git reset [--mixed] commithash ---&gt; 用commithash的内容重置HEAD内容 重置暂存区
git reset --hard commithash    ---&gt; 用commithash的内容重置HEAD内容 重置暂存区 重置工作目录</code></pre><h3 id="路径reset"><a href="#路径reset" class="headerlink" title="路径reset"></a>路径reset</h3><pre><code>所有的路径reset都要省略第一步!!!
    第一步是重置HEAD内容  我们知道HEAD本质指向一个分支 分支的本质是一个提交对象 
    提交对象 指向一个树对象 树对象又很有可能指向多个git对象 一个git对象代表一个文件!!!
    HEAD可以代表一系列文件的状态!!!!
git reset [--mixed] commithash filename  
     用commithash中filename的内容重置暂存区</code></pre><h3 id="checkout深入理解"><a href="#checkout深入理解" class="headerlink" title="checkout深入理解"></a>checkout深入理解</h3><pre><code>git   checkout brancname  跟   git reset --hard commithash特别像
    共同点
        都需要重置 HEAD   暂存区   工作目录
    区别
         checkout对工作目录是安全的    reset --hard是强制覆盖
         checkout动HEAD时不会带着分支走而是切换分支
         reset --hard时是带着分支走

checkout + 路径
      git checkout commithash  filename   
           重置暂存区
           重置工作目录
      git checkout -- filename  
          重置工作目录  </code></pre><h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><h3 id="eslint-1"><a href="#eslint-1" class="headerlink" title="eslint"></a>eslint</h3><pre><code>js代码的检查工具
下载: npm i eslint -D
使用:
    生成配置文件 npx eslint --init
    检查js文件   npx eslint 目录名
    命中的规则:
        字符串必须使用单引号
        语句结尾不能有分号
        文件的最后必须要有换行</code></pre><h3 id="eslint结合git"><a href="#eslint结合git" class="headerlink" title="eslint结合git"></a>eslint结合git</h3><pre><code>husky: 哈士奇, 为Git仓库设置钩子程序
使用
    在仓库初始化完毕之后 再去安装哈士奇
    在package.json文件写配置
        &quot;husky&quot;: {
            &quot;hooks&quot;: {
              &quot;pre-commit&quot;: &quot;npm run lint&quot;   
              //在git commit之前一定要通过npm run lint的检查
              // 只有npm run lint不报错时 commit才能真正的运行
            }
          }           </code></pre><h2 id="远程协作"><a href="#远程协作" class="headerlink" title="远程协作"></a>远程协作</h2><h3 id="三个必须懂得概念"><a href="#三个必须懂得概念" class="headerlink" title="三个必须懂得概念"></a>三个必须懂得概念</h3><pre><code>本地分支
远程跟踪分支(remote/分支名)
远程分支</code></pre><h3 id="远程协作的基本流程"><a href="#远程协作的基本流程" class="headerlink" title="远程协作的基本流程"></a>远程协作的基本流程</h3><pre><code>第一步: 项目经理创建一个空的远程仓库
第二步: 项目经理创建一个待推送的本地仓库
第三步: 为远程仓库配别名  配完用户名 邮箱
第四步: 在本地仓库中初始化代码 提交代码
第五步: 推送
第六步: 邀请成员
第七步: 成员克隆远程仓库
第八步: 成员做出修改
第九步: 成员推送自己的修改
第十步: 项目经理拉取成员的修改</code></pre><h3 id="做跟踪"><a href="#做跟踪" class="headerlink" title="做跟踪"></a>做跟踪</h3><pre><code>克隆才仓库时 会自动为master做跟踪
本地没有分支
    git checkout --track 远程跟踪分支(remote/分支名)
本地已经创建了分支
    git branch -u 远程跟踪分支(remote/分支名)</code></pre><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><pre><code>git push</code></pre><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><pre><code>git pull</code></pre><h3 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h3><pre><code>让第三方人员参与到项目中 fork</code></pre><h3 id="使用频率最高的五个命令"><a href="#使用频率最高的五个命令" class="headerlink" title="使用频率最高的五个命令"></a>使用频率最高的五个命令</h3><pre><code>git status
git add
git commit
git push
git pull</code></pre><p>​    </p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/14/nodejs/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="NodeJs学习笔记" class="lazyload">
                    <h1>NodeJs学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月14日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.6k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 20 分钟</a>
        </div>

        <article>
            
                <h2 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h2><h3 id="1、命令行窗口"><a href="#1、命令行窗口" class="headerlink" title="1、命令行窗口"></a>1、命令行窗口</h3><ul>
<li><p>又称cmd窗口、终端、shell</p>
</li>
<li><p>打开方式：</p>
<ul>
<li><p>win：<kbd>win</kbd>+<kbd>R</kbd>，输入<code>cmd</code>，打开</p>
</li>
<li><p>mac\linux: <code>terminal</code></p>
</li>
</ul>
</li>
<li><p>前面显示的为目前所在的目录</p>
</li>
<li><p>常用的命令</p>
<ul>
<li>dir 列出当前目录下所有文件</li>
<li>cd  目录名 进入到指定的目录</li>
<li>目录<ul>
<li>. 表示当前目录</li>
<li>.. 表示上一级目录</li>
</ul>
</li>
<li>md 目录名 创建一个文件夹</li>
<li>rd 目录名 删除一个文件夹</li>
<li>输入当前目录下的一个文件名(包括后缀)可以打开这个文件</li>
</ul>
</li>
<li><p>环境变量(Windows系统中的变量)</p>
<ul>
<li>path  </li>
<li>当我们在命令行窗口打开一个文件，或调用一个程序时，系统会首先在当前目录下寻找文件程序，如果找到了则直接打开，如果没有找到则会依次到环境变量path的路径中寻找，知道找到为止，如果没找到则报错</li>
<li>所以我们可以将一些经常需要访问的程序和文件的路径添加到paht中，这样我们就可以在任意位置来访问这些文件和程序了</li>
</ul>
</li>
</ul>
<h3 id="2、进程和线程"><a href="#2、进程和线程" class="headerlink" title="2、进程和线程"></a>2、进程和线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li>进程负责为程序的运行提供必备的环境</li>
<li>进程就相当于工厂中的车间</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>线程是计算机中的最小的计算单位，线程负责执行进程中的程序</li>
<li>线程就相当于工厂中的工人</li>
<li><ul>
<li>单线程<ul>
<li>js是单线程</li>
</ul>
</li>
<li>多线程</li>
</ul>
</li>
</ul>
<h2 id="二、Node-js简介"><a href="#二、Node-js简介" class="headerlink" title="二、Node.js简介"></a>二、Node.js简介</h2><ul>
<li>nodejs是一个能够在服务器端运行js的开放源代码、跨平台的js运行环境</li>
<li>node采用google开发的v8引擎运行js代码，使用</li>
</ul>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1588819260571.png" alt="1588819260571" class="lazyload"></p>
<h2 id="三、node使用"><a href="#三、node使用" class="headerlink" title="三、node使用"></a>三、node使用</h2><pre><code class="shell">node
&gt; var i = 0
&gt; console.log(i)</code></pre>
<pre><code class="shell">node hello.js</code></pre>
<h2 id="四、COMMONJS规范"><a href="#四、COMMONJS规范" class="headerlink" title="四、COMMONJS规范"></a>四、COMMONJS规范</h2><h3 id="1、ECMAScript标准的缺陷"><a href="#1、ECMAScript标准的缺陷" class="headerlink" title="1、ECMAScript标准的缺陷"></a>1、ECMAScript标准的缺陷</h3><ul>
<li>没有模块系统</li>
<li>标准库较少</li>
<li>没有标准接口</li>
<li>缺乏管理系统</li>
</ul>
<h3 id="2、模块化-module-js"><a href="#2、模块化-module-js" class="headerlink" title="2、模块化 module.js"></a>2、模块化 module.js</h3><ul>
<li><p>在node中，一个js就是一个模块</p>
</li>
<li><p>在Node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问</p>
</li>
<li><p>我们可以通过exports来向外部暴露变量和方法，只需要将要暴露给外部的变量或方法设置为exports的属性即可</p>
<pre><code class="javascript">exports.x=&quot;我是modeule.js中的x&quot;
exports.fn = function(){}</code></pre>
</li>
<li><p>在Node中有一个全局对象global，它的作用和网页中window类似，在全局中创建的变量都会作为global的属性保存，在全局中创建的函数都会作为global的方法保存</p>
<pre><code class="javascript">var a = 10;
console.log(global.a);</code></pre>
</li>
<li><p>arguments</p>
<ul>
<li>arguments.callee 这个属性保存的是当前执行的函数对象</li>
</ul>
</li>
<li><p>在node执行模块中的代码时，它首先会在代码的最顶部添加代码<code>function(exports, require, module, __filename, __dirname){</code>，在代码的最底部，添加代码<code>}</code>.实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参(<code>arguments.length</code>)。</p>
<ul>
<li><p>exports 该对象用来将变量或函数暴露到外部</p>
</li>
<li><p>require 函数，用来引入外部的模块</p>
</li>
<li><p>module </p>
<ul>
<li><p>module代表的是当前模块本身</p>
</li>
<li><p>exports就是module的属性</p>
</li>
<li><p>既可以使用exports导出，也可以使用modeule.exports导出 <code>module.exports==exports</code>，<code>module.exports.a  exports.a</code></p>
</li>
<li><p>通过exports只能使用.的方式来向外暴露内部变量，而modele.exports既可以通过.的形式，也可以直接复制</p>
<pre><code class="javascript">exports.xxx = xxx
module.exports.xxx = xxx
module.exports = {
    name = &quot;swk&quot;
    age = 15000
    sayName = function{
        console.log(name)
    }
}</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>__filename 当前模块的完整路径</p>
</li>
<li><p>__dirname 当前模块所在文件夹的完整路径</p>
</li>
</ul>
<ul>
<li>在node中通过require()函数来引入外部的模块，require()可以传递一个文件的路径作为参数，node将会自动根据该路径来引入外部模块，这里的路径如果使用相对路径，必须以.或..开头。使用require引入模块后，该函数会返回一个对象，这个对象代表的是引入的模块</li>
</ul>
<pre><code class="javascript">var md = require(&quot;./modele.js&quot;);
console.log(md)</code></pre>
<ul>
<li><p>模块分为两大类</p>
<ul>
<li><p>核心模块</p>
<ul>
<li>由node引擎提供的模块</li>
</ul>
</li>
<li><p>文件模块</p>
<ul>
<li>由用户自己创建的模块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、CommonJS规范"><a href="#3、CommonJS规范" class="headerlink" title="3、CommonJS规范"></a>3、CommonJS规范</h3><ul>
<li>CommonJS规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷。</li>
<li>CommonJS规范为js制定了一个美好的愿景，希望js能够在任何地方运行。</li>
<li>CommonJS规范对模块的定义十分简单<ul>
<li>模块引用</li>
<li>模块定义</li>
<li>模块标识<ul>
<li>我们使用require()引入外部模块时，使用的就是模块标识，我们可以通过模块标识来找到指定的模块</li>
<li>核心模块的标识就是模块的名字</li>
<li>文件模块的标识就是文件的路径(绝对、相对)，相对路径使用.或..开头</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="五、包-Package"><a href="#五、包-Package" class="headerlink" title="五、包 Package"></a>五、包 Package</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li>CommonJS的包规范允许我们将一组相关的<strong>模块组合到一起</strong>，形成一组完整的工具。</li>
<li>CommonJS的包规范由包结构和包描述文件两个部分组成</li>
<li>包结构：用于组织包中的各种文件</li>
<li>包描述文件：描述包的相关信息，以供外部读取分析</li>
</ul>
<h3 id="2、包结构"><a href="#2、包结构" class="headerlink" title="2、包结构"></a>2、包结构</h3><p>包实际上就是一个压缩文件，解压以后还原为目录。</p>
<p>符合规范的目录，应该包含如下文件：</p>
<ul>
<li><p><strong>package.json 描述文件</strong></p>
<pre><code class="json">{
    &quot;dependecies&quot;: {}, // 依赖
    &quot;description&quot;: &quot;描述&quot;,
    &quot;devDependencies&quot;: { // 开发依赖
        ...
    }
    ...
    &quot;version&quot;: &quot;v1.0.0&quot;
}</code></pre>
</li>
</ul>
<ul>
<li><p>bin 可执行二进制文件</p>
</li>
<li><p>lib js代码</p>
</li>
<li><p>doc 文档</p>
</li>
<li><p>test 单元测试</p>
</li>
</ul>
<h3 id="3、包描述文件"><a href="#3、包描述文件" class="headerlink" title="3、包描述文件"></a>3、包描述文件</h3><p>包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于包的根目录下，是包的重要组成部分</p>
<p>package.json中的字段(不能写注释)</p>
<ul>
<li><code>name</code></li>
<li><code>description</code></li>
<li><code>version</code></li>
<li><code>keywords</code></li>
<li><code>maintainers</code></li>
<li><code>contributors</code></li>
<li><code>bugs</code></li>
<li><code>licenses</code></li>
<li><code>repositories</code></li>
<li><code>dependencies</code></li>
<li><code>homepage</code></li>
<li><code>os</code></li>
<li><code>cpu</code></li>
<li><code>engine</code></li>
<li><code>builtin</code></li>
<li><code>directories</code></li>
<li><code>implements</code></li>
<li><code>scripts</code></li>
<li><code>author</code></li>
<li><code>bin</code></li>
<li><code>main</code></li>
<li><code>devDependencies</code></li>
</ul>
<ol>
<li>标识</li>
<li>依赖</li>
<li>运行/打包</li>
</ol>
<p>通过<code>npm run</code></p>
<h2 id="六、NPM-Node-Package-Manager"><a href="#六、NPM-Node-Package-Manager" class="headerlink" title="六、NPM(Node Package Manager)"></a>六、NPM(Node Package Manager)</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li><p>CommonJS包规范是理论，NPM是其中一种实践</p>
</li>
<li><p>对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。</p>
</li>
</ul>
<h3 id="2、NPM命令"><a href="#2、NPM命令" class="headerlink" title="2、NPM命令"></a>2、NPM命令</h3><ul>
<li><code>npm -v</code> 查看npm版本</li>
<li><code>npm version</code> 查看所有模块版本</li>
<li><code>npm</code> 帮助说明</li>
<li><code>npm init</code> 在当前目录下创建package.json文件，驼峰命名改为_连接</li>
<li><code>npm search 包名</code>   搜索包</li>
<li><code>npm install/i 包名</code>  安装包，将会在当前目录的<code>node_modules</code>下，直接通过包名引入即可，<code>var math = require(&quot;math&quot;)</code></li>
<li><code>npm install 包名 -g</code>  全局安装包，一般都是一些工具</li>
<li><code>npm remove/r 包名</code>  删除一个模块</li>
<li><code>npm install 包名 --save</code>  <strong>安装包并将其添加到依赖中</strong>，一般不传node_modules，太大、不能保证是最新的，有了依赖，传package.json直接<code>npm install</code>可以下载当前项目所依赖的包</li>
<li><code>npm uninstall 包名</code>  卸载包</li>
<li><code>npm install 文件路径</code>  从本地安装</li>
<li><code>npm install 包名 -registry=地址</code>  从镜像源安装包</li>
<li><code>npm config set registry 地址</code>  设置镜像源</li>
</ul>
<p>淘宝镜像：<a href="https://npm.taobao.org" target="_blank" rel="noopener">https://npm.taobao.org</a></p>
<p>一般不直接设置官方原版npm替换为其他源，可以使用cnpm</p>
<ul>
<li><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  </li>
</ul>
<p>注：</p>
<ul>
<li>Node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否含有该模块，如果有则直接使用，如果没有则去上一级目录的node_modules中寻找，如果有则直接使用，如果没有则再去上一级目录寻找，知道找到为止，如果找到磁盘根目录仍没有，则报错。</li>
</ul>
<h2 id="七、Buffer-缓冲区"><a href="#七、Buffer-缓冲区" class="headerlink" title="七、Buffer(缓冲区)"></a>七、Buffer(缓冲区)</h2><ul>
<li><p>Buffer的就结构和数组很像，操作的方法也和数组类似</p>
</li>
<li><p>数组中不能存储二进制的文件，而buffer就是专门用来存储<strong>二进制</strong>数据的</p>
</li>
<li><p>使用buffer不需要引入模块，直接使用即可</p>
<pre><code class="javascript">var str = &quot;hello&quot;
// 将一个字符串保存到buffer中
var buf = Buffer.from(str)
console.log(buf)
console.log(buf.length,str.length)  // 占用内存的大小,字符串的长度</code></pre>
</li>
<li><p>在buffer中存储的都是二进制数据，但是在显示的时候都是以16进制的形式显示的，buffer中每一个元素的范围是从00到ff(0<del>255) 00000000</del>11111111 8位(bit) = 1字节(byte)，buffer中的一个元素占用内存的一个字节     ps：一个汉字3字节，一个英文字母1字节</p>
</li>
<li><p>buffer的大小一旦确定，则不能修改，Buffer实际上是对底层内存的直接操作</p>
<ul>
<li><code>Buffer.from(str)</code>将一个字符串转为buffer</li>
<li><code>Buffer.alloc(size)</code>创建一个指定大小的buffer</li>
<li><code>Buffer.allocUnsafe(size)</code>创建一个指定的大小的buffer，但是可能包含敏感数据</li>
<li><code>buf.toString()</code>将buffer里的数据转为字符串</li>
</ul>
<pre><code class="javascript">// 创建一个指定大小的buffer
var buf = new Buffer(10) // 10个字节的buffer
// buffer构造函数都是不推荐使用的
var buf2 = Buffer.alloc(10)   // 全都是00
buf2[0] = 88
buf2[1] = 255
buf2[2] = 0xaa
buf2[3] = 556
// 1000101100截取后八位
buf2[10] = 15  // 没改变
// 只要数字在控制台或页面中输出一定是10进制
console.log(buf2[2])
console.log(buf2[2].toString(16))  // 可以这样转为16进制显示

var buf3 = Buffer.allocUnsafe(10)  // 创建一个指定大小的buffer，但是buffer中可能含有敏感数据，不全为00</code></pre>
</li>
</ul>
<p><a href="https://nodejs.cn" target="_blank" rel="noopener">https://nodejs.cn</a></p>
<h2 id="八、文件系统-File-System"><a href="#八、文件系统-File-System" class="headerlink" title="八、文件系统(File System)"></a>八、文件系统(File System)</h2><h3 id="1、简介-2"><a href="#1、简介-2" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li><p>文件系统简单来说就是通过Nodejs来操作系统中的文件</p>
</li>
<li><p>在Node中，与文件系统的交互是非常重要的，服务器的本质就是将本地的文件发送给远程的客户端</p>
</li>
<li><p>Node通过fs模块来和文件系统进行交互</p>
</li>
<li><p>fs模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互</p>
</li>
<li><p>要使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载；要使用fs模块，首先需要对其进行加载<code>const fs = require(&quot;fs&quot;)</code></p>
</li>
</ul>
<h3 id="2、同步和异步调用"><a href="#2、同步和异步调用" class="headerlink" title="2、同步和异步调用"></a>2、同步和异步调用</h3><ul>
<li><p>fs模块中所有的操作都有两种形式可供选择，同步(fs.xxx)和异步(fs.xxxSync)</p>
</li>
<li><p>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</p>
</li>
<li><p>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</p>
</li>
</ul>
<h3 id="3、同步、异步文件写入"><a href="#3、同步、异步文件写入" class="headerlink" title="3、同步、异步文件写入"></a>3、同步、异步文件写入</h3><ul>
<li><p>同步文件的写入</p>
<ul>
<li><p>操作步骤</p>
<ol>
<li><p>打开文件</p>
<ul>
<li><p><code>fs.openSync(path, flags[, mode])</code></p>
</li>
<li><p>path 要打开文件的路径</p>
</li>
<li><p>flags 打开文件要做的操作的类型：r只读的、w可写的</p>
</li>
<li><p>mode 设置文件的操作权限，一般不传</p>
</li>
<li><p>返回值： 返回一个文件的描述符，可以通过该描述符来对文件进行各种操作</p>
<pre><code class="javascript">var fs = require(&quot;fs&quot;);
var fd = fs.openSync(&quot;hello.txt&quot;, &quot;w&quot;);
// console.log(fd)</code></pre>
</li>
</ul>
</li>
<li><p>向文件中写入内容</p>
<ul>
<li><p><code>fs.writeSync(fd, string[, position[, encoding]])</code></p>
</li>
<li><p>fd 文件的描述符，需要传递要写入的文件的描述符</p>
</li>
<li><p>string 要写入的内容</p>
</li>
<li><p>position 写入的起始位置</p>
</li>
<li><p>encoding 写入的编码，默认utf-8</p>
<pre><code class="javascript">fs.writeSync(fd, &quot;这是写入的内容&quot;)</code></pre>
</li>
</ul>
</li>
<li><p>保存并关闭文件</p>
<ul>
<li><code>fs.closeSync(fd)</code></li>
<li>fd 要关闭的文件的描述符</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>异步文件写入</p>
<ol>
<li><p><code>fs.open(path, flags[, mode], callback)</code></p>
<ul>
<li><p>用来打开一个文件</p>
</li>
<li><p>异步方法没有返回值，有返回值的都是同步方法。异步调用的方法，结果都是通过回调函数参数返回的。</p>
</li>
<li><p>callback 回调函数两个参数(arguements):</p>
<ul>
<li><p>err 错误对象，如果没有错误则为null</p>
</li>
<li><p>fd 文件的描述符</p>
</li>
</ul>
</li>
</ul>
<pre><code class="javascript">var fs = require(&quot;fs&quot;)
var f
fs.open(&quot;hello.txt&quot;,&quot;w&quot;,function(err, fd){
    // console.log(&#39;回调函数中的代码&#39;)  // callback中的代码会在读取完毕之后执行
    if(!err){
        f = fd
    }else{
        console.log(err)
    }
})
console.log(&quot;open下的代码&quot;)    // 能比上面的更早执行</code></pre>
<pre><code></code></pre></li>
</ol>
</li>
</ul>
<ol start="2">
<li><p><code>fs.write(fd, string[, position[, encoding]], callback)</code></p>
<ul>
<li>用来异步写入一个文件</li>
</ul>
<ol start="3">
<li><p><code>fs.close(fd, callback)</code></p>
<ul>
<li><p>用来关闭文件</p>
<pre><code class="javascript">var fs = require(&quot;fs&quot;)
fs.open(&quot;hello.txt&quot;,&quot;w&quot;,function(err, fd){
   if(!err){
       fs.write(fd, &quot;这是异步写入的内容&quot;,function(err)          {
           if(!err){
               console.log(&#39;写入成功&#39;)
           }
           fs.close(fd, function(err){
               if(!err){
                   console.log(&#39;文件已关闭&#39;)
               }
           })
       })
   }else{
       console.log(err)
   }
})</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="4、简单文件写入"><a href="#4、简单文件写入" class="headerlink" title="4、简单文件写入"></a>4、简单文件写入</h3><ul>
<li><p><code>fs.writeFile(file, data[, options], callback)</code></p>
<ul>
<li><p>file 要操作的文件的路径</p>
</li>
<li><p>data 要写入的数据</p>
</li>
<li><p>options 选项，可以对写入进行一些设置，是一个对象{encoding, mode, flag}</p>
<ul>
<li>encoding: ‘utf8’</li>
<li>mode: ‘0o666’</li>
<li>flag: ‘w’   一般用r(只读)、w(可写)、a(追加)</li>
</ul>
</li>
<li><p>callback 当写入完成以后执行的函数</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;)
// 路径也可以C:/Users/Shinlo/Desktop/hello.txt
fs.writeFile(&quot;C:\\Users\\Shinlon\\Desktop\\hello.txt&quot;, &quot;这是通过writeFile写入的内容&quot;, {flag: &quot;a&quot;}, function(err){
    if(!err){
        console.log(&#39;写入成功&#39;)
    }else{
        console.log(err)
    }
})</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1588844894085.png" alt="1588844894085" class="lazyload"></p>
</li>
</ul>
</li>
<li><p><code>fs.writeFileSync(file, data[, options])</code></p>
<ul>
<li>同步简单写入</li>
</ul>
</li>
</ul>
<h3 id="5、流式文件写入"><a href="#5、流式文件写入" class="headerlink" title="5、流式文件写入"></a>5、流式文件写入</h3><ul>
<li><p>同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</p>
</li>
<li><p>流式文件写入</p>
<ul>
<li><p><code>fs.createWriteStream(path[, options])</code></p>
<ul>
<li>可以用来创建一个可写流</li>
<li>path 文件路径</li>
<li>options 配置的参数</li>
</ul>
<pre><code class="javascript">var fs = require(&quot;fs&quot;)
var ws = fs.createWriteStream(&quot;hello.txt&quot;)
// 可以通过监听流的open和close事件来监听流的打开和关闭
// ws.on(&quot;open&quot;, function{  // on绑定一个长期有效的事件
ws.once(&quot;open&quot;, function{   // once绑定一次性的事件，在触发一次之后事件自动失效
    console.log(&quot;流打开了&quot;)
})
ws.once(&quot;close&quot;, function{
    console.log(&quot;流关闭了&quot;)
})
// 通过ws向文件中输出内容
ws.write(&quot;通过可写流写入文件的内容1&quot;)
ws.write(&quot;通过可写流写入文件的内容2&quot;)
ws.write(&quot;通过可写流写入文件的内容3&quot;)
// 只要流还存在就可以接着写入
// 关闭流
// ws.close()    // 这个在传入的方向断开流，文件没到管子里
ws.end()        // 在传出的这一方断开流，数据已经在管子里了</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="6、文件的读取"><a href="#6、文件的读取" class="headerlink" title="6、文件的读取"></a>6、文件的读取</h3><ul>
<li><p>同步文件读取</p>
</li>
<li><p>异步文件读取</p>
</li>
<li><p>简单文件读取</p>
<ul>
<li><p><code>fs.readFile(path[, options], callback)</code></p>
</li>
<li><p><code>fs.readFileSync(path[, options])</code></p>
<ul>
<li>path 要读取的文件的路径</li>
<li>options 读取的选项</li>
<li>callback 回调函数，通过回调函数将读取到的内容返回<ul>
<li>err 错误对象</li>
<li>data 读取到的数据，会返回一个Buffer</li>
</ul>
</li>
</ul>
<pre><code class="javascript">var fs = require(&quot;fs&quot;)
var path=&quot;C:/Users/Shinlon/a.mp3&quot;
fs.readFile(&quot;hello.txt&quot;, function(err, data){
    if(!err){
        console.log(data)  // buffer通用性更高
        // console.log(data.toString())文本可以，其他不行
        fswriteFile(&quot;hello.mp3&quot;, data, function(err){
            if(!err){
                console.log(&quot;文件写入成功&quot;)
            }
        })
    }
})</code></pre>
</li>
</ul>
</li>
<li><p>流式文件读取</p>
<ul>
<li>流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中</li>
<li><code>fs.createReadStream(path[, options])</code></li>
</ul>
<pre><code class="javascript">var fs = require(&quot;fs&quot;)
// 创建一个可读流
var rs = fs.createReadStream(&quot;an.jpg&quot;)
// 监听流的开启和关闭
rs.once(&quot;open&quot;, function(){
    console.log(&quot;可读流打开了&quot;)
})
rs.once(&quot;close&quot;, function(){
    console.log(&quot;可读流关闭了&quot;)
})
// 读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据
rs.on(&quot;data&quot;, function(data){
    console.log(data) // 参数就是数据 data.length最大65536字节
})</code></pre>
</li>
</ul>
<p>可读流、可写流复制一个大文件</p>
<pre><code class="javascript">var fs = require(&quot;fs&quot;)
var rs = fs.createReadStream(&quot;an.jpg&quot;)
var ws = fs.createWriteStream(&quot;an.jpg&quot;)
rs.once(&quot;open&quot;, function(){
    console.log(&quot;可读流打开了&quot;)
})
rs.once(&quot;close&quot;, function(){
    console.log(&quot;可读流关闭了&quot;)
    // 数据读取完毕，关闭可写流
    ws.end()
})
ws.once(&quot;open&quot;, function(){
    console.log(&quot;可写流打开了&quot;)
})
ws.once(&quot;close&quot;, function(){
    console.log(&quot;可写流关闭了&quot;)
})
rs.on(&quot;data&quot;, function(data){
    ws.write(data)
})</code></pre>
<p>简单的方式</p>
<pre><code class="javascript">var fs = require(&quot;fs&quot;)
var rs = fs.createReadStream(&quot;an.jpg&quot;)
var ws = fs.createWriteStream(&quot;an.jpg&quot;)
rs.once(&quot;open&quot;, function(){
    console.log(&quot;可读流打开了&quot;)
})
rs.once(&quot;close&quot;, function(){
    console.log(&quot;可读流关闭了&quot;)
})
ws.once(&quot;open&quot;, function(){
    console.log(&quot;可写流打开了&quot;)
})
ws.once(&quot;close&quot;, function(){
    console.log(&quot;可写流关闭了&quot;)
})
// pipe()可以将可读流中的内容直接输出到可写流中
rs.pipe(ws)</code></pre>
<h3 id="7、fs的其他方法"><a href="#7、fs的其他方法" class="headerlink" title="7、fs的其他方法"></a>7、fs的其他方法</h3><ul>
<li><p>验证路径是否存在</p>
<ul>
<li><del>fs.exists(path, callback)</del></li>
<li><code>fs.exitsSync(path)</code></li>
</ul>
<pre><code>var fs = require(&quot;fs&quot;)
var isExists = fs.exitsSync(&quot;a.mp3&quot;)
// console.log(isExists)</code></pre></li>
<li><p>获取文件信息</p>
<ul>
<li><code>fs.stat(path, callback)</code>获取文件的状态，会返回一个对象，这个对象中保存了当前对象状态的相关信息</li>
<li><code>fs.statSync(path)</code></li>
</ul>
<pre><code>fs.stat(&quot;a.mp3&quot;, function(err, stat){
    console.log(stat)
})</code></pre><ul>
<li>stat参数的一些属性、方法<ul>
<li>size 大小</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
<li><p>删除文件</p>
<ul>
<li><code>fs.unlink(path, callback)</code></li>
<li><code>fs.unlinkSync(path)</code></li>
</ul>
<pre><code>fs.unlinkSync(&quot;hello.txt&quot;)</code></pre></li>
<li><p>列出文件</p>
<ul>
<li><code>fs.readdir(path[, options], callback)</code>读取一个目录的目录结构</li>
<li><code>fs.readdirSync(path[, options])</code><ul>
<li>files是一个字符串数组，每一个元素就是一个文件夹或文件的名字</li>
</ul>
</li>
</ul>
<pre><code>fs.readdir(&quot;.&quot;, function(err, files){
    if(!err){
        console.log(files)
    }
})</code></pre></li>
<li><p>截断文件</p>
<ul>
<li><code>fs.truncate(path, len, callback)</code> 将文件修改为指定的大小</li>
<li><code>fs.truncateSync(path, len)</code></li>
</ul>
<pre><code>fs.truncateSync(&quot;hello.txt&quot;, 3)</code></pre></li>
<li><p>建立目录</p>
<ul>
<li><code>fs.mkdir(path[,mode], callback)</code></li>
<li><code>fs.mkdirSync(path[, mode])</code></li>
</ul>
<pre><code>fs.mkdirSync(&quot;hello&quot;)</code></pre></li>
<li><p>删除目录</p>
<ul>
<li><code>fs.rmdir(path, callback)</code></li>
<li><code>fs.rmdirSync(path)</code></li>
</ul>
<pre><code>fs.rmdirSync(&quot;hello&quot;)</code></pre></li>
<li><p>重命名文件和目录</p>
<ul>
<li><code>fs.rename(oldPath, newPath, callback)</code></li>
<li><code>fs.renameSync(oldPath, newPath)</code><ul>
<li>oldPath 旧的路径</li>
<li>newPath 新的路径</li>
<li>callback 回调函数</li>
</ul>
</li>
</ul>
<pre><code>fs.rename(&quot;a.mp3&quot;, &quot;new.mp3&quot;, function(err){
    if(!err){
        console.log(&quot;succece&quot;)
    }
})</code></pre></li>
<li><p>监视文件更改写入</p>
<ul>
<li><code>fs.watchFile(filename[, options], listener)</code><ul>
<li>filename 要监视的文件的名字</li>
<li>options 配置选项</li>
<li>listener 回调函数，当文件发生变化时，回调函数会执行<ul>
<li>curr 当前文件的状态</li>
<li>prev 修改前文件的状态</li>
<li>这两个对象都是stats对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>fs.watchFile(&quot;hello.txt&quot;, function{
    console.log(prev.size)
    console.log(curr.size)
})</code></pre><ul>
<li>时间间隔，配置选项中</li>
</ul>
<pre><code>fs.watchFile(&quot;hello.txt&quot;, {interval: 1000}, function{
    console.log(prev.size)
    console.log(curr.size)
})</code></pre></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/14/MongoDB/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="MongoDB学习笔记" class="lazyload">
                    <h1>MongoDB学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月14日</a>
            <a><i class="nexmoefont icon-areachart"></i>5.3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 25 分钟</a>
        </div>

        <article>
            
                <h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="一、数据库简介"><a href="#一、数据库简介" class="headerlink" title="一、数据库简介"></a>一、数据库简介</h2><ul>
<li>数据库是按照数据结构来组织、存储和管理数据的仓库</li>
<li>我们的程序都是在内存中运行的，一旦程序运行结束或者计算机断电，程序运行的数据都会丢失</li>
<li>所以我们就需要将一些程序运行的数据持久化到硬盘之中，以确保数据的安全性</li>
<li>说白了，数据库就是存储数据的仓库</li>
<li>数据库分类<ul>
<li>关系型数据库(RDBMS)<ul>
<li>MySQL、Oracle、DB2、SQL Server……</li>
<li>关系数据库中都是表</li>
</ul>
</li>
<li>非关系型数据库(No SQL  Not Only SQL)<ul>
<li>MongoDB、Redis……</li>
<li>键值对数据库</li>
<li>文档数据库MongoDB</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二、MongoDB简介"><a href="#二、MongoDB简介" class="headerlink" title="二、MongoDB简介"></a>二、MongoDB简介</h2><ul>
<li><p>MongoDB是为快速开发互联网Web应用而设计的数据库系统</p>
</li>
<li><p>MongoDB的设计目标是极简、灵活、作为Web应用栈的一部分</p>
</li>
<li><p>MongoDB的数据模型是面向文档的，所谓文档是一种类似于JSON的结构，简单理解MongoDB这个数据库中存的是各种各样的JSON（BSON）</p>
</li>
<li><p>三个概念</p>
<ul>
<li>数据库（database）：数据库是一个仓库，在仓库中可以存放集合</li>
<li>集合（collection）：集合类似于数组，在集合中可以存放文档</li>
<li>文档（document）：文档数据库中的最小单位，我们存储和操作的内容都是文档</li>
</ul>
</li>
<li><p>下载MongoDB</p>
<ul>
<li>下载地址：<a href="https://www.mongodb.org/dl/win32/" target="_blank" rel="noopener">https://www.mongodb.org/dl/win32/</a></li>
<li>MongoDB的版本偶数版本为稳定版，奇数版本为开发版</li>
<li>MongoDB对于32位系统支持不佳，所以3.2版本以后没有再对32位系统的支持</li>
</ul>
</li>
<li><p>安装MongoDB</p>
<ul>
<li><p>安装</p>
</li>
<li><p>配置环境变量 D:\Program Files\MongoDB\Server\4.2\bin</p>
</li>
<li><p>在C盘根目录下创建data/db文件夹</p>
</li>
<li><p>打开cmd命令行窗口</p>
<ul>
<li>输入<code>mongod</code>启动MongoDB服务器</li>
<li>32位的初次启动需要输入<code>mongod --storageEngine=mmapv1</code></li>
</ul>
</li>
<li><p>再打开一个cmd窗口</p>
<ul>
<li>输入<code>mongo</code>连接mongodb，出现<code>&gt;</code></li>
</ul>
</li>
<li><p>其他配置命令<code>mongod --dbpath &quot;D:\Program Files\MongoDB\Server\4.2\data\db --port 123&quot;</code></p>
</li>
<li><p>数据库</p>
<ul>
<li><p>服务器用来保存数据，<code>mongod</code>启动</p>
</li>
<li><p>客户端用来操作服务器，对数据进行增删改查的操作，<code>mongo</code>来启动</p>
</li>
<li><p>需要打开两个窗口，我们可以将MongoDB设置为系统服务，可以自动在后台启动，不需要每次都手动启动</p>
<ul>
<li><p>C://data/创建db、log目录</p>
</li>
<li><p>在D:\Program Files\MongoDB\Server\4.2下添加一个配置文件mongod.cfg，配置文件中添加内容</p>
<pre><code>systemLog:
    destination: file
    path: c:\data\log\mongod.log
storage:
    dbPath: c:\data\db</code></pre></li>
<li><p>以管理员身份打开命令行窗口，输入命令<code>sc.exe create MongoDB binPath=&quot;\&quot;D:\Program Files\MongoDB\Server\4.2\bin\mongod.exe\&quot; --service --config=\&quot;D:\Program Files\MongoDB\Server\4.2\mongod.cfg\&quot;&quot; DisplayName= &quot;MongoDB&quot; start= &quot;auto&quot;</code></p>
</li>
<li><p>启动MongoDB服务</p>
</li>
<li><p>如果启动失败，则输入<code>sc delete MongoDB</code>删除服务之后，重新开始配置</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、MongoDB的基本操作"><a href="#三、MongoDB的基本操作" class="headerlink" title="三、MongoDB的基本操作"></a>三、MongoDB的基本操作</h2><p>在MongoDB中，数据库和集合都不需要我们手动创建，当我们创建文档时，如果文档所在的集合或数据库不存在则会自动创建数据库和集合</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1588908280549.png" alt="MongoDB" class="lazyload"></p>
<h3 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h3><ul>
<li>显示当前的所有数据库<ul>
<li><code>show dbs</code></li>
<li><code>show databases</code></li>
</ul>
</li>
<li>进入到指定的数据库中<ul>
<li><code>use 数据库名</code></li>
</ul>
</li>
<li>db表示的是当前所处的数据库<ul>
<li><code>db</code></li>
</ul>
</li>
<li>显示数据库中所有的集合<ul>
<li><code>show collections</code></li>
</ul>
</li>
</ul>
<h3 id="2、数据库的CRUD操作"><a href="#2、数据库的CRUD操作" class="headerlink" title="2、数据库的CRUD操作"></a>2、数据库的CRUD操作</h3><p>安装图形化工具：<code>MongodbManagerFree</code>或<code>Studio-3T</code></p>
<ul>
<li><p>向数据库中插入文档</p>
<ul>
<li><code>db.&lt;collection&gt;.insert(doc)</code> 向集合中插入一个或多个文档。当我们向集合中插入文档时，如果没有给文档指定<code>_id</code>属性，则数据库会自动为文档添加<code>_id</code>，该属性用来作为文档的唯一标识，也可以自己指定，如果我们指定了，数据库就不会添加了，如果自己指定_id也必须确保它的唯一性</li>
</ul>
<pre><code>// 向test数据库中的stus集合中插入一个新的学生对象{name:&quot;swk&quot;,age:18,gender:&quot;man&quot;}
use test
db.stus.insert({name:&quot;swk&quot;,age:18,gender:&quot;man&quot;})
db.stus.insert([
    {name:&quot;shs&quot;,age:38,gender:&quot;man&quot;},
    {name:&quot;bgj&quot;,age:18,gender:&quot;female&quot;},
    {name:&quot;zbj&quot;,age:28,gender:&quot;man&quot;}
])
ObjectId()  // 根据时间戳、机器码
db.stus.insert({_id:&quot;ts&quot;,name:&quot;ts&quot;,age:18,gender:&quot;man&quot;})   // 建议不要自己指定</code></pre><ul>
<li><code>db.&lt;collection&gt;.insertOne(doc)</code>  插入一个文档对象</li>
<li><code>db.&lt;collection&gt;.insertMany(doc)</code>  插入多个文档对象</li>
<li>这两个和上面的差不多，就是写开了更容易理解</li>
</ul>
<p>注：MongoDB中的文档的属性值也可以是一个文档，当一个文档的属性值是文档时，我们称这为内嵌文档。</p>
<p>MongoDB支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档，可以通过<code>.</code>的形式来匹配。属性名必须用引号括起来</p>
</li>
<li><p>查询</p>
<ul>
<li><code>db.&lt;collectin&gt;.find()</code> 查询当前集合中的所有的文档<ul>
<li>find()用来查询集合中所有符合条件的文档。在开发时，绝对不会执行不带条件的查询</li>
<li>find()可以接受一个对象作为条件参数<ul>
<li>{}表示查询集合中所有的文档</li>
<li>{字段名:值}查询属性是指定值的文档<ul>
<li>值还可以添加一个选项,多个条件之间使用<code>,</code>连接</li>
<li><code>$eq</code> 等于</li>
<li><code>$gt</code>  <code>$gte</code> 大于  大于等于</li>
<li><code>$in</code></li>
<li><code>$lt</code> <code>$lte</code></li>
<li><code>$ne</code></li>
<li><code>$nin</code></li>
<li><code>$or</code> 或</li>
</ul>
</li>
</ul>
</li>
<li>find()返回的是一个数组</li>
<li><code>db.stus.find({}).count()</code>返回对象个数，一般用这个；<code>db.stus.find({}).length()</code></li>
<li><code>db.stus.find().limit(10)</code> 设置显示数据的上限，这里表示只显示前十条数据</li>
<li><code>db.numbers.find().skip(10).limit(10)</code> skip()用于跳过指定数量的数据，这里会显示第11~20条数据。MongoDB会自动调整skip和limit的位置，因此顺序随便</li>
</ul>
</li>
<li><code>db.&lt;collectin&gt;.findOne()</code> 查询当前集合中符合条件的第一个文档<ul>
<li>findOne()返回的是一个文档对象</li>
</ul>
</li>
</ul>
<pre><code>db.stus.find();
db.stus.find({});
db.stus.find({}).count();
db.stus.find({}).length();
db.stus.find({_id:&quot;ts&quot;});
db.stus.find({age: 28,name:&quot;zbj&quot;});
db.stus.find({age: 28})[1];
db.stus.find({age:{$gt:20}})</code></pre></li>
<li><p>修改</p>
<ul>
<li><code>db.&lt;collectin&gt;.update(查询条件,新对象[,配置选项])</code> <ul>
<li>update()默认情况下回使用新对象来替换旧的对象</li>
<li>如果需要修改指定的属性，而不是替换，需要使用“修改操作符”来完成修改<ul>
<li><code>$set</code> 可以用来修改文档中的指定属性</li>
<li><code>$push</code>用于向数据中添加一个新的元素</li>
<li><code>$addT0Set</code>向数据中添加一个新元素，如果数组中已经存在该元素，则不会添加</li>
<li><code>$unset</code> 可以用来删除文档的指定属性</li>
</ul>
</li>
<li>update()默认只会修改一个</li>
</ul>
</li>
<li><code>db.&lt;collectin&gt;.updateMany(查询条件,新对象)</code>  同时修改多个符合条件的文档</li>
<li><code>db.&lt;collectin&gt;.updateOne(查询条件,新对象)</code>  修改一个符合条件的文档</li>
<li><code>db.&lt;collectin&gt;.replace(查询条件,新对象)</code>   替换一个文档</li>
<li>这三个也是将第一个分开了</li>
</ul>
<pre><code>db.stus.upadate({name:&#39;shs&#39;},{age:29}) // 替换
db.stus.upadate({name:&#39;shs&#39;},{$set{age:29， address:&quot;lsh&quot;}) // 修改，默认值修改一个
db.stus.upadate({name:&#39;shs&#39;},{$set{address:&quot;lsh&quot;})
db.stus.upadate({name:&#39;shs&#39;},{$unset{age:29}) // 删除
db.stus.upadate({name:&#39;shs&#39;},{$set{age:29， address:&quot;lsh&quot;}) // 添加配置项也可以修改多个</code></pre></li>
</ul>
<ul>
<li><p>删除</p>
<ul>
<li><code>db.&lt;collectin&gt;.remove()</code> <ul>
<li>remove()可以根据条件来删除文档，传递的条件的方式和find()一样</li>
<li>删除符合条件的所有的文档，默认会删除多个</li>
<li>如果remove()第二个参数传递一个true，则只会删除一个</li>
<li>如果只传递一个空对象，则会删除所有的</li>
</ul>
</li>
<li><code>db.&lt;collectin&gt;.deleteOne()</code></li>
<li><code>db.&lt;collectin&gt;.deleteMany()</code>  </li>
<li><code>db.collection.drop()</code> 删除集合</li>
<li><code>db.dropDatabase()</code>删除数据库</li>
<li>一般数据库中的数据都不会删除，所以删除的方法很少调用，一般在数据中添加一个字段，来表示数据是否被删除</li>
</ul>
<pre><code>db.stus.remove()

db.stus.remove({})   // 清空集合（性能略差）
db.stus.drop()     // 删除集合
db.database()       // 删除数据库
// 一般删除一个文档都是用这种方式
db.stus.inert([
    {
        name: &quot;ts&quot;,
        isDel: 0
    },
    {
        name: &quot;zbj&quot;,
        isDel: 0
    },
    {
        name:&quot;shs&quot;,
        isDel: 0
    }
])
db.stus.updateOne({name:&quot;ts&quot;},{$et:{isDel:1}})
db.stus.find({isDel:0})</code></pre></li>
</ul>
<h2 id="四、文档之间的关系"><a href="#四、文档之间的关系" class="headerlink" title="四、文档之间的关系"></a>四、文档之间的关系</h2><ul>
<li><p>一对一(One to One)</p>
<ul>
<li>夫妻（一个丈夫对应一个妻子）</li>
<li>在MongoDB中，可以通过内嵌文档的形式来体现出一对一的关系</li>
</ul>
<pre><code>db.wifeAndHusband.insert([
    {
        name:&quot;hr&quot;,
        husband:{
            name:&quot;gj&quot;
        }
    },{
        name:&quot;pjl&quot;
        husband:{
            name:&quot;wdl&quot;
        }
    }
])</code></pre></li>
</ul>
<ul>
<li><p>一对多(One to Many)/多对一(Many to One)</p>
<ul>
<li>父母——孩子、用户——订单、文章——评论</li>
<li>也可以通过内嵌文档来映射一对多的关系，属性变为数组</li>
</ul>
<pre><code>db.users.insert([
    {
        username:&quot;swk&quot;
    },{
        username:&quot;zbj&quot;
    }
])
db.order.insert({
    list:[&quot;pg&quot;,&quot;xj&quot;,&quot;dyl&quot;],
    user_id:ObjectId(&quot;swk_Id&quot;)
})
var user_idd = db.users.findOne({username:&quot;swk&quot;})._id
db.order.find({user_id:user_idd})</code></pre></li>
</ul>
<ul>
<li><p>多对多(Many to Many)</p>
<ul>
<li>分类——商品、老师——学生</li>
<li>学生属于多个老师、老师教多个学生，学生中有一个老师的id，id多个用数组</li>
</ul>
<pre><code>db.teachers.insert([
    {
        name: &#39;hqg&#39;,
    },
    {
        name: &#39;hys&#39;,
    },
    {
        name: &quot;gxr&quot;
    }
])
db.stus.insert([
    {
        name:&quot;gj&quot;,
        tech_ids:[
            ObjectID(&#39;hqgID&#39;),
            ObjectID(&quot;hysID&quot;)
        ]
    },
    {
        name:&quot;swk&quot;,
        tech_ids: [
            ObjectID(&#39;hqgID&#39;),
            ObjectID(&quot;hysID&quot;),
            ObjectID(&quot;gxr&quot;)
        ]
    }
])
db.teachers.find()
db.stus.find()</code></pre></li>
</ul>
<h2 id="五、sort和投影"><a href="#五、sort和投影" class="headerlink" title="五、sort和投影"></a>五、sort和投影</h2><ul>
<li><code>db.emp.find()</code> 查询文档时，默认情况是按照_id的值进行排列(升序)</li>
<li><code>db.emp.find({}).sort({sal:1})</code> sort()可以用来指定文档的排序的规则，sort()需要传递一个队形来指定排序的规则<ul>
<li>1 表示升序</li>
<li>-1 表示降序</li>
<li><code>db.emp.find({}).sort(sal:1, empno:-1)</code> 先按照sal升序排列，如果sal相同，按照empno降序排列</li>
</ul>
</li>
<li>注：limit、skip、sort书写顺序没有要求</li>
<li><code>db.emp.find({}, {ename:1})</code>在查询时，可以在第二个参数的位置来设置查询结果的投影   <code>db.emp.find({}, {ename: 1, _id: 0, sal: 1})</code></li>
</ul>
<h2 id="六、MongoOse简介"><a href="#六、MongoOse简介" class="headerlink" title="六、MongoOse简介"></a>六、MongoOse简介</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li>之前我们都是通过shell来完成对数据库的各种操作的，在开发中大部分的时候我们都需要通过程序来完成对数据库的操作</li>
<li>Mongoose就是一个让我们可以通过Node来操作MongoDB的模块</li>
<li>Mongoose是一个对象文档模型(ODM)库，它对Node原生的MongoDB模块进行了进一步的优化封装，并提供了很多的功能</li>
<li>在大多数情况下，它被用来把结构化的模式应用到一个MongoDB集合，并提供了验证和类型转换等好处</li>
</ul>
<h3 id="2、Mongoose好处"><a href="#2、Mongoose好处" class="headerlink" title="2、Mongoose好处"></a>2、Mongoose好处</h3><ul>
<li>可以为文档创建一个模式结构（Schema）   ——约束</li>
<li>可以对模型中的对象/文档进行验证</li>
<li>数据可以通过类型转换转为对象模型</li>
<li>可以使用中间件来应用业务逻辑挂钩</li>
<li>比Node原生的MongoDB驱动更容易</li>
</ul>
<h3 id="3、新的对象"><a href="#3、新的对象" class="headerlink" title="3、新的对象"></a>3、新的对象</h3><ul>
<li>Schema(模式对象)<ul>
<li>定义约束了数据库中的文档结构</li>
</ul>
</li>
<li>Model<ul>
<li>Model对象作为集合中所有文档的表示，相当于MongoDB数据库中的集合</li>
</ul>
</li>
<li>Document<ul>
<li>Document表示集合中的具体文档，相当于集合中的一个具体的文档</li>
</ul>
</li>
</ul>
<h2 id="七、连接MongoDB数据库"><a href="#七、连接MongoDB数据库" class="headerlink" title="七、连接MongoDB数据库"></a>七、连接MongoDB数据库</h2><ol>
<li>下载安装Mongoose   <code>npm i mongoose --save</code></li>
<li>在项目中引入Mongoose   <code>var mongoose = require(&quot;mongoose&quot;)</code></li>
<li>连接数据库   <code>mongoose.connect(&#39;mongodb://数据库IP地址:端口号/数据库名&#39;);</code><ul>
<li>端口号如果是默认端口号(27017)，则可以省略不写</li>
</ul>
</li>
<li>[可选] 监听MongoDB数据库的连接状态<ul>
<li>在Mongoose对象中，有一个属性叫做connection，该对象表示的就是数据库连接通过监视该对象的状态，可以来监听数据库的连接与断开<ul>
<li><code>mongoose.connection.once(&quot;open&quot;,function(){})</code> 数据库连接成功的事件</li>
<li><code>mongoose.connection.once(&quot;close&quot;,function(){})</code> 数据库断开的事件</li>
</ul>
</li>
</ul>
</li>
<li>断开数据库连接(一般不需要调用) <code>mongoose.disconnect()</code><ul>
<li>MongoDB数据库，一般情况下只需要连接一次，连接一次以后，除非项目停止、服务器关闭，否接连接一般不会断开</li>
</ul>
</li>
</ol>
<pre><code>// 例子
var mongoose = require(&quot;mongoose&quot;)
mongoose.connect(&quot;mongodb://127.0.0.1/mongoose_test&quot;)
mongoose.connection.once(&quot;open&quot;,function(){
    console.log(&quot;数据库已连接&quot;)
})
mongoose.connection.once(&quot;close&quot;,function(){
    console.log(&quot;数据库已断开&quot;)
})
mongoose.disconnect()</code></pre><h2 id="八、Schema、Model和Document"><a href="#八、Schema、Model和Document" class="headerlink" title="八、Schema、Model和Document"></a>八、Schema、Model和Document</h2><p>有了Model，就可以对数据库进行增删改查的操作了</p>
<ul>
<li><code>Model.crate(doc(s), [callback])</code><ul>
<li>用来创建一个文档并添加到数据库中</li>
<li>doc(s)  可以是一个文档对象，也可以是一个文档对象的数组</li>
<li>callback  当操作完成之后调用的回调函数</li>
</ul>
</li>
<li>查询<ul>
<li><code>Model.find(conditions, [projection], [options], [callback])</code> 查询所有符合条件的文档 总会返回一个数组</li>
<li><code>Model.findById(id, [projection], options), [callback]</code> 根据文档的id属性查询文档</li>
<li><code>Model.findOne([conditions], [projection], [options], [callback])</code> 查询符合条件的第一个文档  总会返回一个具体的对象<ul>
<li>conditions 查询的条件</li>
<li>projection 投影  需要获取到的字段 两种方式 <ul>
<li><code>{}</code>  对象，要的字段为1，不要的为0</li>
<li><code>&quot;&quot;</code> 字段名、不要的设为-</li>
</ul>
</li>
<li>options 查询选项（skip limit）</li>
<li>callback 回调函数，查询结果会通过回调函数返回，毁掉函数必须传，如果不传回调函数，压根不会查询</li>
</ul>
</li>
<li>通过find()查询的结果，返回的对象，就是Document，文档对象</li>
</ul>
</li>
<li>修改<ul>
<li><code>Model.update(conditions, doc, [options], [callback])</code></li>
<li><code>Model.updateMany(conditions, doc, [options], [callback])</code></li>
<li><code>Model.updateOne(conditions, doc, [options], [callback])</code><ul>
<li>用来修改一个或多个文档</li>
<li>conditions 查询条件</li>
<li>doc 修改后的对象</li>
<li>options 配置参数</li>
<li>callback 回调函数</li>
</ul>
</li>
<li><code>Model.replaceOne(conditions, doc, [options], [callback])</code> 替换</li>
</ul>
</li>
<li>删除(不用这个)<ul>
<li><code>Model.remove(conditions, [callback])</code></li>
<li><code>Model.deleteOne(conditions, [callback])</code></li>
<li><code>Model.deleteMany(conditions, [callback])</code></li>
</ul>
</li>
<li><code>Model.count(conditions, [callback])</code><ul>
<li>统计文档的数量</li>
</ul>
</li>
</ul>
<p>Document和集合中的文档一一对应，Document是Model的实例，通过Model查询到结果都是Document</p>
<p>Document的方法</p>
<ul>
<li><code>Model#save([options], [options.safe], [options.validateBeforeSave], [fn])</code></li>
<li><code>update(update, [options], [callback])</code><ul>
<li>修改对象</li>
</ul>
</li>
<li><code>remove([callback])</code><ul>
<li>删除对象(拒绝用这个)</li>
</ul>
</li>
<li><code>get(name)</code><ul>
<li>获取文档中的指定属性值</li>
</ul>
</li>
<li><code>set(name, value)</code><ul>
<li>设置文档的指定的属性值</li>
</ul>
</li>
<li><code>id</code><ul>
<li>获取文档的_id属性值</li>
</ul>
</li>
<li><code>toJSON()</code><ul>
<li>转换为一个JSON对象</li>
</ul>
</li>
<li><code>toObject()</code><ul>
<li>将Document对象转换为普通的js对象</li>
<li>转换为普通的js对象以后，所有的Document对象的方法或属性都不能使用了</li>
</ul>
</li>
<li>其他 <code>equals(doc)</code>  <code>isNew</code>  <code>isInit(path)</code> </li>
</ul>
<pre><code class="javascript">var mongoose = require(&quot;mongoose&quot;)
mongoose.connect(&quot;mongodb://127.0.0.1/mongoose_test&quot;, {useMongoClient:true})
// Schema对数据进行约束
// 将mongoose.Schema赋值给一个变量
var Schema = mongoose.Schema
// 创建Schema(模式)对象
var stuSchema = new Schema({
    name: String,
    age: Number,
    gender: {
        type: String,
        default: &quot;male&quot;
    },
    address: String
})

// Model代表的是数据库中的集合，通过Model才能对数据库进行操作
// 通过Schema来创建Model
// mogoose.model(&quot;要映射的集合名&quot;, 刚创建的Schema对象) Mongoose会自动将集合名变为复数
var StuModel = mogoose.model(&quot;student&quot;, stuSchema)
// 向数据库中出入一个文档 model.create(文档, 回调函数)
stuModel.create({
    name: &#39;swk&#39;,
    age: 18,
    gender: &#39;male&#39;,
    address: &quot;hgs&quot;
}, function(err){
    if(!err){
        console.log(&quot;插入成功&quot;)
    }
})
stuModel.create([{
    name: &#39;shs&#39;,
    age: 28,
    gender: &#39;male&#39;,
    address: &quot;lsh&quot;
},{
    name: &quot;bgj&quot;,
    age: 17,
    gender: &quot;female&quot;,
    address: &quot;bgd&quot;
}], function(err){
    if(!err){
        console.log(&quot;插入成功&quot;)
    }
})

// 查询
StuModel.find({name:&quot;shs&quot;},function(err, docs){
    if(!err){
        console.log(docs)
        console.log(docs[0].name)
    }
})
/* StuModel.find({name:&quot;shs&quot;},{name:1, _id:0},function(err, docs){
    if(!err){
        console.log(docs)
    }
}) */
StuModel.find({name:&quot;shs&quot;},&quot;name -_id&quot;,function(err, docs){
    if(!err){
        console.log(docs)
    }
})
StuModel.find({name:&quot;shs&quot;},&quot;name -_id&quot;,{skip:3, limit:1},function(err, docs){
    if(!err){
        console.log(docs)
    }
})
StuModel.findOne({}, function(err, doc){
    if(!err){
        console.log(doc.name)
    }
})
StuModel.findById(&quot;...&quot;,function(err,doc){
    if(!err){
        console.log(doc)
    }
})

// Document对象是Model的实例
/* StuModel.findById(&quot;...&quot;,function(err,doc){
    if(!err){
        console.log(doc instantceof StuModel)
    }
})
 */

StuModel.updateOne({name: &#39;ts&#39;}, {$set:{age:20}},function(err){
    if(!err){
        console.log(&quot;修改成功&quot;)
    }
})

StuModel.remove({name:&quot;bgj&quot;}, function(err){
    if(!err){
        console.log(&quot;删除成功&quot;)
    }
})

StuModel.count({}, function(err, count){
    if(!err){
        console.log(count)
    }
})



// 创建一个Document
var stu = new StuModel({
    name: &quot;blm&quot;,
    age: 14,
    gender: &quot;male&quot;,
    address: &quot;bbt&quot;
})
stu.save(function(err){
    if(!err){
        console.log(&quot;保存成功&quot;)
    }
})
StuModel.findOne({}, function(err, doc){
    if(!err){
        /* doc.update({$set:{age: 28}}, function(err){
            if(!err){
                console.log(&quot;修改成功&quot;)
            }
        }) */
        doc.age = 28
        save()

        /* doc.remove(function(err){
            if(!err){
                console.log(&quot;删除成功&quot;)
            }
        }) */
        // console.log(doc.get(&quot;age&quot;))
        console.log(doc.age)
        // doc.set(&quot;name&quot;, &quot;zhu&quot;)
        doc.name = &quot;zhu&quot;
        // console.log(doc.id)
        console.log(doc._id)
        console.log(doc.toJSON())
        doc = doc.toObject()
        delete doc.address
        console.log(doc)
    }
})</code></pre>
<h2 id="九、Mongoose的模块化"><a href="#九、Mongoose的模块化" class="headerlink" title="九、Mongoose的模块化"></a>九、Mongoose的模块化</h2><p>定义一个模块，用来连接MongoDB数据库</p>
<pre><code class="javascript">// conn_mongo.js
var mongoose = require(&quot;mongoose&quot;)
mongoose.connect(&quot;mongodb://127.0.0.1/mongoose_test&quot;)</code></pre>
<p>定义一个student的模型，几个模型就可以创建几个js文件</p>
<pre><code class="javascript">// student.js
var mongoose = require(&quot;mongoose&quot;)
var Schema = mongoose.Schema
var stuSchema = new Schema({
    name: String,
    age: Number,
    gender: {
        type: String,
        default: &quot;male&quot;
    },
    address: String
})
var StuModel = mongoose.model(&quot;student&quot;, stuSchema)
// exports.model = StuModel
module.exports = StuModel</code></pre>
<p>其他地方引入</p>
<pre><code class="javascript">require(&quot;./conn_mongo&quot;)
// var Student = require(&quot;./models/student&quot;).model
var Student = require(&quot;./models/student&quot;)
Student.find({}, function(err, docs){
    if(!err){
        console.log(docs)
    }
})</code></pre>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><pre><code>//1.进入my_test数据库
use my_test

//2.向数据库的user集合中插入一个文档  
db.users.insert({
    username:&quot;sunwukong&quot;
});

//3.查询user集合中的文档
db.users.find();

//4.向数据库的user集合中插入一个文档   
db.users.insert({
    username:&quot;zhubajie&quot;
});

//5.查询数据库user集合中的文档
db.users.find();

//6.统计数据库user集合中的文档数量
db.users.find().count();

//7.查询数据库user集合中username为sunwukong的文档
db.users.find({username:&quot;sunwukong&quot;});

//8.向数据库user集合中的username为sunwukong的文档，添加一个address属性，属性值为huaguoshan
db.users.update({username:&quot;sunwukong&quot;},{$set:{address:&quot;huaguoshan&quot;}});


//9.使用{username:&quot;tangseng&quot;} 替换 username 为 zhubajie的文档
db.users.replaceOne({username:&quot;zhubajie&quot;},{username:&quot;tangseng&quot;});    

//10.删除username为sunwukong的文档的address属性
db.users.update({username:&quot;sunwukong&quot;},{$unset:{address:1}});


//11.向username为sunwukong的文档中，添加一个hobby:{cities:[&quot;beijing&quot;,&quot;shanghai&quot;,&quot;shenzhen&quot;] , movies:[&quot;sanguo&quot;,&quot;hero&quot;]}
//MongoDB的文档的属性值也可以是一个文档，当一个文档的属性值是一个文档时，我们称这个文档叫做 内嵌文档
db.users.update({username:&quot;sunwukong&quot;},{$set:{hobby:{cities:[&quot;beijing&quot;,&quot;shanghai&quot;,&quot;shenzhen&quot;] , movies:[&quot;sanguo&quot;,&quot;hero&quot;]}}});
db.users.find();

//12.向username为tangseng的文档中，添加一个hobby:{movies:[&quot;A Chinese Odyssey&quot;,&quot;King of comedy&quot;]}
db.users.update({username:&quot;tangseng&quot;},{$set:{hobby:{movies:[&quot;A Chinese Odyssey&quot;,&quot;King of comedy&quot;]}}})

//13.查询喜欢电影hero的文档
//MongoDB支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档则可以通过.的形式来匹配
//如果要通过内嵌文档来对文档进行查询，此时属性名必须使用引号 
db.users.find({&#39;hobby.movies&#39;:&quot;hero&quot;});

//14.向tangseng中添加一个新的电影Interstellar
//$push 用于向数组中添加一个新的元素
//$addToSet 向数组中添加一个新元素 ， 如果数组中已经存在了该元素，则不会添加
db.users.update({username:&quot;tangseng&quot;},{$push:{&quot;hobby.movies&quot;:&quot;Interstellar&quot;}});
db.users.update({username:&quot;tangseng&quot;},{$addToSet:{&quot;hobby.movies&quot;:&quot;Interstellar&quot;}});
db.users.find();

//15.删除喜欢beijing的用户
db.users.remove({&quot;hobby.cities&quot;:&quot;beijing&quot;});

//16.删除user集合
db.users.remove({});
db.users.drop();

show dbs;

//17.向numbers中插入20000条数据 7.2s
for(var i=1 ; i&lt;=20000 ; i++){
    db.numbers.insert({num:i});
}

db.numbers.find()

db.numbers.remove({});


//0.4s
var arr = [];

for(var i=1 ; i&lt;=20000 ; i++){
    arr.push({num:i});
}

db.numbers.insert(arr);


//18.查询numbers中num为500的文档
db.numbers.find({num:500})

//19.查询numbers中num大于5000的文档
db.numbers.find({num:{$gt:500}});
db.numbers.find({num:{$eq:500}});

//20.查询numbers中num小于30的文档
db.numbers.find({num:{$lt:30}});

//21.查询numbers中num大于40小于50的文档
db.numbers.find({num:{$gt:40 , $lt:50}});

//22.查询numbers中num大于19996的文档
db.numbers.find({num:{$gt:19996}});

//23.查看numbers集合中的前10条数据
db.numbers.find({num:{$lte:10}});

//limit()设置显示数据的上限
db.numbers.find().limit(10);
//在开发时，我们绝对不会执行不带条件的查询
db.numbers.find();

//24.查看numbers集合中的第11条到20条数据
/*
    分页 每页显示10条
        1-10     0
        11-20    10
        21-30    20
        。。。

        skip((页码-1) * 每页显示的条数).limit(每页显示的条数);

    skip()用于跳过指定数量的数据    

    MongoDB会自动调整skip和limit的位置
*/
db.numbers.find().skip(10).limit(10);

//25.查看numbers集合中的第21条到30条数据
db.numbers.find().skip(20).limit(10);

db.numbers.find().limit(10).skip(10);




//26.将dept和emp集合导入到数据库中
db.dept.find()
db.emp.find()

//27.查询工资小于2000的员工
db.emp.find({sal:{$lt:2000}});

//28.查询工资在1000-2000之间的员工
db.emp.find({sal:{$lt:2000 , $gt:1000}});

//29.查询工资小于1000或大于2500的员工
db.emp.find({$or:[{sal:{$lt:1000}} , {sal:{$gt:2500}}]});

//30.查询财务部的所有员工
//(depno)
var depno = db.dept.findOne({dname:&quot;财务部&quot;}).deptno;
db.emp.find({depno:depno});

//31.查询销售部的所有员工
var depno = db.dept.findOne({dname:&quot;销售部&quot;}).deptno;
db.emp.find({depno:depno});

//32.查询所有mgr为7698的所有员工
db.emp.find({mgr:7698})

//33.为所有薪资低于1000的员工增加工资400元
db.emp.updateMany({sal:{$lte:1000}} , {$inc:{sal:400}});
db.emp.find()
</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/04/AngularJs/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="AngularJs学习笔记" class="lazyload">
                    <h1>AngularJs学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月04日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 12 分钟</a>
        </div>

        <article>
            
                <h2 id="1、Angular介绍"><a href="#1、Angular介绍" class="headerlink" title="1、Angular介绍"></a>1、Angular介绍</h2><ul>
<li>官网： <a href="https://angularjs.org" target="_blank" rel="noopener">https://angularjs.org</a></li>
<li>Angular是Google开源的前端JS结构化框架</li>
<li>AngularJS特性和优点<ul>
<li>双向数据绑定</li>
<li>声明式依赖注入</li>
<li>解耦应用逻辑，数据模型和视图<ul>
<li>耦合度：两者之间关系密切度</li>
<li>降低耦合度</li>
</ul>
</li>
<li>完善的页面指令</li>
<li>定制表单验证</li>
<li>Ajax封装</li>
</ul>
</li>
<li>与jQuery比较<ul>
<li>jQuery<ul>
<li>JS函数库</li>
<li>封装简化DOM操作</li>
</ul>
</li>
<li>Angular<ul>
<li>JS结构化框架</li>
<li>主体不再是DOM，而是页面中的动态数据</li>
</ul>
</li>
</ul>
</li>
<li>AngularJS能做什么项目<ul>
<li>构建单页面(SPA)Web应用或Web APP应用<ul>
<li>单页面应用（SPA）Simple Page Application特点：<ul>
<li>将所有的活动局限于一个页面</li>
<li>当页面中有部分数据发生了变化不会去刷新整个页面，而是局部刷新</li>
<li>利用的Ajax技术、路由</li>
</ul>
</li>
</ul>
</li>
<li>应用<ul>
<li><del>饿了么 <a href="https://www.ele.me/home/" target="_blank" rel="noopener">https://www.ele.me/home/</a></del></li>
<li>微信网页版 <a href="https://wx.qq.com" target="_blank" rel="noopener">https://wx.qq.com</a></li>
<li>知乎周报 <a href="https://zhuanlan.zhihu.com/Weekly" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/Weekly</a></li>
<li>后台管理应用：阿里云、土豆后台、唯品会……</li>
</ul>
</li>
</ul>
</li>
<li>版本学习<ul>
<li>1.0 JavaScript </li>
<li><del>2.0 3.0 4.0 TypeScript</del></li>
</ul>
</li>
</ul>
<h3 id="2、第一个Angular程序"><a href="#2、第一个Angular程序" class="headerlink" title="2、第一个Angular程序"></a>2、第一个Angular程序</h3><p>使用jQuery实现</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;jQuery实现&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;input type=&quot;text&quot;&gt;
  &lt;p&gt;您输入的内容是：&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
  &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    $(function(){  //document.ready 文档(页面结构)加载完毕 window.onload:整个页面加载完毕，包括图片等资源
      $(&#39;input&#39;).keyup(function(){
        var value = this.value   // $(this).val()
        $(&#39;span&#39;).html(value)
      })
    })
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>使用AngularJS实现</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;AngularJS实现&lt;/title&gt;
&lt;/head&gt;
&lt;body ng-app&gt;
  &lt;input type=&quot;text&quot; ng-model=&quot;username&quot;&gt;
  &lt;p&gt;您输入的内容是：&lt;span&gt;{{username}}&lt;/span&gt;&lt;/p&gt;
  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/angular.js/1.2.29/angular.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Chrome插件：</p>
<blockquote>
<p>ng-inspector for AngularJS</p>
</blockquote>
<ul>
<li><code>ng-app</code>(指令)：告诉angular核心，它管理当前标签所包含的整个区域，并且会自动创建$rootScope根作用域对象（通常放在body标签）</li>
<li><code>ng-model</code>：将当前输入框的值与谁关联(属性名:属性值)，并作为当前作用域对象($rootScope)的属性</li>
</ul>
<pre><code>{{}}(表达式)：显示数据，从当前作用域对象的指定属性名上取</code></pre><ul>
<li><p>表达式：通常有一个返回值，可以放在任何需要值的地方，比如函数调用的参数、一个变量名、一个运算等</p>
</li>
<li><p>语句：通常表示一个完整的执行单位，一段完整的js可执行代码，有的语句也可以用表达式来执行，称为表达式语句</p>
</li>
<li><p>区别：语句用分号结尾，有些语句我们没有加分号，例如console.log虽然没加分号，但也是语句，因为js引擎会自动在解析的时候加上分号</p>
</li>
<li><p>特例：if语句，就不用加分号，也可以是完整的语句</p>
</li>
</ul>
<h2 id="二、四个重要概念"><a href="#二、四个重要概念" class="headerlink" title="二、四个重要概念"></a>二、四个重要概念</h2><h3 id="1、双向数据绑定"><a href="#1、双向数据绑定" class="headerlink" title="1、双向数据绑定"></a>1、双向数据绑定</h3><ul>
<li><p>数据绑定：数据从一个地方A转移(传递)到另一个地方B，而且这个操作由框架来完成</p>
</li>
<li><p>双向数据绑定：数据可以从View(视图层)流向Model(模型)，也可以从Model流向View</p>
<ul>
<li><p>视图(View)：也就是我们的页面（主要是Angular指令和表达式）</p>
</li>
<li><p>模型(Model)：作用域对象(当前为$rootScope)，它可以包含一些属性或方法</p>
</li>
<li><p>当改变View中的数据，Model对象的对应属性也会随之改变：ng-model指令 数据从View到Model</p>
</li>
<li><p>当Model域对象的属性发生改变时，页面对应数据随之更新：{{}}表达式  数据从Model到View</p>
</li>
<li><p>ng-model是双向数据绑定，而{{}}是单向数据绑定</p>
<p>(View——页面   Model——内存)</p>
</li>
</ul>
</li>
<li><p>ng-init：用来初始化当前作用域变量  （View–&gt;Model–&gt;View)</p>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;AngularJS实现&lt;/title&gt;
&lt;/head&gt;
&lt;body ng-app&gt;    &lt;!-- ng-app=&quot;&quot;除了接管区域，还会自动生成根作用域($rootScope) --&gt;
  &lt;!--
  &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;   先传递到Model，再从Model到三个View中的相应位置
  &lt;p&gt;姓名1：{{name}}&lt;/p&gt;
  &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
  &lt;p&gt;姓名2：{{name}}&lt;/p&gt;
  --&gt;
  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/angular.js/1.2.29/angular.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>显示结果</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1589612197548.png" alt="测试" class="lazyload"></p>
<p>过程</p>
<pre><code class="html">&lt;body ng-app&gt;</code></pre>
<p>ng-app=””除了接管区域，还会自动生成根作用域($rootScope)</p>
<pre><code class="html">&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1589611921666.png" alt="过程1" class="lazyload"></p>
<pre><code class="html">&lt;p&gt;姓名1：{{name}}&lt;/p&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1589612077497.png" alt="过程2" class="lazyload"></p>
<ul>
<li>初始化数据</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;AngularJS实现&lt;/title&gt;
&lt;/head&gt;
&lt;body ng-app ng-init=&quot;name=&#39;Tom&#39;&quot;&gt; &lt;!-- ng-init初始化数据 --&gt;
  &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
  &lt;p&gt;姓名1：{{name}}&lt;/p&gt;
  &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
  &lt;p&gt;姓名2：{{name}}&lt;/p&gt;
  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/angular.js/1.2.29/angular.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1589612507494.png" alt="过程3" class="lazyload"></p>
<h3 id="2、依赖注入"><a href="#2、依赖注入" class="headerlink" title="2、依赖注入"></a>2、依赖注入</h3><ul>
<li>依赖对象：完成某个特定的功能需要某个对象才能实现，这个对象就是依赖对象。</li>
<li>依赖注入：依赖的对象以形参的形式被注入进来使用，这种方式就是依赖注入。</li>
<li>Angular的<code>$scope</code>对象就是依赖对象，并且是依赖注入的形式进行使用。</li>
<li>回调函数的event的就是依赖对象</li>
<li>回调函数有形参就是依赖注入</li>
</ul>
<p>补：</p>
<p>开发的两种方式：</p>
<ul>
<li>命令式<ul>
<li>更加注重的是执行的过程</li>
<li>更像考试的解答题</li>
</ul>
</li>
<li>声明式<ul>
<li>更加注重的是执行的结果</li>
<li>声明式是对命令的局部包装</li>
<li>更像选择题或填空题</li>
</ul>
</li>
</ul>
<p>eg：数组中每一项加10</p>
<pre><code class="javascript">var arr = [1,2,3,4,5]
var newArr1 = []
// 命令式
for(var i = 0; i &lt; arr.length; i++){
    var value = arr[i] + 10
    newArr1.push(value)
}
console.log(newArr1)
// 声明式
var newArr2 = arr.map(function(item, index){
    return item + 10
})
console.log(newArr2)</code></pre>
<h2 id="三、三个重要对象"><a href="#三、三个重要对象" class="headerlink" title="三、三个重要对象"></a>三、三个重要对象</h2><h3 id="1、作用域与控制器"><a href="#1、作用域与控制器" class="headerlink" title="1、作用域与控制器"></a>1、作用域与控制器</h3><ul>
<li>作用域对象<ul>
<li>一个JS实例对象，ng-app指令默认会创建一个根作用域对象($rootScope)</li>
<li>它的属性和方法与页面中的指令或表达式是关联的</li>
</ul>
</li>
<li>控制器<ul>
<li>用来控制AngularJS应用数据的实例对象</li>
<li>ng-controller：指定控制器构造函数，Angular会自动new此函数创建控制器对象</li>
<li>同时Angular还有创建一个新的域对象$scope，它是$rootScope的子对象</li>
<li>在控制器函数中声明<code>$scope</code>形参，Angular会自动将<code>$scope</code>传入</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;AngularJS实现&lt;/title&gt;
&lt;/head&gt;
&lt;body ng-app ng-init=&quot;age=12&quot;&gt;
  &lt;div ng-controller=&quot;MyController&quot;&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;姓&quot; ng-model=&quot;firstName&quot;&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;名&quot; ng-model=&quot;lastName&quot;&gt;
    &lt;p&gt;姓名1：{{firstName+'-'+lastName}}&lt;/p&gt;
    &lt;p&gt;姓名2：{{getName()}}&lt;/p&gt;
    {{age}}
  &lt;/div&gt;
  &lt;div&gt;
    {{firstName}}   &lt;!-- 不能显示 --&gt;
  &lt;/div&gt;
  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/angular.js/1.2.29/angular.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    function MyController($scope){ // 形参必须是$scope
      // console.log($scope)
      // console.log(this instanceof MyController)
      $scope.firstName = &#39;lu&#39;
      $scope.lastName = &#39;wang&#39;
      $scope.getName = function(){
        return $scope.firstName + &#39; &#39; + $scope.lastName
        // return this.firstName + &#39; &#39; + this.lastName
      }
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1589613477087.png" alt="作用域" class="lazyload"></p>
<h3 id="2、模块和控制器"><a href="#2、模块和控制器" class="headerlink" title="2、模块和控制器"></a>2、模块和控制器</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;AngularJS实现&lt;/title&gt;
&lt;/head&gt;
&lt;body ng-app=&quot;myApp&quot;&gt;   &lt;!--指向模块对象的名字--&gt;
  &lt;div ng-controller=&quot;MyController&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&#39;empName&#39;&gt;
    &lt;p&gt;员工名字1：{{empName}}&lt;/p&gt;
  &lt;/div&gt;
  &lt;div ng-controller=&quot;MyController2&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&#39;empName&#39;&gt;
    &lt;p&gt;员工名字2：{{empName}}&lt;/p&gt;
  &lt;/div&gt;
  &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/angular.js/1.5.5/angular.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // console.log(angular)
    /* // 创建模块对象
    var myModule = angular.module(&quot;myApp&quot;, [])
    // 生成作用域对象
    myModule.controller(&#39;MyController&#39;, function($scope){
      $scope.empName = &#39;Tom&#39;
    })
    myModule.controller(&#39;MyController2&#39;, function($scope){
      $scope.empName = &#39;Jack&#39;
    }) */
    // 优化 链式调用
    /* &lt;angular.module(&quot;myApp&quot;, [])
          .controller(&#39;MyController&#39;, function($scope){  // 返回值是模块对象
            $scope.empName = &#39;Tom&#39;
          })
          .controller(&#39;MyController2&#39;, function($scope){ // 隐式声明依赖注入
            $scope.empName = &#39;Jack&#39;
          }) */
      // 但是，由于js代码压缩之后形参会用其他字母abcd代替，会造成angular解析不了，解决方案：
      &lt;angular.module(&quot;myApp&quot;, [])
          .controller(&#39;MyController&#39;, [&#39;$scope&#39;, function($scope){ // 显式声明依赖注入
            $scope.empName = &#39;Tom&#39;
          }])
          .controller(&#39;MyController2&#39;, [&#39;$scope&#39;, function($scope){
            $scope.empName = &#39;Jack&#39;
          }])
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="四、两个页面语法"><a href="#四、两个页面语法" class="headerlink" title="四、两个页面语法"></a>四、两个页面语法</h2><h3 id="1、表达式"><a href="#1、表达式" class="headerlink" title="1、表达式"></a>1、表达式</h3><ul>
<li>使用Angular表达式：<ul>
<li>语法：</li>
<li>作用：显示表达式的结果数据</li>
<li>注意：表达式中引用的变量必须是当前域对象有的属性(包括其原型属性)</li>
</ul>
</li>
<li>操作的数据<ul>
<li>基本类型数据：Number/String/Boolean</li>
<li>undefined, Infinity,NaN,null解析为空串””，不显示任何效果</li>
<li>对象的属性或方法</li>
<li>数组</li>
</ul>
</li>
</ul>
<h3 id="2、常用指令"><a href="#2、常用指令" class="headerlink" title="2、常用指令"></a>2、常用指令</h3><ul>
<li>Angular指令<ul>
<li>Angular为HTML页面扩展的：自定义标签属性或标签</li>
<li>与Angular的作用域对象(scope)交互，扩展页面的动态表现力</li>
</ul>
</li>
<li>常用指令<ul>
<li>ng-app：</li>
<li>ng-model</li>
<li>ng-init</li>
<li>ng-click</li>
<li>ng-controller</li>
<li>ng-bind</li>
<li>ng-repeat</li>
<li>ng-show</li>
<li>ng-hide</li>
<li>ng-class</li>
<li>ng-style</li>
<li>ng-mouseenter</li>
<li>ng-mouseleave</li>
</ul>
</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1、我的笔记"><a href="#1、我的笔记" class="headerlink" title="1、我的笔记"></a>1、我的笔记</h3><p>功能：在文本输入区域写文本，下方显示可输入剩余字符量；保存能够将文本保存，这样点击读取的时候文本能接着在文本输入区域显示，点删除删除</p>
<h3 id="2、我的备忘录"><a href="#2、我的备忘录" class="headerlink" title="2、我的备忘录"></a>2、我的备忘录</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/06/04/ES/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="ES和模块化学习笔记" class="lazyload">
                    <h1>ES和模块化学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年06月04日</a>
            <a><i class="nexmoefont icon-areachart"></i>12.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 60 分钟</a>
        </div>

        <article>
            
                <h2 id="一、理解ES"><a href="#一、理解ES" class="headerlink" title="一、理解ES"></a>一、理解ES</h2><ol>
<li><p>全称: ECMAScript</p>
<ul>
<li>它是一种由ECMA组织(前身为欧洲计算机制造商协会)制定和发布的脚本语言规范</li>
<li>我们学习的JavaScript就是ECMA的实现，但属于ECMAScript和JavaScript平时表达同一个意思</li>
</ul>
</li>
<li><p>JS包含三个部分：</p>
<ul>
<li><p>ECMAScript(js基础、核心)</p>
</li>
<li><p>扩展–&gt;浏览器端</p>
<ul>
<li>BOM(浏览器对象模型)</li>
<li>DOM(文档对象模型)</li>
</ul>
</li>
<li><p>扩展–&gt;服务器端</p>
<ul>
<li>Node.js</li>
</ul>
</li>
</ul>
</li>
<li><p>ES的几个重要版本</p>
<ul>
<li>ES5：09年发布</li>
<li><strong>ES6(ES2015)</strong>:15年发布，也称为ECMA2015——重点</li>
<li>ES7(ES2016):16年发布，也称为ECMA2016（变化不大）</li>
</ul>
</li>
</ol>
<h2 id="二、ES5"><a href="#二、ES5" class="headerlink" title="二、ES5"></a>二、ES5</h2><h3 id="1、严格模式"><a href="#1、严格模式" class="headerlink" title="1、严格模式"></a>1、严格模式</h3><ul>
<li><p>理解</p>
<ul>
<li>运行模式: 正常(混杂)模式与严格模式</li>
<li>这种模式使得JavaScript在更严格的语法条件下运行</li>
</ul>
</li>
<li><p>目的/作用: </p>
<ul>
<li>使得Javascript在更严格的条件下运行</li>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用</p>
<ul>
<li>在全局或函数的第一条语句定义为：<code>use strict</code></li>
<li>如果浏览器不支持，只解析为一条简单的语句，没有任何副作用</li>
</ul>
</li>
<li><p>语法和行为改变</p>
<ul>
<li>声明定义变量必须用var</li>
<li>禁止自定义的函数中的this关键字指向全局对象(window)</li>
<li>创建eval作用域, 更安全</li>
<li>对象不能有重名的属性</li>
</ul>
<pre><code class="html">&lt;script&gt;
  &#39;use strict&#39;
  var username = &#39;luwang&#39;
  // name = &#39;luwang&#39; 在严格模式下不用var声明变量会报错
  console.log(username)

  function Person(name, age){
    this.name = name
    this.age = age
  }
  new Person(&#39;luwang&#39;, 23)
  // Person(&#39;luwang&#39;, 23) //没有new会报错

  var str = &#39;web&#39;
  eval(&#39;var str = &quot;HTML&quot;; alert(str)&#39;) // HTML
  alert(str) // web 即开启严格模式之后不会污染全局作用域

  var obj = {
    username: &#39;luwang&#39;,
    username: &#39;luwang&#39;  // 定义重名了
  }
&lt;/script&gt;</code></pre>
</li>
</ul>
<h3 id="2、JSON对象"><a href="#2、JSON对象" class="headerlink" title="2、JSON对象"></a>2、JSON对象</h3><ul>
<li>作用: 用于在json对象/数组与js对象/数组相互转换</li>
<li><code>JSON.stringify(obj/arr)</code> js对象(数组)转换为json对象(数组)</li>
<li><code>JSON.parse(json)</code> json对象(数组)转换为js对象(数组)<pre><code class="html">&lt;script&gt;
var obj = {username: &#39;wallleap&#39;}
obj = JSON.stringify(obj)
console.log(typeof obj)
obj = JSON.parse(obj)
console.log(typeof obj)
&lt;/script&gt;</code></pre>
</li>
</ul>
<h3 id="3、Object扩展"><a href="#3、Object扩展" class="headerlink" title="3、Object扩展"></a>3、Object扩展</h3><p>ES5给Object扩展了一些静态方法，常用的两个：</p>
<ul>
<li><p><code>Object.create(prototype[, descriptors])</code>: 创建一个新的对象</p>
<ul>
<li><p>作用：以指定对象为原型创建新的对象</p>
</li>
<li><p>为新的对象指定新的属性, 并对属性进行描述</p>
<ul>
<li><code>value</code>: 指定值</li>
<li><code>writable</code> : 标识当前属性值是否是可修改的, 默认为<code>false</code></li>
<li><code>configurable</code>：标识当前属性是否可以被删除，默认为<code>false</code></li>
<li><code>enumerable</code>：标识当前属性是否能用for in枚举，默认为<code>false</code></li>
</ul>
<pre><code class="html">&lt;script&gt;
  var obj = {username: &#39;luwang&#39;, age:23}
  var obj1 = {}
  obj1 = Object.create(obj, {  // obj的属性为obj1的原型
    sex: {
      value: &#39;男&#39;,
      writable: true,  // 默认false
      configurable: true,
      enumerable: true
    }
  })
  console.log(obj1.sex)
  obj1.sex = &#39;nan&#39;
  console.log(obj1.sex)
  delete obj1.sex
  console.log(obj1)
  for(var i in obj1){
    console.log(i)
  }
&lt;/script&gt;</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>Object.defineProperties(object, descriptors)</code>: 为指定对象定义扩展多个属性</p>
<ul>
<li><strong>get方法</strong> : 用来得到当前属性值的回调函数</li>
<li><strong>set方法</strong> : 用来监视当前属性值变化的回调函数</li>
</ul>
<pre><code class="html">&lt;script&gt;
  var obj = {username: &#39;luwang&#39;, age:23}
  var obj1 = {}
  var obj2 = {firstName: &#39;lu&#39;, lastName: &#39;wang&#39;}
  Object.defineProperties(obj2, {
    fullName: { // 此方法在原型中
      get: function(){ // 获取扩展属性的值
        console.log(&#39;get方法被调用&#39;)
        return this.firstName + &#39; &#39; + this.lastName
      },
      set: function(data){ // 监听扩展属性，当扩展属性发生变化的时候会自动调用，自动调用后会讲变化的值作为实参注入到set函数
        console.log(&#39;set方法被调用，&#39;, data)
        var names = data.split(&#39; &#39;) // 根据空格拆分为数组
        this.firstName = names[0]
        this.lastName = names[1]
      }
    }
  })
  console.log(obj2.fullName) // get会自动调用 
  obj2.fullName = &#39;lu wang&#39;  
  console.log(obj2.fullName)
&lt;/script&gt;</code></pre>
<p>console.log(obj2)   fullName</p>
<p>惰性求值：点击才给值(什么时候要什么时候给)，会再次调用get方法</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1589786198022.png" alt="惰性求值" class="lazyload"></p>
<ul>
<li>什么时候调用：<ul>
<li>get方法：获取扩展属性值的时候get方法自动调用</li>
<li>set方法：监听</li>
</ul>
</li>
<li>存储器属性：setter，getter一个用来存值，一个用来取值</li>
</ul>
</li>
</ul>
<p>对象本身也有两个方法</p>
<ul>
<li>get propertyName(){}</li>
<li>set propertyName(){}</li>
</ul>
<pre><code class="html">&lt;script&gt;
  var obj = {
    firstName: &#39;lu&#39;, 
    lastName: &#39;wang&#39;,
    get fullName(){
      return this.firstName + &#39; &#39; + this.lastName
    },
    set fullName(data){
      var names = data.split(&#39; &#39;)
      this.firstName = names[0]
      this.lastName = names[1]
    }
  }
  console.log(obj)
  obj.fullName = &#39;lu wang&#39;
  console.log(obj.fullName)
&lt;/script&gt;</code></pre>
<h3 id="4、Array扩展"><a href="#4、Array扩展" class="headerlink" title="4、Array扩展"></a>4、Array扩展</h3><ul>
<li><p>Array.prototype.indexOf(value) : 得到值在数组中的第一个下标</p>
</li>
<li><p>Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</p>
</li>
<li><p><strong>Array.prototype.forEach(function(item, index){}) : 遍历数组</strong></p>
</li>
<li><p><strong>Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组</strong></p>
</li>
<li><p><strong>Array.prototype.filter(function(item, index){}) : 遍历过滤出一个子数组，返回条件为true的值</strong></p>
<pre><code class="javascript">var arr = [2,4,5,1,6,7,4,3,9]
console.log(arr.indexOf(4))
console.log(arr.lastIndexOf(4))
arr.forEach(function(item, index){
    console.log(item, index)
})
var arr1 = arr.map(function(item, index){
    return item + 10
})
console.log(arr, arr1)
arr.filter(fuction(item, index){
    return item &gt; 3
})</code></pre>
</li>
</ul>
<h3 id="5、Function扩展"><a href="#5、Function扩展" class="headerlink" title="5、Function扩展"></a>5、Function扩展</h3><p>this，强制绑定使用call和bind</p>
<p>eg:</p>
<pre><code class="javascript">var obj = {username: &#39;luwang&#39;}
function foo(){
    console.log(this)   
}
foo() // this--&gt;Window 全局
// call和apply不传参的时候是一样的
foo.call(obj) // this--&gt;{username: &#39;luwang&#39;} obj对象
foo.apply(obj) // this--&gt;{username: &#39;luwang&#39;} obj对象
// bind的特点： 绑定完this不会立即调用当前的函数，而是将函数返回
// var bar = foo.bind(obj)
// bar()
foo.bind(obj)()


// 传入参数的形式
var obj1 = {age: 23}
function fun(data){
    console.log(this, data)
}
fun(22) // Window  22
// call直接从第二个参数开始，依次传入
fun.call(obj1, 21) // {age: 23} 21
// 第二参数必须是数组，传入放在数组里
fun.apply(obj1, [20]) // {age: 23} 20

// bind传参的方式通call一样
fun.bind(obj1, 18)()</code></pre>
<ul>
<li><p><code>Function.prototype.bind(obj)</code></p>
<ul>
<li>将函数内的this绑定为obj, 并将函数返回</li>
</ul>
</li>
<li><p>面试题: 区别bind()与call()和apply()?</p>
<ul>
<li><p><code>fn.bind(obj)</code> : 指定函数中的this, 并返回函数(不会立即调用)，一般用在回调函数绑定其他对象的this</p>
<pre><code class="javascript">var obj = {username: &#39;luwang&#39;}
setTimeout(function(){
    console.log(this) // Window
}, 1000)
setTimeout(function(){
    console.log(this) // Window
}.bind(obj), 1000)</code></pre>
</li>
<li><p><code>fn.call(obj)</code>: 指定函数中的this,并调用函数</p>
</li>
<li><p><code>fn.apply(obj)</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="6、Date扩展"><a href="#6、Date扩展" class="headerlink" title="6、Date扩展"></a>6、Date扩展</h3><ul>
<li>Date.now() : 得到当前时间值</li>
</ul>
<h2 id="三、ES6"><a href="#三、ES6" class="headerlink" title="三、ES6"></a>三、ES6</h2><h3 id="1、2个新的关键字"><a href="#1、2个新的关键字" class="headerlink" title="1、2个新的关键字"></a>1、2个新的关键字</h3><ul>
<li>块作用域：ES5中没有(只有全局和函数作用域)，ES6有</li>
</ul>
<ol>
<li><p><strong>let</strong></p>
<ul>
<li><p>作用：与var相似，用于声明一个变量</p>
</li>
<li><p>特点</p>
<ul>
<li>在块作用域内有效</li>
<li>不能重复声明</li>
<li>不会预处理，不存在变量提升</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li><p>循环遍历加监听</p>
<pre><code class="html">&lt;br/&gt;&lt;button&gt;按钮1&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;
&lt;button&gt;按钮2&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;
&lt;button&gt;按钮3&lt;/button&gt;
&lt;script&gt;
    var btns = document.getElementsByTagName(&#39;button&#39;)
    for(var i = 0; i &lt; btns.length; i++){
        var btn = btns[i]
        btn.onclick = function(){
            alert(i)
        }
    }
    /*
     * 一直会显示3
     * 点击事件对应的是回调函数，回调函数又称勾子函数，回调函数会被放到事件队列中，等主线程上的代码执行完毕之后再通过钩子一样的形式，勾出来执行
     * 以前的方式是通过闭包，立即执行函数(自己的作用域)
    */
    for(var i = 0; i &lt; btns.length; i++){
      var btn = btns[i]
      ;(function(i){  // 声明的形参
        btn.onclick = function(){
        alert(i)
      }
      })(i)   // 传的实参
    }
    /*
    * 闭包利用的是函数作用域的特点
    * 因此可以直接使用let
    */
    for(let i = 0; i &lt; btns.length; i++){ // let，在块作用域内有效
      var btn = btns[i]
      btn.onclick = function(){
        alert(i)
      }
    }
&lt;/script&gt;</code></pre>
</li>
<li><p>使用let代替var是趋势</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>const</strong></p>
<ul>
<li><p>作用：定义一个常量</p>
</li>
<li><p>特点</p>
<ul>
<li>不能修改</li>
<li>其他特点同let</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>保存不用改变的数据</li>
</ul>
<pre><code class="javas">const PI = 3.1415926</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="2、变量-对象-的解构赋值"><a href="#2、变量-对象-的解构赋值" class="headerlink" title="2、变量(对象)的解构赋值"></a>2、变量(对象)的解构赋值</h3><ul>
<li><p>理解：从对象或数组中提取数据，并赋值给多个变量</p>
</li>
<li><p>将包含多个数据的对象(数组)一次赋值给多个变量</p>
</li>
<li><p>数据源: 对象/数组</p>
</li>
<li><p>目标: {a, b}/[a, b]</p>
</li>
<li><p>对象的解构赋值：<code>let {n, a} = {n:&#39;tom&#39;, a:12}</code> 把对象中的值赋值出来(根据属性名key)</p>
</li>
<li><p>数组的解构赋值：<code>let[a, b] = [1, &#39;luwang&#39;]</code> (根据下标)</p>
</li>
<li><p>用途：给多个形参赋值</p>
<pre><code class="javascript">let obj = {
    username: &#39;luwang&#39;,
    age: 23
}
// let username = obj.username
// let age = obj.age
// console.log(username, age)
// let {username, age} = obj // 对象，因此需要以对象的形式来接收 只需要一个就写一个，不需要按顺序
// console.log(username, age)
let {age} = obj
console.log(age)

let arr = [1, 3, 5,&#39;abc&#39;, true]
// let [a, b, c, d, e] = arr
// console.log(a, b, c, d, e)
// let [a, b] = arr
// console.log(a, b)
let [,,a, b] = arr
console.log(a, b)

function foo({username, age}){ // {username, age} = obj
    console.log(username, age)
}
foo(obj)</code></pre>
</li>
</ul>
<h3 id="3、各种数据类型的扩展"><a href="#3、各种数据类型的扩展" class="headerlink" title="3、各种数据类型的扩展"></a>3、各种数据类型的扩展</h3><ul>
<li><p>字符串</p>
<ul>
<li><strong>模板字符串</strong> <ul>
<li>作用: 简化字符串的拼接</li>
<li>模板字符串必须用``，波浪线那个</li>
<li>变化的部分使用${xxx}定义</li>
</ul>
</li>
</ul>
<pre><code class="javascript">let obj = {username: &#39;luwang&#39;, age: 23}
/*
* 之前的写法：简单拼串
* 缺点：可能会拼错，效率低。比如，url携带10个参数，动态拼起来
*/
let str = &#39;My name is &#39; + obj.username + &#39;, age is &#39;+ obj.age
console.log(str)
/*
* ES6提供的模板字符串
*/
str = `My name is ${obj.username} age is ${obj.age}`</code></pre>
<ul>
<li><code>includes(str)</code> : 判断是否包含指定的字符串</li>
<li><code>startsWith(str)</code>: 判断是否以指定字符串开头</li>
<li><code>endsWith(str)</code> : 判断是否以指定字符串结尾</li>
<li><code>repeat(count)</code>: 重复指定次数</li>
</ul>
<pre><code class="javascript">let str = &#39;asdfghjkklqwrtyuiopzxcvbnm123467890&#39;
console.log(str.includes(&#39;t&#39;)) // true
console.log(str.includes(&#39;abc&#39;)) // false
console.log(str.startsWith(&#39;a&#39;)) // true
console.log(str.endsWith(&#39;0&#39;)) // true
console.log(str.repeat(2)) // asdfghjkklqwrtyuiopzxcvbnm123467890asdfghjkklqwrtyuiopzxcvbnm123467890</code></pre>
</li>
</ul>
<ul>
<li><p>数值扩展</p>
<ul>
<li>二进制与八进制表示法：二进制用0b，八进制用0o</li>
<li><code>Number.isFinite(i)</code>：判断是否是有限大的数字</li>
<li><code>Number.isNaN(i)</code>：判断是否是NaN</li>
<li><code>Number.isInteger(i)</code>：判断是否是整数</li>
<li><code>Number.parseInt(str)</code>：将字符串转换为对应的数值</li>
<li><code>Math.trunc(i)</code>：直接去除小数部分</li>
</ul>
<pre><code class="javascript">console.log(0b1010)
console.log(0o12)
console.log(Number.isFinite(Infinity))
console.log(Number.isNaN(NaN))
console.log(Number.isInteger(123.1))
console.log(Number.isInteger(123.0))
console.log(Number.parseInt(&#39;123abc123&#39;)) // 123
console.log(Number.parseInt(&#39;a123abc123&#39;)) // NN
console.log(Math.trunc(123.123)) // 123</code></pre>
</li>
</ul>
<ul>
<li><p>对象</p>
<ul>
<li><p><strong>简化的对象写法</strong></p>
<ul>
<li>省略同名的属性值</li>
<li>省略方法的function</li>
</ul>
<pre><code class="JavaScript">let name = &#39;Tom&#39;;
let age = 12;
/* 正常情况 */
let obj = {
    name: name,
    age: age，
    getName: function(){
        retrun this.name
    }
}
console.log(obj)
/* key和value相同，可以省略 */
let person = {
    name,  // 同名的属性可以不写
    age,
    setName (name) { // 可以省略函数的function
        this.name = name
    }
}</code></pre>
</li>
<li><p><code>Object.assign(target, source1, source2..)</code>: 将源对象的属性复制到目标对象上</p>
</li>
</ul>
<pre><code class="javascript">let obj = {}
let obj1 = {username:&#39;a&#39;, age: 20}
let obj2 = {sex: &#39;男&#39;}
// Object.assign(obj, obj1)
// console.log(obj) // {username: &quot;a&quot;, age: 20}
Object.assign(obj, obj1, obj2)
console.log(obj) // {username: &quot;a&quot;, age: 20, sex: &quot;男&quot;}</code></pre>
<ul>
<li><code>Object.is(v1, v2)</code> : 判断2个数据是否完全相等</li>
</ul>
<pre><code class="javascript">console.log(0 == -0) // true
console.log(NaN == NaN) //false
console.log(Object.is(0, -0)) // false
console.log(Object.is(NaN, NaN)) // true</code></pre>
<ul>
<li><strong>proto</strong>属性 : 隐式原型属性.ES6中能直接操作<code>__proto__</code>属性</li>
</ul>
<pre><code class="javascript">let obj = {}
let obj1 = {salary: 5000000}
obj.__proto__ = obj1
console.log(obj)
console.log(obj.salary)</code></pre>
</li>
</ul>
<ul>
<li><p>数组</p>
<ul>
<li><code>Array.from(v)</code> : 将伪数组对象或可遍历对象转换为真数组</li>
<li><code>Array.of(v1, v2, v3)</code> : 将一系列值转换成数组</li>
<li><code>find(function(value, index, arr){return true})</code> : 找出第一个满足条件返回true的元素</li>
<li><code>findIndex(function(value, index, arr){return true})</code>: 找出第一个满足条件返回true的元素下标</li>
</ul>
<pre><code class="html">&lt;button&gt;測試1&lt;/button&gt;&lt;br&gt;
&lt;button&gt;測試2&lt;/button&gt;&lt;br&gt;
&lt;button&gt;測試3&lt;/button&gt;
&lt;script&gt;
  let btns = document.getElementsByTagName(&#39;button&#39;)
  // 偽數組 不能使用forEach(數組的方法)
  Array.from(btns).forEach(function(item, index){
    console.log(item)
  })

  let arr = Array.of(1, 4, &#39;abc&#39;, true)
  console.log(arr)

  let arr2 = [2,3,4,2,5,7,3,6]
  console.log(arr2.find(function(item, index){
    return item &gt; 4
  }))
  console.log(arr2.findIndex(function(item, index){
    return item &gt; 4
  }))
&lt;/script&gt;</code></pre>
</li>
</ul>
<ul>
<li><p>函数</p>
<ul>
<li><strong>箭头函数</strong><ul>
<li>用来定义匿名函数</li>
<li>基本语法:<ul>
<li>没有参数: () =&gt; console.log(‘xxxx’)   箭头前的()不能省略</li>
<li>一个参数: i =&gt; i+2  可以省略</li>
<li>大于一个参数: (i,j) =&gt; i+j  ()不能省略</li>
<li>函数体不用大括号: 默认返回结果</li>
<li>函数体如果有多个语句, 需要用{}包围</li>
</ul>
</li>
<li>使用场景: 多用来定义回调函数</li>
<li>特点：<ul>
<li>简洁</li>
<li>箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候所处的对象就是它的this</li>
<li>扩展理解：箭头函数的this看外层是否有函数<ul>
<li>箭头外层有函数，this是外层函数的this</li>
<li>箭头外层无函数，this是window</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="javascript">let fun = function(){console.log(&#39;fun&#39;)}
fun()
// 1、没有形参
let fun1 = () =&gt; console.log(&#39;fun1&#39;)
fun1()

// 2、只有一个形参
let fun2 = (a) =&gt; console.log(a)
// 可省略() let fun2 = a =&gt; console.log(a)
fun2(&#39;aaa&#39;)

// 3、两个及两个以上的形参
let fun3 = (x,y) =&gt; console.log(x, y)
fun3(1, 2)

// I、函数体只有一条语句或表达式，{}可以省略--&gt;会自动返回语句执行的结果或表达式的结果
let foo = (x, y) =&gt; x + y
// let foo = (x, y) =&gt; {return x + y}
console.log(foo(1, 3))

// II、函数体不止一条语句或者表达式， {}不可以省略
let foo2 = (x, y) =&gt; {
    console.log(x, y)
    return x + y
}
console.log(foo2(3, 5))

// 箭头函数的this
&lt;br/&gt;&lt;button id=&quot;btn1&quot;&gt;按钮1&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;
&lt;button id=&quot;btn2&quot;&gt;按钮2&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;
&lt;button id=&quot;btn3&quot;&gt;按钮3&lt;/button&gt;
&lt;script&gt;
    let btn1 = document.getElementById(&#39;btn1&#39;)
    let btn2 = document.getElementById(&#39;btn2&#39;)
    let btn3 = document.getElementById(&#39;btn3&#39;)
    btn1.onclick = function(){
      console.log(this) // &lt;button id=&quot;btn1&quot;&gt;按钮1&lt;/button&gt;
    }
    btn2.onclick = () =&gt; {
      console.log(this)  // Window
    }
    let obj = {
      name: &#39;箭头函数&#39;,
      getName: function(){
        btn3.onclick = () =&gt; {
          console.log(this) // {name: &quot;箭头函数&quot;, getName: ƒ}
        }
      }
    }
    obj.getName()
    let obj1 = {
      name: &#39;箭头函数&#39;,
      getName: () =&gt; {
        btn3.onclick = () =&gt; {
          console.log(this) // Window
        }
      }
    }
    obj.getName()
&lt;/script&gt;</code></pre>
</li>
</ul>
<ul>
<li><p><strong>3点运算符/点点点运算符</strong></p>
<ul>
<li>rest(可变)参数<ul>
<li>通过形参左侧的…来表达, 取代arguments的使用</li>
<li>比arguments灵活，只能是最后部分形参参数<ul>
<li>arguments是伪数组，有length，但是没有数组的一般方法，不能使用forEach遍历</li>
<li>callee是arguments的一个属性，等于函数本身，递归的时候可以写为：<code>arguments.callee()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="javascript">// arguments
function foo(a, b){
  console.log(arguments)
  // arguments.callee() 调用自身，相当于foo(参数)
  /* arguments.forEach(function(item, index){ // 会报错，伪数组并没有数组的一般方法
      console.log(item, index)
  }) */
}
foo(2,5)</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1590476357564.png" alt="参数" class="lazyload"></p>
<pre><code class="javascript">// 点点点运算符
function foo(...value){
  console.log(arguments)
  console.log(value) // 就是一个正常的数组
  value.forEach(function(item, index){
    console.log(item, index)
  })
}
foo(2,5)

function foo(a, ...value){// ...value只能放在最后面
  console.log(arguments)
  // arguments.callee()
  console.log(value)    // 使用的时候不用加...
  value.forEach(function(item, index){
    console.log(item, index)
  })
}
foo(2, 3, 5, 7) // 最前面的就是a，value就不包括它了</code></pre>
</li>
</ul>
<ul>
<li><p>第二种用法——扩展运算符</p>
<ul>
<li>可以分解出数组或对象中的数据</li>
</ul>
<pre><code class="javascript">let arr = [1, 6]
let arr1 = [2, 3, 4, 5]
arr = [1, ...arr1, 6]
console.log(arr)    // (6) [1, 2, 3, 4, 5, 6]  数组
console.log(...arr) // 1 2 3 4 5 6  每项值</code></pre>
</li>
</ul>
<ul>
<li><p><strong>形参的默认值</strong></p>
<ul>
<li>定义形参时指定其默认的值</li>
<li>当不传入参数的时候默认使用形参里的默认值</li>
</ul>
<pre><code class="javascript">// 定义一个点的坐标的构造函数
function Point(x, y){
  this.x = x
  this.y = y
}
let point = new Point(50, 20)
console.log(point) // Point {x: 50, y: 20}
// 忘记传参
let point1 = new Point()
console.log(point1) // Point {x: undefined, y: undefined}

/* 
* 因此会有需求，在忘记传参的时候使用默认值
* 在形参的位置赋默认值
*/
function Point(x = 0, y = 0){
  this.x = x
  this.y = y
}
let point = new Point(50, 20)
console.log(point) // Point {x: 50, y: 20}
// 忘记传参，使用默认值
let point1 = new Point()
console.log(point1) // Point {x: 0, y: 0}</code></pre>
</li>
</ul>
<h3 id="4、深度克隆"><a href="#4、深度克隆" class="headerlink" title="4、深度克隆"></a>4、深度克隆</h3><ul>
<li><p>拷贝数据：</p>
<ul>
<li>基本数据类型<ul>
<li>拷贝后会生成一份新的数据</li>
<li>修改拷贝以后的数据不会影响原数据</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>拷贝后不会生成新的数据，而是拷贝的引用</li>
<li>修改拷贝以后的数据会影响原来的数据</li>
</ul>
</li>
</ul>
<pre><code class="javascript">// 基本數據類型
let str = &#39;abcd&#39;
let str2 = str
console.log(str, str2)
str2 = &#39;&#39;
console.log(str, str2)

// 引用數據類型
let obj = {username: &#39;kobe&#39;, age:39}
let obj1 = obj
console.log(obj, obj1)
obj1.username = &#39;wade&#39;
console.log(obj, obj1)
let arr = [1,4,{username:&#39;kobe&#39;,age:39}]
let arr2 = arr
arr2[0] = &#39;abcd&#39;
console.log(arr, arr2)</code></pre>
</li>
</ul>
<ul>
<li><p>拷贝数据的方法</p>
<ul>
<li>直接赋值给一个变量    // 浅拷贝(浅克隆)——能影响</li>
<li><code>Object.assign()</code>     // 浅拷贝</li>
</ul>
<pre><code class="javascript">let obj = {username: &#39;kobe&#39;}
let obj2 = Object.assign(obj)
console.log(obj, obj2)
obj2.username = &#39;wade&#39;
console.log(obj, obj2)</code></pre>
<ul>
<li><code>Array.prototype.concat()</code>   //浅拷贝</li>
</ul>
<pre><code class="javascript">let arr = [1, 4, {username: &#39;kobe&#39;}]
let testArr = [&#39;ce&#39;, &#39;shi&#39;]
// let arr2 = arr.concat(testArr)
let arr2 = arr.concat()
console.log(arr, arr2)
arr2[1] = &#39;a&#39;
console.log(arr, arr2)
arr2[2].username = &#39;wade&#39;
console.log(arr, arr2)</code></pre>
<ul>
<li><code>Array.prototype.slice()</code>   // 浅拷贝</li>
</ul>
<pre><code class="javascript">let arr = [1, 4, {username: &#39;kobe&#39;}]
let arr2 = arr.slice()
arr2[2].username = &#39;wade&#39;
console.log(arr, arr2)</code></pre>
<ul>
<li><code>JSON.parse(JSON.stringify())</code>   // 深拷贝(深度克隆)——修改不影响引用类型的原数据。<ul>
<li>拷贝的数据里不能有函数(处理不了)，先是将数据转为了JSON格式，字符串对应js中的只有对象和数组，没有函数</li>
</ul>
</li>
</ul>
<pre><code class="javascript">let arr = [1, 4, {username: &#39;kobe&#39;}]
let arr2 = JSON.stringify(arr)
arr2 = JSON.parse(arr2)
arr2[2].username = &#39;wade&#39;
console.log(arr, arr2)</code></pre>
</li>
<li><p>浅拷贝</p>
<ul>
<li>特点：拷贝的是引用，修改拷贝以后的数据会影响原来的数据，使得原数据不安全</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li>特点：拷贝的时候生成新数据，修改拷贝以后的数据不会影响原数据</li>
</ul>
</li>
<li><p>这两个都是针对对象/数组来说的</p>
</li>
<li><p>思考：如何实现深度拷贝？</p>
<ul>
<li><p>拷贝的数据里有对象/数组，即使有对象/数组可以继续遍历对象、数组，拿到里边的每一项值，直到拿到的是基本数据类型，然后再去复制(拷贝的数据里不能有对象/数组)</p>
</li>
<li><p>知识点储备</p>
<ul>
<li>如何判断数据类型<ol>
<li><code>typeof</code>返回的数据类型： String、Number、boolean、undefined、Object、Function</li>
<li><code>Object.prototype.toString.call(obj)</code>—&gt;<code>Object.prototype.toString.call(data).slice(8, -1)</code></li>
</ol>
</li>
</ul>
<pre><code class="javascript">let result = &#39;abc&#39; // [object String]
result = null // [object Null]
result = [1, &#39;a&#39;] // test-demo.html:17 [object Array]
// console.log(Object.prototype.toString.call(result))
// console.log(typeof Object.prototype.toString.call(result)) // 返回的是string
// 因此可以用下面这种方式显示数据类型
console.log(Object.prototype.toString.call(result).slice(8, -1))
</code></pre>
<ul>
<li><p>for in 循环</p>
<ul>
<li>用于循环对象，枚举出来的是属性名</li>
</ul>
<pre><code class="javascript">let obj = {username: &#39;kobe&#39;, age: 39}
for(let i in obj){
  console.log(i) // username age
}</code></pre>
<ul>
<li>循环数组时，枚举的是下标</li>
</ul>
<pre><code class="javascript">let arr = [1,3,&#39;abc&#39;]
for(let i in arr){
  console.log(i) // 0 1 2
}</code></pre>
</li>
</ul>
</li>
<li><p>实现深度克隆</p>
</li>
</ul>
<pre><code class="javascript">// 定义检测数据类型的功能函数
function checkType(target){
  return Object.prototype.toString.call(target).slice(8, -1)
}
console.log(checkType([1,2,&#39;a&#39;]))
// 实现深度克隆--&gt;对象/数组
function clone(target){
  // 1.判断拷贝的数据类型
  let result, targetType = checkType(target)
  if(targetType === &#39;Object&#39;){
    // 2.初始化数据，对象/数组/其他类型仍不改变
    result = {}
  }else if(targetType === &#39;Array&#39;){
    result = []
  }else{
    return target
  }
  // 3.遍历目标数据
  for(let i in target){
    // 遍历数据结构的每一项值
    let value = target[i] // key、下标都可以用[]
    // 判断目标结构里的每一值是否存在数组/对象
    if(checkType(value) === &#39;Object&#39; || checkType(value) === &#39;Array&#39;){// 对象、数组中还嵌套了对象数组
      // 继续遍历获取到的value值
      result[i] = clone(value)
    }else{ // 获取到的value值是基本数据类型或函数
      result[i] = value
    }
  }
  return result
}
let arr = [1,2,{username: &#39;kobe&#39;}]
let arr2 = clone(arr)
console.log(arr, arr2)
arr2[2].username = &#39;abdc&#39;
console.log(arr, arr2)

let obj = {username: &#39;luwang&#39;, age: 23}
let obj2 = clone(obj)
console.log(obj, obj2)
obj2.username = &#39;LUWANG&#39;
console.log(obj, obj2)</code></pre>
</li>
</ul>
<h3 id="7、class类"><a href="#7、class类" class="headerlink" title="7、class类"></a>7、class类</h3><ul>
<li><p>通过class定义类，实现类的继承</p>
<ul>
<li><p>回顾：原型、构造函数、构造函数+原型——继承</p>
<pre><code class="javascript">function Person(name, age){
  this.name = name
  this.age = age
}
let person = new Person(&#39;kobe&#39;, 39)
console.log(person)</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591769869983.png" alt="继承" class="lazyload"></p>
</li>
</ul>
</li>
<li><p>在类中通过 constructor() 定义构造方法(相当于构造函数)</p>
<pre><code class="javascript">// 定義一個人物的類
class Person{
 // 类的构造方法
  constructor(name, age){
    this.name = name
    this.age = age
  }
  // 类的一般方法
  showMe(){
    console.log(this.name)
  }
}
let person = new Person(&#39;kobe&#39;, 39)
console.log(person)
person.showName()</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591770059566.png" alt="继承" class="lazyload"></p>
</li>
<li><p>一般方法: xxx () {}</p>
</li>
<li><p>用extends来定义子类（实现累的继承）</p>
</li>
<li><p>用super()来调用父类的构造方法</p>
</li>
<li><p>子类方法自定义: 将从父类中继承来的方法重新实现一遍（重写从父类继承的一般方法）</p>
<pre><code class="javascript">// 定義一個人物的類
class Person{
  constructor(name, age){
    this.name = name
    this.age = age
  }
  showMe(){
    console.log(&#39;調用父類的方法&#39;)
    console.log(this.name, this.age)
  }
}
let person = new Person(&#39;kobe&#39;, 39)
person.showMe()

// 子類
class StarPerson extends Person{
  constructor(name, age, salary){
    super(name, age) // 調用父類的構造方法
    this.salary = salary
  }
  showMe(){
    console.log(&#39;子類重寫的方法&#39;)
    console.log(this.name, this.age, this.salary)
  }
}
let p1 = new StarPerson(&#39;wade&#39;, 36, 10000000)
console.log(p1)
p1.showMe()</code></pre>
</li>
<li><p>js中没有方法重载(方法名相同, 但参数不同)的语法</p>
</li>
</ul>
<h3 id="4、set-Map容器结构"><a href="#4、set-Map容器结构" class="headerlink" title="4、set/Map容器结构"></a>4、set/Map容器结构</h3><ul>
<li><p>容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法</p>
</li>
<li><p>任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数)</p>
</li>
<li><p><strong>Set的特点</strong>: 保存多个value, value是不重复 ====&gt;数组元素去重</p>
</li>
<li><p><strong>Map的特点</strong>: 保存多个key–value, key是不重复, value是可以重复的</p>
</li>
<li><p>API</p>
<ul>
<li>Set容器：无序不可重复的多个value的集合体<ul>
<li><code>Set()</code></li>
<li><code>Set(arr)</code> //arr是一维数组</li>
<li><code>add(value)</code></li>
<li><code>delete(value)</code></li>
<li><code>clear()</code></li>
<li><code>has(value)</code></li>
<li><code>size</code></li>
<li>Map容器：无序的key、不重复的多个key-value的集合体</li>
</ul>
</li>
<li><code>Map()</code></li>
<li><code>Map(arr)</code>//arr是二维数组</li>
<li><code>set(key, value)</code></li>
<li><code>get(key)</code></li>
<li><code>delete(key)</code></li>
<li><code>clear()</code></li>
<li><code>has(key)</code></li>
<li><code>size</code></li>
</ul>
<pre><code class="javascript">// let set = new Set()
let set = new Set([1,2,4,5,2,3,6]) // 重复的会去除
console.log(set)
set.add(7)
console.log(set.size, set)
console.log(set.has(8))
console.log(set.has(7))
set.delete(7)
console.log(set.size, set)
set.clear()
console.log(set.size, set)

// let map = new Map()
let map = new Map([[&#39;username&#39;, &#39;aaa&#39;], [&#39;age&#39;, 35], [&#39;sex&#39;, &#39;female&#39;]]) // 二维数组，且只能有两值(一个是key，一个是value)
map.set(&#39;other&#39;, &#39;shuoming&#39;)
console.log(map.size, map)
map.delete(&#39;other&#39;)
console.log(map)
console.log(map.has(&#39;username&#39;))
map.clear()
console.log(map)</code></pre>
</li>
</ul>
<h3 id="5、for–of循环"><a href="#5、for–of循环" class="headerlink" title="5、for–of循环"></a>5、for–of循环</h3><ul>
<li>可以遍历任何容器（Set、Map）</li>
</ul>
<pre><code class="javascript">let set = new Set([1, 2, 4, 3, 4, 5]) 
for(let i of set){
  console.log(i)
}

// 可以用Set给数组去重
let arr = [1,2,4,5,5,6,2]
let arr1 = arr
arr = [] // 保留数组类型
let set = new Set(arr1)
for(let i of set){
  arr.push(i)
}
console.log(arr)</code></pre>
<ul>
<li>数组</li>
<li>对象</li>
<li>伪/类对象</li>
<li>字符串</li>
<li>可迭代的对象</li>
</ul>
<h3 id="6、Promise对象"><a href="#6、Promise对象" class="headerlink" title="6、Promise对象"></a>6、Promise对象</h3><ul>
<li><p>理解：</p>
<ul>
<li>Promise对象代表了某个将要发生的事件（通常是一个异步操作）</li>
<li>ES6的Promise是一个构造函数，用来生成promise实例</li>
</ul>
<ul>
<li><p>解决<code>回调地狱</code>(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差)；有了promise对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数（回调地狱）</p>
</li>
<li><p>能以同步编码的方式实现异步调用</p>
</li>
<li><p>在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise</p>
</li>
<li><p>promise对象的3个状态：</p>
<ul>
<li>pending：初始化状态</li>
<li>fullfilled：成功状态</li>
<li>rejected：失败状态</li>
</ul>
</li>
<li><p>应用：</p>
<ul>
<li>使用promise实现超时处理</li>
<li>使用promise封装处理Ajax请求</li>
</ul>
<pre><code>let request = new XMLHttpRequest()
request.responseType = &#39;json&#39;
request.open(&quot;GET&quot;, url)
request.send()</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>ES6中定义实现API(使用Promise基本步骤): </p>
<pre><code>// 1. 创建promise对象
let promise = new Promise((resolve, reject) =&gt; { 
      // 初始化promise状态为pending
  // 执行异步操作 
  if(异步操作成功) { // 调用成功的回调
    resolve(result);     // 修改promise状态为fullfilled
  } else { // 调用失败的回调
    reject(errorMsg);   // 修改promise的状态为rejected
  } 
}) 
// 2. 调用promise对象的then()
promise.then(function(
  result =&gt; console.log(result), 
  errorMsg =&gt; alert(errorMsg)
))</code></pre><p>例子：</p>
<pre><code class="javascript">// 1、创建promise对象
let promise = new Promise((resolve, reject) =&gt; {
  // 初始化promise状态  pending： 初始化
  console.log(&#39;11111111&#39;)
  // 执行异步操作，通常是发送Ajax请求，开启定时器
  setTimeout(() =&gt; {
    console.log(&#39;3333333&#39;)
    // 根据异步任务的返回结果去修改promise的状态
    // 异步任务执行成功
    // resolve(&#39;哈哈，&#39;) // 修改promise的状态为 fullfilled：成功
    // 异步任务执行失败
    reject(&#39;555, &#39;) // 修改promise的状态为 rejsected： 失败
  }, 2000)
})
console.log(&#39;222222222&#39;)
// 2. 调用promise对象的then()
promise
  .then((data) =&gt; { // 成功的回调
    console.log(data, &#39;成功了~~~&#39;)
  }, (error) =&gt; { // 失败的回调
    console.log(error, &#39;失败了……&#39;)
})</code></pre>
<p>实例：新闻、新闻的评论：只发新闻的内容；在接着根据新闻的id拿取这个新闻下的评论</p>
<p>1、打开ES5_6_7中code目录中的es_server</p>
<p>2、输入命令<code>node bin/www</code></p>
<p>3、浏览器中访问 <a href="http://localhost:3000/news" target="_blank" rel="noopener">http://localhost:3000/news</a> ，能够获取数据</p>
<pre><code class="javascript">// 定义获取新闻的功能函数
function getNews(url){
  let promise = new Promise((resolve, reject) =&gt; {
    // 状态：初始化
    // 执行异步任务
    let xmlHttp = new XMLHttpRequest()
    // 绑定监听readyState
    /*xmlHttp.onreadystatechange = function(){
      if(xmlHttp.readyState === 4 &amp;&amp; xmlHttp.status == 200){
        // 请求成功
        console.log(xmlHttp.responseText)
        // 修改状态
        resolve(xmlHttp.responseText) // 修改promise的状态为成功
      }else{
        // 请求失败
        reject(&#39;暂时没有新闻内容&#39;)
      }
    } --&gt; 逻辑有问题*/
    xmlHttp.onreadystatechange = function(){
      if(xmlHttp.readyState === 4){
        if(xmlHttp.status == 200){
          // 请求成功
          // console.log(xmlHttp.responseText)
          // 修改状态
          resolve(xmlHttp.responseText) // 修改promise的状态为成功
        }else{
          // 请求失败
          reject(&#39;暂时没有新闻内容&#39;)
        }
      }
    }

    // open 设置请求得方式以及url
    xmlHttp.open(&#39;GET&#39;, url)
    // 发送
    xmlHttp.send()
  })
  return promise
}
getNews(&#39;http://localhost:3000/news?id=2&#39;)
  .then((data) =&gt; {
    console.log(data)
    // 发送请求获取评论内容准备url
    let commentsUrl = JSON.parse(data).commentsUrl
    let url = &#39;http://localhost:3000&#39; + commentsUrl
    // 发送请求
    return getNews(url)
  },(error) =&gt; {
    console.log(error)
  })
  .then((data) =&gt; {
    console.log(data)
  }, () =&gt; {

})</code></pre>
</li>
</ul>
<h3 id="8、Symbol属性"><a href="#8、Symbol属性" class="headerlink" title="8、Symbol属性"></a>8、Symbol属性</h3><ul>
<li>前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境</li>
<li>概念：ES6中添加了一种<strong>原始数据类型symbol</strong>(已有的数据类型：String、Number、boolean、null、undefined、对象)</li>
<li>特点<ul>
<li>Symbol属性对应的值是<strong>唯一</strong>的，解决命名冲突问题</li>
<li>Symbol值<strong>不能</strong>与<strong>其他数据</strong>进行<strong>计算</strong>，包括与字符串拼串</li>
<li>for in、for of遍历时不会遍历symbol属性</li>
</ul>
</li>
<li>使用<ul>
<li>调用Symbol函数得到symbol值</li>
<li>传参标识</li>
<li>内置Symbol值<ul>
<li>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值（查看官方文档）</li>
<li>对象的Symbol.iterator属性，指向该对象的默认遍历器方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="javascript">// 创建symbol属性值
let symbol = Symbol()
console.log(symbol)  // Symbol()
let obj = {username:&#39;kobe&#39;, age:39}
// 可以添加symbol属性——但是得用另一种方式
obj.gender = &#39;男&#39;
obj[symbol] = &#39;hello&#39;
console.log(obj)  // {username: &quot;kobe&quot;, age: 39, gender: &quot;男&quot;, Symbol(): &quot;hello&quot;}

//let symbol2 = Symbol()
//let symbol3 = Symbol()
// 并不相同，值是唯一的
//console.log(symbol2, symbol3, symbol2 == symbol3)  // Symbol() Symbol() false

// 可以传参，这样就能很明显看出不同了
let symbol2 = Symbol(&#39;one&#39;)
let symbol3 = Symbol(&#39;two&#39;)
console.log(symbol2, symbol3, symbol2 == symbol3)  // Symbol(one) Symbol(two) false

// 可以用来定义常量
const Person_key = Symbol(&#39;person_key&#39;)
console.log(Person_key)  // Symbol(person_key)






// 等同于在指定的数据结构上部署了Iterator接口
// 当使用for of去遍历某一个数据结构的时候，首先去找Symbol.itearator，找到了就去遍历，没有找到就不能遍历
let targetData = {
  [Symbol.iterator]: function(){
    let nextIndex = 0
    return{
      next: function(){
        return nextIndex &lt; this.length ? {value: this[nextIndex++], done: false} : {value: undefined, done: true}
      }
    }
  }
}
// 使用三点运算符、解构赋值，默认会去调用Iterator接口
let arr2 = [1,6]
let arr3 = [2,3,4,5]
arr2 = [1,...arr3,6]
console.log(arr2)
let [a,b] = arr2
console.log(a,b)
</code></pre>
<h3 id="9、Iterator遍历器"><a href="#9、Iterator遍历器" class="headerlink" title="9、Iterator遍历器"></a>9、Iterator遍历器</h3><ul>
<li><p>概念：iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制</p>
</li>
<li><p>作用：</p>
<ul>
<li>为各种数据结构，提供一个统一的、简便的访问接口</li>
<li>使得数据机构的成员能够按照某种次序排列</li>
<li>ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费</li>
</ul>
</li>
<li><p>工作原理</p>
<ul>
<li>创建一个指针对象(遍历器对象)，指向数据结构的起始位置</li>
<li>第一次调用next方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员</li>
<li>没调用next方法返回的是一个包含value和done的对象<code>{value: 当前成员的值, done: 布尔值}</code><ul>
<li>value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束</li>
<li>当遍历结束的时候返回的value值是undefined，done值为false</li>
</ul>
</li>
</ul>
</li>
<li><p>原生具备Iterator接口的数据(可用for…of遍历)</p>
</li>
<li><p>扩展理解</p>
<ul>
<li>当数据结构上部署了Symbol.iterator接口，该数据就是可以用for of遍历</li>
<li>当使用for of去遍历目标数据的时候，该数据会自动去找Symbol.iterator属性（Symbol.iterator属性指向对象的默认遍历器方法）<ul>
<li>Array</li>
<li>arguments</li>
<li>set容器</li>
<li>map容器</li>
<li>String</li>
<li>……</li>
</ul>
</li>
</ul>
<pre><code class="javascript">// 模拟指针对象(遍历器对象)
function myIterator(arr){// Iterator接口
let nextIndex = 0 // 记录指针的位置
  return{
    next: function(){// 遍历器对象
      return nextIndex &lt; arr.length ? {value: arr[nextIndex++], done: false} : {value: undefined, done: true}
    }
  }
}
// 准备一个数据
let arr =[1,4,65,&#39;abc&#39;]

let iteratorObj = myIterator(arr)
console.log(iteratorObj.next()) // {value: 1, done: false}
console.log(iteratorObj.next()) // {value: 4, done: false}
console.log(iteratorObj.next()) // {value: 65, done: false}
console.log(iteratorObj.next()) // {value: &quot;abc&quot;, done: false}
console.log(iteratorObj.next()) // {value: undefined, done: true}

// 将iterator接口部署到指定的数据类型上，可以使用for of去循环遍历
// 数组、字符串、argument、set容器、map容器
for(let i of arr){
  console.log(i)
}// 1 4 65 abc

let str = &#39;abcdefg&#39;
for(let i of str){
  console.log(i)
}// a b c d e f g

function fun(){
  for(let i of arguments){
    console.log(i)
  }
}
fun(1,4,5,&#39;abc&#39;) // 1 4 5 abc

// let obj = {username:&#39;kobe&#39;, age: 39}
// for(let i of obj){
//   console.log(i)
// }// Uncaught TypeError: obj is not iterable 不可迭代</code></pre>
</li>
</ul>
<h3 id="10、Generator函数"><a href="#10、Generator函数" class="headerlink" title="10、Generator函数"></a>10、Generator函数</h3><ul>
<li><p>概念</p>
<ul>
<li>ES6提供的解决异步编程的方案之一</li>
<li>Generator函数是一个状态机，内部封装了不同状态的数据</li>
<li>用来生成遍历器对象</li>
<li>可暂停函数(惰性求值)，yield可暂停，next方法可启动。每次返回的是yield后的表达式结果</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>function 与函数名之间有一个星号</p>
</li>
<li><p>内部用yield表达式来定义不同的状态</p>
<p>例如：</p>
<pre><code class="javascript">function* generatorExample(){
    let result = yield &#39;hello&#39;  // 状态值为hello
    yield &#39;generator&#39;  // 状态值为generator
}</code></pre>
</li>
<li><p>generator函数返回的是指针对象，而不会执行函数内部逻辑</p>
<pre><code class="javascript">function* generatorExample(){
    console.log(&#39;开始执行&#39;)
    let result = yield &#39;hello&#39;  // 状态值为hello
    yield &#39;generator&#39;  // 状态值为generator
}
generatorExample() // 调用并不会执行函数内部逻辑</code></pre>
</li>
<li><p>调用next方法函数，内部逻辑开始执行，遇到yield表达式停止，返回<code>{value: yield后的表达式结果/return后的返回结果(如果没写，返回undefined),done: boolean值(后面还有返回false，没有返回true)}</code></p>
<pre><code class="javascript">function* generatorExample(){
    console.log(&#39;开始执行&#39;)
    let result = yield &#39;hello&#39;  // 状态值为hello，会执行，停止 测试yield console.log(&#39;会执行&#39;)
    console.log(&#39;下次调用next执行&#39;)
    yield &#39;generator&#39;  // 状态值为generator
    console.log(&#39;下次调用next执行&#39;)
    return &#39;返回的结果&#39;
}
let MG = generatorExample() // 返回的是指针对象
console.log(MG.next()) // 执行，遇到yield停止
console.log(MG.next(&#39;可以拿到这个值&#39;)) // 再次调用next，往下执行，可以传参
console.log(MG.next()) // 再次调用next，往下执行，返回true</code></pre>
</li>
<li><p>再次调用next方法会从上一次停止时的yield处开始，直到最后</p>
</li>
<li><p>yield语句返回结果通常为undefined，当调用next方法时传参内容会作为启动时yield语句的返回值</p>
</li>
<li><p>补充</p>
<ul>
<li>对象的Symbol.iterator属性，指向遍历器对象</li>
</ul>
<pre><code class="javascript">let obj = {username:&#39;kobe&#39;, age: 39}
obj[Symbol.iterator] = function* myTest(){
    yield 1
    yield 2
    yield 3
}
for(let i of obj){
  console.log(i)
}</code></pre>
<ul>
<li>案例<ul>
<li>需求<ul>
<li>发送ajax请求获取新闻内容</li>
<li>新闻内容获取成功后再次发送请求，获取对应的新闻评论内容</li>
<li>新闻内容获取失败则不需要再次发送请求</li>
</ul>
</li>
<li>启动服务器——进入es_server目录，cmd输入命令<code>node bin/www</code></li>
</ul>
</li>
</ul>
<pre><code class="javascript">// 要比使用Promise更好
function getNews(url){
  $.get(url, function(data){ // 前面引入了jQuery
    console.log(data)
    let url = &#39;http://localhost:3000&#39; + data.commentsUrl
    SX.next(url) // 放在这里也可以往下移，并且这里参数传输更方便
  })
}
function* sendXml(){
  let url = yield getNews(&#39;http://localhost:3000/news?id=3&#39;) // 如果这里出错，后面评论也不会再执行了
  yield getNews(url)
}
// 获取遍历器对象
let SX = sendXml()
SX.next()</code></pre>
</li>
</ul>
</li>
</ul>
<p>​        </p>
<h2 id="四、模块化"><a href="#四、模块化" class="headerlink" title="四、模块化"></a>四、模块化</h2><h3 id="1、理解"><a href="#1、理解" class="headerlink" title="1、理解"></a>1、理解</h3><ul>
<li><p>什么是模块?</p>
<ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li>
</ul>
</li>
<li><p>一个模块的组成</p>
<ul>
<li>数据—&gt;内部的属性</li>
<li>操作数据的行为—&gt;内部的函数</li>
</ul>
</li>
<li><p>模块化</p>
<ul>
<li>编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目</li>
</ul>
</li>
<li><p>模块化的进化过程</p>
<ul>
<li><p>全局function模式 : </p>
<ul>
<li>编码: 全局变量/函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591870404488.png" alt="全局变量" class="lazyload"></p>
<ul>
<li><p>namespace模式 : </p>
<ul>
<li>编码: 将数据/行为封装到对象中</li>
<li>解决: 命名冲突(减少了全局变量)</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
</li>
</ul>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591870416611.png" alt="Namespace" class="lazyload"></p>
<ul>
<li><p>IIFE模式/增强</p>
<ul>
<li><p>IIFE : 立即调用函数表达式—&gt;匿名函数自调用</p>
</li>
<li><p>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</p>
</li>
</ul>
</li>
</ul>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591870442007.png" alt="IIFE" class="lazyload"></p>
<ul>
<li><p>引入依赖: 通过函数形参来引入依赖模块</p>
<pre><code>(function(window, module2){
  var data = &#39;atguigu.com&#39;
  function foo() {
     module2.xxx()
     console.log(&#39;foo()&#39;+data)
  }
  function bar() {
     console.log(&#39;bar()&#39;+data)
  }

  window.module = {foo}
})(window, module2)</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591870456267.png" alt="IIFE增强" class="lazyload"></p>
</li>
<li><p>模块化好处</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591870477012.png" alt="模块化好处" class="lazyload"></p>
<ul>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
</li>
<li><p>页面引入加载script</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/1591871174402.png" alt="引入js" class="lazyload"></p>
<ul>
<li>问题<ul>
<li>请求过多</li>
<li>依赖模糊</li>
<li>难以维护</li>
</ul>
</li>
</ul>
</li>
<li><p>模块化规范</p>
<ul>
<li><p><strong>CommonJS</strong></p>
<ul>
<li><p>Node.js : 服务器端</p>
</li>
<li><p>Browserify : 浏览器端    也称为js的打包工具</p>
</li>
<li><p>基本语法:</p>
<ul>
<li><p>定义暴露模块 : exports</p>
<pre><code>exports.xxx = value
module.exports = value</code></pre><p>引入模块 : require</p>
<pre><code>var module = require(&#39;模块名/模块相对路径&#39;)</code></pre></li>
</ul>
</li>
<li><p>每个文件都可以当作一个模块</p>
</li>
<li><p>引入模块发生在什么时候?</p>
<ul>
<li>Node : 运行时, 动态同步引入</li>
<li>Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), <pre><code>运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>*<em>AMD *</em>: 浏览器端，模块的加载时异步的</p>
<ul>
<li><p>require.js</p>
</li>
<li><p>基本语法</p>
<ul>
<li><p>定义暴露模块: define([依赖模块名], function(){return 模块对象})</p>
</li>
<li><p>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</p>
</li>
<li><p>配置: </p>
<pre><code>require.config({
  //基本路径
  baseUrl : &#39;js/&#39;,
  //标识名称与路径的映射
  paths : {
    &#39;模块1&#39; : &#39;modules/模块1&#39;,
    &#39;模块2&#39; : &#39;modules/模块2&#39;,
    &#39;angular&#39; : &#39;libs/angular&#39;,
    &#39;angular-messages&#39; : &#39;libs/angular-messages&#39;
  },
  //非AMD的模块
  shim : {
    &#39;angular&#39; : {
        exports : &#39;angular&#39;
    },
    &#39;angular-messages&#39; : {
        exports : &#39;angular-messages&#39;,
        deps : [&#39;angular&#39;]
    }
  }
})</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>CMD(通用模块定义) : 浏览器端，模块加载是异步的；模块使用时才会加载执行</p>
<ul>
<li><p>sea.js</p>
</li>
<li><p>基本语法</p>
<ul>
<li><p>定义暴露模块: </p>
<pre><code>define(function(require, module, exports){
  通过require引入依赖模块
  通过module/exports来暴露模块
  exports.xxx = value
})</code></pre></li>
<li><p>使用模块seajs.use([‘模块1’, ‘模块2’])</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ES6</strong></p>
<ul>
<li><p>ES6内置了模块化的实现，依赖模块需要编译打包处理</p>
</li>
<li><p>基本语法</p>
<ul>
<li><p>定义暴露模块 : export</p>
<ul>
<li><p>暴露一个对象: </p>
<pre><code>export default 对象</code></pre></li>
<li><p>暴露多个: </p>
<pre><code>export var xxx = value1
export let yyy = value2

var xxx = value1
let yyy = value2
export {xxx, yyy}</code></pre></li>
</ul>
</li>
<li><p>引入使用模块 : import</p>
<ul>
<li><p>default模块:</p>
<pre><code>import xxx  from &#39;模块路径/模块名&#39;</code></pre></li>
<li><p>其它模块</p>
<pre><code>import {xxx, yyy} from &#39;模块路径/模块名&#39;
import * as module1 from &#39;模块路径/模块名&#39;</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>问题: 所有浏览器还不能直接识别ES6模块化的语法  </p>
</li>
<li><p>解决:</p>
<ul>
<li>使用Babel将ES6—&gt;ES5(使用了CommonJS) —-浏览器还不能直接支行</li>
<li>使用Browserify—&gt;打包处理—-浏览器可以运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、CommonJS基于服务器端（Node-js）"><a href="#2、CommonJS基于服务器端（Node-js）" class="headerlink" title="2、CommonJS基于服务器端（Node.js）"></a>2、CommonJS基于服务器端（Node.js）</h3><ul>
<li><p>下载安装Node.js</p>
</li>
<li><p>创建目录结构</p>
<ul>
<li><p>Modules</p>
<ul>
<li>module1.js</li>
<li>module2.js</li>
<li>module3.js</li>
</ul>
</li>
<li><p>app.js</p>
</li>
<li><p>package.json（命令创建,<code>npm init</code>,再输入包名）</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;conmmonjs_node&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;
}</code></pre>
</li>
</ul>
</li>
<li><p>下载第三方模块<code>npm install uniq --save</code></p>
<ul>
<li><p>package.json</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;conmmonjs_node&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;dependencies&quot;:{
        &quot;uniq&quot;: &quot;^1.0.1&quot;
    }
}</code></pre>
</li>
</ul>
</li>
<li><p>模块化编码</p>
<ul>
<li><p>module1.js</p>
<pre><code class="javascript">// module.exports = value 暴露一个对象
module.exports = {
    msg: &#39;module1&#39;,
    foo(){
        console.log(this.msg)
    }
}</code></pre>
</li>
<li><p>module2.js</p>
<pre><code class="javascript">// 暴露一个函数 module.exports = function(){}
module.exports = fuction(){
    console.log(&quot;module2&quot;)
}</code></pre>
</li>
<li><p>module3.js</p>
<pre><code class="javascript">// exports.xxx = value 分别暴露
exports.foo = function(){
    console.log(&#39;foo() module3&#39;)
}
exports.bar = function(){
    console.log(&#39;bar() module3&#39;)
}

exports.arr = [2, 4, 5, 2, 3, 5, 1]</code></pre>
</li>
<li><p>app.js</p>
<pre><code class="javascript">// 将其他的模块汇集到主模块
let uniq = require(&#39;uniq&#39;)

let module1 = require(&#39;./modules/module1&#39;)
let module2 = require(&#39;./modules/module2&#39;)
let module3 = require(&#39;./modules/module3&#39;)

module1.foo()

module2()

module3.foo()
module3.bar()

let result = uniq(module3.arr)
console.log(result)</code></pre>
</li>
</ul>
</li>
<li><p>通过node运行app.js——<code>node app.js</code></p>
</li>
</ul>
<h3 id="3、CommonJS基于浏览器端应用（Browserify）"><a href="#3、CommonJS基于浏览器端应用（Browserify）" class="headerlink" title="3、CommonJS基于浏览器端应用（Browserify）"></a>3、CommonJS基于浏览器端应用（Browserify）</h3><ul>
<li><p>创建项目结构</p>
<ul>
<li><p>js</p>
<ul>
<li>dist //打包生成文件的目录</li>
<li>src //源码所在的目录<ul>
<li>module1.js</li>
<li>module2.js</li>
<li>module3.js</li>
<li>app.js //应用主源文件</li>
</ul>
</li>
</ul>
</li>
<li><p>index.html</p>
</li>
<li><p>package.json</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;browserify-test&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;
}</code></pre>
</li>
</ul>
</li>
<li><p>下载browserify</p>
<ul>
<li><p>全局：<code>npm install browserify -g</code></p>
</li>
<li><p>局部：<code>npm install browserify --save-dev</code></p>
<pre><code class="json">{
    &quot;name&quot;: &quot;browserify-test&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;devDependencies&quot;:{
        &quot;browserify&quot;: &quot;^14.5.0&quot;
    }
}</code></pre>
</li>
</ul>
</li>
<li><p>下载第三方模块<code>npm install uniq --save</code></p>
<ul>
<li><p>package.json</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;browserify-test&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;devDependencies&quot;:{
        &quot;browserify&quot;: &quot;^14.5.0&quot;
    },
    &quot;dependencies&quot;:{
        &quot;uniq&quot;: &quot;^1.0.1&quot;
    }
}</code></pre>
</li>
</ul>
</li>
<li><p>定义模块代码</p>
<ul>
<li><p>module1.js</p>
<pre><code class="javascript">module.exports = {
  foo() {
    console.log(&#39;moudle1 foo()&#39;)
  }
}</code></pre>
</li>
<li><p>module2.js</p>
<pre><code class="javascript">module.exports = function () {
  console.log(&#39;module2()&#39;)
}</code></pre>
</li>
<li><p>module3.js</p>
<pre><code class="javascript">exports.foo = function () {
  console.log(&#39;module3 foo()&#39;)
}

exports.bar = function () {
  console.log(&#39;module3 bar()&#39;)
}</code></pre>
</li>
<li><p>app.js</p>
<pre><code class="javascript">//引用模块
let module1 = require(&#39;./module1&#39;)
let module2 = require(&#39;./module2&#39;)
let module3 = require(&#39;./module3&#39;)

let uniq = require(&#39;uniq&#39;)

//使用模块
module1.foo()
module2()
module3.foo()
module3.bar()

console.log(uniq([1, 3, 1, 4, 3]))</code></pre>
</li>
</ul>
</li>
<li><p>打包处理js：<code>browserify js/src/app.js -o js/dist/bundle.js</code></p>
</li>
<li><p>页面使用引入</p>
<ul>
<li><p>index.html</p>
<pre><code class="html">&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;broserify测试&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="4、AMD规范"><a href="#4、AMD规范" class="headerlink" title="4、AMD规范"></a>4、AMD规范</h3><h4 id="（1）NoAMD"><a href="#（1）NoAMD" class="headerlink" title="（1）NoAMD"></a>（1）NoAMD</h4><ul>
<li><p>项目结构</p>
<ul>
<li>js<ul>
<li>alerter.js</li>
<li>dataService.js</li>
</ul>
</li>
<li>app.js</li>
<li>test1.html</li>
</ul>
</li>
<li><p>文件内容</p>
<ul>
<li><p>dataService.js</p>
<pre><code class="javascript">// 定义一个没有依赖的模块
(function(win){ // 形参可以和实参的名字相同，这里方便区分
    let name = &#39;dataservice.js&#39;
    function getName(){
        return name
    }
    win.dataService = {getName}
})(window) // 实参</code></pre>
</li>
<li><p>alerter.js</p>
<pre><code class="javascript">// 定义一个有依赖的模块
(function(window, dataService){
    let msg = &#39;alerter.js&#39;
    function showMsg(){
        alert(msg + &#39;,&#39; + dataService.getName())
    }
    window.alerter = {showMsg}
})(window, dataService) // 依赖dataService</code></pre>
</li>
<li><p>app.js</p>
<pre><code class="javascript">(function (alerter){
    alerter.showMsg()
})(alerter)</code></pre>
</li>
<li><p>test1.html</p>
<pre><code class="html">&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Modular Demo: 未使用AMD(require.js)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script src=&quot;./js/dataService.js&quot;&gt;&lt;/script&gt; 
&lt;script src=&quot;./js/alerter.js&quot;&gt;&lt;/script&gt; 
&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt; // 下面的分别依赖上面的模块
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="（2）AMD（require-js）"><a href="#（2）AMD（require-js）" class="headerlink" title="（2）AMD（require.js）"></a>（2）AMD（require.js）</h4><ol>
<li><p>下载require.js, 并引入</p>
<ul>
<li>官网: <a href="http://www.requirejs.cn/" target="_blank" rel="noopener">http://www.requirejs.cn/</a></li>
<li>github : <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">https://github.com/requirejs/requirejs</a></li>
<li>将require.js导入项目: js/libs/require.js </li>
</ul>
</li>
<li><p>创建项目结构</p>
</li>
</ol>
<ul>
<li>js<ul>
<li>libs<ul>
<li>require.js</li>
</ul>
</li>
<li>modules<ul>
<li>alerter.js</li>
<li>dataService.js</li>
</ul>
</li>
<li>main.js</li>
</ul>
</li>
<li>index.html</li>
</ul>
<ol start="3">
<li><p>定义require.js的模块代码</p>
<ul>
<li><p>dataService.js</p>
<pre><code class="javascript">// 定义没有依赖的模块
define(function () {
 let msg = &#39;dataService.js&#39;

 function getMsg() {
   return msg.toUpperCase()
 }
 // 暴露模块
 return {getMsg}
})</code></pre>
</li>
<li><p>alerter.js</p>
<pre><code class="javascript">// 定义有依赖的模块
define([&#39;dataService&#39;, &#39;jquery&#39;], function (dataService, $) {
 let msg = &#39;alerter.js&#39;

 function showMsg() {
   $(&#39;body&#39;).css(&#39;background&#39;, &#39;gray&#39;)
   alert(dataService.getMsg() + &#39;, &#39; + msg)
 }

 return {showMsg}
})</code></pre>
</li>
</ul>
</li>
<li><p>应用主(入口)js：main.js</p>
<pre><code class="javascript">(function () {
    //配置
    require.config({
        //基本路径 出发点在根目录下
        baseUrl: &quot;js/&quot;,
        //模块标识名与模块路径映射
        paths: {
            &quot;alerter&quot;: &quot;modules/alerter&quot;,
            &quot;dataService&quot;: &quot;modules/dataService&quot;,
        }
    })
    //引入使用模块
    require( [&#39;alerter&#39;], function(alerter) {
        alerter.showMsg()
    })
})()</code></pre>
</li>
<li><p>页面使用模块：index.html</p>
</li>
</ol>
<pre><code class="html">&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</code></pre>
<hr>
<ol start="6">
<li><p>使用第三方基于require.js的框架(jquery)</p>
<ul>
<li><p>将jquery的库文件导入到项目: </p>
<ul>
<li>js/libs/jquery-1.10.1.js</li>
</ul>
</li>
<li><p>在main.js中配置jquery路径</p>
<pre><code class="javascript">paths: {
   &#39;jquery&#39;: &#39;libs/jquery-1.10.1&#39;  // jQuery定义的返回AMD模块名为小写
}</code></pre>
</li>
<li><p>在alerter.js中使用jquery</p>
<pre><code class="javascript">define([&#39;dataService&#39;, &#39;jquery&#39;], function (dataService, $) {
   var name = &#39;xfzhang&#39;
   function showMsg() {
       $(&#39;body&#39;).css({background : &#39;red&#39;})
       alert(name + &#39; &#39;+dataService.getMsg())
   }
   return {showMsg}
})</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="7">
<li><p>使用第三方不基于require.js的框架(angular/angular-messages)</p>
<ul>
<li><p>将angular.js和angular-messages.js导入项目</p>
<ul>
<li>js/libs/angular.js</li>
<li>js/libs/angular-messages.js</li>
</ul>
</li>
<li><p>在main.js中配置</p>
<pre><code class="javascript">(function () {
 require.config({
   //基本路径
   baseUrl: &quot;js/&quot;,
   //模块标识名与模块路径映射
   paths: {
     //第三方库
     &#39;jquery&#39; : &#39;libs/jquery-1.10.1&#39;,
     &#39;angular&#39; : &#39;libs/angular&#39;,
     &#39;angular-messages&#39; : &#39;libs/angular-messages&#39;,
     //自定义模块
     &quot;alerter&quot;: &quot;modules/alerter&quot;,
     &quot;dataService&quot;: &quot;modules/dataService&quot;
   },
   /*
    配置不兼容AMD的模块
    exports : 指定导出的模块名
    deps  : 指定所有依赖的模块的数组
    */
   shim: {
     &#39;angular&#39; : {
       exports : &#39;angular&#39;
     },
     &#39;angular-messages&#39; : {
       exports : &#39;angular-messages&#39;,
       deps : [&#39;angular&#39;]
     }
   }
 })
 //引入使用模块
 require( [&#39;alerter&#39;, &#39;angular&#39;, &#39;angular-messages&#39;], function(alerter, angular) {
   alerter.showMsg()
   angular.module(&#39;myApp&#39;, [&#39;ngMessages&#39;])
   angular.bootstrap(document,[&quot;myApp&quot;])
 })
})()</code></pre>
</li>
<li><p>页面:</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot;&gt;
 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; ng-model=&quot;username&quot; ng-required=&quot;true&quot;&gt;
 &lt;div style=&quot;color: red;&quot; ng-show=&quot;myForm.username.$dirty&amp;&amp;myForm.username.$invalid&quot;&gt;用户名是必须的&lt;/div&gt;
&lt;/form&gt;</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="5、CMD规范"><a href="#5、CMD规范" class="headerlink" title="5、CMD规范"></a><font color=lightgray>5、CMD规范</font></h3><ol>
<li><p>下载sea.js, 并引入</p>
<ul>
<li>官网: <a href="http://seajs.org/" target="_blank" rel="noopener">http://seajs.org/</a></li>
<li>github : <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">https://github.com/seajs/seajs</a></li>
<li>将sea.js导入项目: js/libs/sea.js </li>
</ul>
</li>
<li><p>创建项目结构</p>
<pre><code>|-js
 |-libs
   |-sea.js
 |-modules
   |-module1.js
   |-module2.js
   |-module3.js
   |-module4.js
   |-main.js
|-index.html</code></pre></li>
<li><p>定义sea.js的模块代码</p>
<ul>
<li><p>module1.js</p>
<pre><code class="javascript">// 没有依赖的模块
define(function (require, exports, module) {
 //内部变量数据
 var data = &#39;atguigu.com&#39;
 //内部函数
 function show() {
   console.log(&#39;module1 show() &#39; + data)
 }

 //向外暴露
 exports.show = show
})</code></pre>
</li>
<li><p>module2.js</p>
<pre><code class="javascript">define(function (require, exports, module) {
 let msg = &#39;module2&#39;
 function bar(){
     console.log(msg)
 }
   module.exports = bar
 /* module.exports = {
   msg: &#39;I Will Back&#39;
 } */
})</code></pre>
</li>
<li><p>module3.js</p>
<pre><code class="javascript">define(function(require, exports, module){
   let data = &#39;module3&#39;
   function fun(){
       console.log(data)
   }
   exports.module3 = {fun}
})
/* define(function (require, exports, module) {
 const API_KEY = &#39;abc123&#39;
 exports.API_KEY = API_KEY
}) */</code></pre>
</li>
<li><p>module4.js</p>
<pre><code class="javascript">define(function(require, exports, module){
   let msg = &#39;module4&#39;
   // 同步引入
   let module2 = require(&#39;./module2&#39;)
   module2()
   // 异步引入
   require.async(&#39;./module3&#39;, function(module3){
       module3.module3.fun()
   })
   function fun2(){
       console.log(msg)
   }
   exports.fun2 = fun2
})
/*define(function (require, exports, module) {
 //引入依赖模块(同步)
 var module2 = require(&#39;./module2&#39;)

 function show() {
   console.log(&#39;module4 show() &#39; + module2.msg)
 }

 exports.show = show
 //引入依赖模块(异步)
 require.async(&#39;./module3&#39;, function (m3) {
   console.log(&#39;异步引入依赖模块3  &#39; + m3.API_KEY)
 })
})*/</code></pre>
</li>
<li><p>main.js : 主(入口)模块</p>
<pre><code class="javascript">define(function (require) {
 let module1 = require(&#39;./module1&#39;)
 console.log(module1.foo())
 let module4 = require(&#39;./module4&#39;)
 module4.fun2()
})
/*define(function (require) {
 var m1 = require(&#39;./module1&#39;)
 var m4 = require(&#39;./module4&#39;)
 m1.show()
 m4.show()
})*/</code></pre>
</li>
</ul>
</li>
<li><p>index.html:</p>
<pre><code>&lt;!--
使用seajs:
 1. 引入sea.js库
 2. 如何定义导出模块 :
   define()
   exports
   module.exports
 3. 如何依赖模块:
   require()
 4. 如何使用模块:
   seajs.use()
--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/libs/sea.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
 seajs.use(&#39;./js/modules/main&#39;)
&lt;/script&gt;</code></pre></li>
</ol>
<p>​       </p>
<h3 id="6、ES6-Babel-Browserify使用教程"><a href="#6、ES6-Babel-Browserify使用教程" class="headerlink" title="6、ES6-Babel-Browserify使用教程"></a><font color=red>6、ES6-Babel-Browserify使用教程</font></h3><ol>
<li><p>定义package.json文件</p>
<pre><code class="json">{
 &quot;name&quot; : &quot;es6-babel-browserify&quot;,
 &quot;version&quot; : &quot;1.0.0&quot;
}</code></pre>
</li>
<li><p>安装babel-cli, babel-preset-es2015和browserify // cli——command line interface</p>
<ul>
<li><code>npm install babel-cli browserify -g</code></li>
</ul>
</li>
</ol>
<ul>
<li><code>npm install babel-preset-es2015 --save-dev</code></li>
<li>preset 预设（将es6转换成es5的所有插件打包）</li>
</ul>
<ol start="3">
<li><p>定义.babelrc文件（babel run control）</p>
<pre><code class="bash">{
 &quot;presets&quot;: [&quot;es2015&quot;]
}</code></pre>
</li>
<li><p>编码</p>
<ul>
<li><p>js/src/module1.js</p>
<pre><code class="JavaScript">// 暴露模块 分别暴露
export function foo() {
 console.log(&#39;module1 foo()&#39;);
}
export let bar = function () {
 console.log(&#39;module1 bar()&#39;);
}
export const DATA_ARR = [1, 3, 5, 1]</code></pre>
</li>
<li><p>js/src/module2.js</p>
<pre><code class="JavaScript">// 统一暴露——常规暴露
let data = &#39;module2 data&#39;

function fun1() {
 console.log(&#39;module2 fun1() &#39; + data);
}

function fun2() {
 console.log(&#39;module2 fun2() &#39; + data);
}

export {fun1, fun2}</code></pre>
</li>
<li><p>js/src/module3.js</p>
<pre><code class="JavaScript">// 默认暴露：可以暴露任意数据类型，暴露什么数据类型接收到的就是什么数据
// export default value
export default() =&gt;{
   console.log(&#39;我是默认暴露的箭头函数&#39;)
} // 只能暴露一个default，因此暴露对象
/* export default {
 name: &#39;Tom&#39;,
 setName: function (name) {
   this.name = name
 }
} */</code></pre>
</li>
<li><p>js/src/app.js</p>
<pre><code class="JavaScript">// 引入其他的模块
// 语法： import xxx from &#39;路径&#39;
import {foo, bar} from &#39;./module1&#39;
import {DATA_ARR} from &#39;./module1&#39;
import {fun1, fun2} from &#39;./module2&#39;

import module3 from &#39;./module3&#39;
/* import person from &#39;./module3&#39; */

// 安装 npm install jquery@1
import $ from &#39;jquery&#39;

$(&#39;body&#39;).css(&#39;background&#39;, &#39;red&#39;)

foo()
bar()
console.log(DATA_ARR);
fun1()
fun2()

module3()
/* person.setName(&#39;JACK&#39;)
console.log(person.name); */</code></pre>
</li>
</ul>
</li>
<li><p>编译</p>
<ul>
<li>使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : <code>babel js/src -d js/lib</code></li>
<li>使用Browserify编译js : <code>browserify js/lib/app.js -o js/lib/bundle.js</code></li>
</ul>
</li>
<li><p>页面中引入测试</p>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;js/lib/bundle.js&quot;&gt;&lt;/script&gt;</code></pre>
</li>
<li><p>引入第三方模块(jQuery)<br>1). 下载jQuery模块: </p>
<ul>
<li><code>npm install jquery@1 --save</code> // @后的是版本，1代表<code>1.x.x</code>中的最新版本</li>
</ul>
<p>2). 在app.js中引入并使用</p>
<pre><code>import $ from &#39;jquery&#39;
$(&#39;body&#39;).css(&#39;background&#39;, &#39;red&#39;)</code></pre></li>
</ol>
<h2 id="五、ES7"><a href="#五、ES7" class="headerlink" title="五、ES7"></a>五、ES7</h2><h3 id="1、async函数-源自ES2017"><a href="#1、async函数-源自ES2017" class="headerlink" title="1、async函数(源自ES2017)"></a>1、async函数(源自ES2017)</h3><ul>
<li><p>概念：真正意义上去解决异步回调的问题，同步流程表达异步操作</p>
</li>
<li><p>本质：Generator的语法</p>
</li>
<li><p>语法：</p>
<pre><code class="javascript">async function foo(){
    await 异步操作;
    await 异步操作;
}</code></pre>
</li>
<li><p>特点：</p>
<ul>
<li>不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行</li>
<li>返回的总是Promise对象，可以用then方法进行下一步操作</li>
<li>async取代Generator函数的<code>*</code>，await取代Generator的yield</li>
<li>语义上更为明确，使用简单，暂时没有任何副作用</li>
</ul>
<pre><code class="javascript">// async基本使用
async function foo(){
  return new Promise(resolve =&gt; {
    // setTimeout(function(){
    //   resolve()
    // }, 2000)
    // 可以写成下方这种
    setTimeout(resolve, 2000)
  })
}
async function test(){
  console.log(&#39;开始执行&#39;, new Date().toTimeString())
  await foo()
  console.log(&#39;执行完毕&#39;, new Date().toTimeString())
}
test()

</code></pre>
</li>
</ul>
<p>  // async里await返回值<br>  function test2(){<br>    return ‘xxx’<br>  }<br>  async function asyncPrint(){<br>    /* let result = await test2()<br>    console.log(result) // 普通函数没有返回值<br>    <em>/<br>    /</em><br>    let result = await Promise.resolve()<br>    console.log(result) // Promise对象成功状态返回undefined<br>    */<br>    let result = await Promise.resolve(‘promise’)<br>    console.log(result) // Promise对象成功状态传参返回参数 promise<br>    result = await Promise.reject(‘失败了……’)<br>    console.log(result) // 失败状态，返回出错，且能将参数返回 Uncaught (in promise) 失败了……</p>
<p>  }<br>  asyncPrint()</p>
<pre><code>
  仍是获取新闻内容案例

  ```javascript
  // async比generator又更简单
  async function getNews(url){
    return new Promise((resolve, reject) =&gt; {
      $.ajax({ // 前面已经引入jQuery
        method: &#39;GET&#39;,
        url,  // 这是ES6中简写
        /* success: function(data){
          resolve()
        },
        error: function(error){
          reject() 
        }*/
        // 简写
        success: data =&gt; resolve(data),
        error: error =&gt; reject(error)

      })
    })
  }
  async function sendXml(){
    let result = await getNews(&#39;http://localhost:3000/news?id=7&#39;)
    console.log(result) // {id: &quot;7&quot;, title: &quot;news title1...&quot;, content: &quot;news content1...&quot;, commentsUrl: &quot;/comments?newsId=7&quot;}
    result = await getNews(&#39;http://localhost:3000&#39; + result.commentsUrl)
    console.log(result)
  }
  sendXml()</code></pre><p>  改进一下，由于这种写法error并不会显示错误信息</p>
<pre><code class="html">  &lt;script src=&quot;./jquery-3.1.0.min.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // async比generator又更简单
    async function getNews(url){
      return new Promise((resolve, reject) =&gt; {
        $.ajax({
          method: &#39;GET&#39;,
          url,  // 这是ES6中简写
          /* success: function(data){
            resolve()
          },
          error: function(error){
            reject() 
          }*/
          // 简写
          success: data =&gt; resolve(data),
          // error: error =&gt; reject(error)
          error: error =&gt; resolve(false) // 不用reject，而是返回false
        })
      })
    }
    async function sendXml(){
      let result = await getNews(&#39;http://localhost:30010/news?id=7&#39;)
      console.log(result) // {id: &quot;7&quot;, title: &quot;news title1...&quot;, content: &quot;news content1...&quot;, commentsUrl: &quot;/comments?newsId=7&quot;}
      if(!result){ // 出错就弹窗
        alert(&#39;暂时没有新闻……&#39;)
      }
      result = await getNews(&#39;http://localhost:3000&#39; + result.commentsUrl)
      console.log(result)
    }
    sendXml()
  &lt;/script&gt;</code></pre>
<h3 id="2、指数运算符-幂"><a href="#2、指数运算符-幂" class="headerlink" title="2、指数运算符(幂): **"></a>2、指数运算符(幂): <code>**</code></h3><p><code>console.log(3 ** 3)</code></p>
<h3 id="3、Array-prototype-includes-value-判断数组中是否包含指定value"><a href="#3、Array-prototype-includes-value-判断数组中是否包含指定value" class="headerlink" title="3、Array.prototype.includes(value): 判断数组中是否包含指定value"></a>3、<code>Array.prototype.includes(value)</code>: 判断数组中是否包含指定value</h3><pre><code class="javascript">let arr = [1,2,3,&#39;abc&#39;]
console.log(arr.includes(&#39;a&#39;))</code></pre>
<ul>
<li><strong>区别方法的2种称谓</strong><ul>
<li>静态(工具)方法<ul>
<li>Fun.xxx = function(){}</li>
</ul>
</li>
<li>实例方法<ul>
<li>所有实例对象 : Fun.prototype.xxx = function(){} //xxx针对Fun的所有实例对象</li>
<li>某个实例对象 : fun.xxx = function(){} //xxx只是针对fun对象 </li>
</ul>
</li>
</ul>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/04/26/jQuery/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="jQuery学习笔记" class="lazyload">
                    <h1>jQuery学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年04月26日</a>
            <a><i class="nexmoefont icon-areachart"></i>15.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 81 分钟</a>
        </div>

        <article>
            
                <ul>
<li>初识jQuery</li>
<li>jQuery的两把利器</li>
<li>使用jQuery核心函数</li>
<li>使用jQuery对象</li>
<li>jQuery对象</li>
<li>练习</li>
</ul>
<h2 id="一、初识jQuery"><a href="#一、初识jQuery" class="headerlink" title="一、初识jQuery"></a>一、初识jQuery</h2><h3 id="1、what"><a href="#1、what" class="headerlink" title="1、what"></a>1、what</h3><ul>
<li><a href="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a></li>
<li>一个优秀的JS函数库</li>
<li>使用了jQuery的网站超过90%中大型WEB项目开发首选</li>
<li>Write Less, Do More!!!</li>
</ul>
<h3 id="2、why"><a href="#2、why" class="headerlink" title="2、why"></a>2、why</h3><ul>
<li>HTML元素选取(选择器)</li>
<li>HTML元素操作</li>
<li>CSS操作</li>
<li>HTML事件处理</li>
<li>JS动画效果</li>
<li>链式调用</li>
<li>读写合一</li>
<li>浏览器兼容</li>
<li>易扩展插件</li>
<li>ajax封装<br>……</li>
</ul>
<blockquote>
<p>封装简化DOM操作(CRUD) / Ajax</p>
<p>强大选择器：方便快速查找DOM元素</p>
<p>隐式遍历(迭代)：一次操作多个元素</p>
<p>读写合一：读数据/写数据用的是一个函数</p>
<p>事件处理、链式调用、DOM操作(CUD)、样式操作……</p>
</blockquote>
<h3 id="3、how"><a href="#3、how" class="headerlink" title="3、how"></a>3、how</h3><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815145128.png" alt="image-20200815145126124" class="lazyload"></p>
<p>(1) 引入库：本地引入、CDN远程引入，测试版、生产版(压缩版)</p>
<p>(2) 使用库：函数(<code>$</code>/<code>jQuery</code>)、对象(<code>$xxx</code>)</p>
<pre><code class="html">&lt;!--
需求: 点击&quot;确定&quot;按钮, 提示输入的值
--&gt;
用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;
&lt;button id=&quot;btn1&quot;&gt;确定(原生版)&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;确定(jQuery版)&lt;/button&gt;
&lt;!--使用原生DOM--&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  window.onload = function () {
    var btn1 = document.getElementById(&#39;btn1&#39;)
    btn1.onclick = function () {
      var username = document.getElementById(&#39;username&#39;).value
      alert(username)
    }
  }
&lt;/script&gt;
&lt;!--使用jQuery实现--&gt;
  &lt;!--本地引入--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.3.js&quot;&gt;&lt;/script&gt;
  &lt;!--远程引入--&gt;
&lt;!--&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.js&quot;&gt;&lt;/script&gt;--&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //绑定文档加载完成的监听
  jQuery(function () {
    var $btn2 = $(&#39;#btn2&#39;)
    $btn2.click(function () { // 给btn2绑定点击监听
      var username = $(&#39;#username&#39;).val()
      alert(username)
    })
  })
  /*
  1. 使用jQuery核心函数: $/jQuery
  2. 使用jQuery核心对象: 执行$()返回的对象
    */
  //新的注释
&lt;/script&gt;</code></pre>
<h2 id="二、jQuery的2把利器"><a href="#二、jQuery的2把利器" class="headerlink" title="二、jQuery的2把利器"></a>二、jQuery的2把利器</h2><ul>
<li>jQuery函数: <code>$</code>/<code>jQuery</code><ul>
<li>jQuery向外暴露的就是jQuery函数, 可以直接使用</li>
<li>当成一般函数使用: <code>$(param)</code><ul>
<li>param是function: 相当于<code>window.onload = function</code>(文档加载完成的监听)</li>
<li>param是选择器字符串: 查找所有匹配的DOM元素, 返回包含所有DOM元素的jQuery对象</li>
<li>param是DOM元素: 将DOM元素对象包装为jQuery对象返回  <code>$(this)</code></li>
<li>param是标签字符串: 创建标签DOM元素对象并包装为jQuery对象返回</li>
</ul>
</li>
<li>当成对象使用: <code>$.xxx</code><ul>
<li><code>each(obj/arr, function(key, value){})</code></li>
<li><code>trim(str)</code></li>
</ul>
</li>
</ul>
</li>
<li>jQuery对象<ul>
<li>包含所有匹配的n个DOM元素的伪数组对象</li>
<li>执行<code>$()</code>返回的就是jQuery对象</li>
<li>基本行为:<ul>
<li><code>length</code>/<code>size()</code>: 得到dom元素的个数</li>
<li><code>[index]</code>: 得到指定下标对应的dom元素</li>
<li><code>each(function(index, domEle){})</code>: 遍历所有dom元素</li>
<li><code>index()</code>: 得到当前dom元素在所有兄弟中的下标</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1、jQuery核心函数"><a href="#1、jQuery核心函数" class="headerlink" title="1、jQuery核心函数"></a>1、jQuery核心函数</h3><ul>
<li><p>简称: jQuery函数(<code>$</code>/<code>jQuery</code>)</p>
</li>
<li><p>jQuery库向外直接暴露的就是<code>$</code>/<code>jQuery</code></p>
</li>
<li><p>引入jQuery库后, 直接使用<code>$</code>即可</p>
<ul>
<li>当函数用: <code>$(xxx)</code></li>
<li>当对象用: <code>$.xxx()</code></li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.3.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //1.  jQuery函数: 直接可用
  console.log($, typeof $) // f(){}
  console.log(jQuery===$) // true
  /*
  (function (window) {
    var jQuery = function () {
      return new xxx()
    }
    window.$ = window.jQuery = jQuery
  })(window)
  */
&lt;/script&gt;</code></pre>
<p>理解</p>
<ul>
<li>即<code>$</code> 或<code>jQuery</code></li>
<li>jQuery定义了这个全局的函数供我们调用</li>
<li>它既可作为一般函数调用, 且传递的参数类型不同/格式不同功能就完全不同</li>
<li>也可作为对象调用其定义好的方法, 此时<code>$</code>就是一个工具对象</li>
</ul>
<p>作为函数调用</p>
<ul>
<li>参数为函数 <code>$(fun)</code></li>
<li>参数为选择器(selector)字符串 <code>$(&quot;#div1&quot;)</code></li>
<li>参数为DOM对象 <code>$(div1Ele)</code></li>
<li>参数为html标签字符串<code>$(&quot;&lt;div&gt;&quot;)</code></li>
</ul>
<p>作为对象使用</p>
<ul>
<li>发送ajax请求的方法<br><code>$.ajax()</code><br><code>$.get()</code><br><code>$.post()</code><br>……</li>
<li>其它工具方法<br><code>$.each()</code><br><code>$.trim()</code><br><code>$.parseJSON()</code><br>……</li>
</ul>
<pre><code class="html">&lt;div&gt;
  &lt;button id=&quot;btn&quot;&gt;测试&lt;/button&gt;
  &lt;br/&gt;
  &lt;input type=&quot;text&quot; name=&quot;msg1&quot;/&gt;&lt;br/&gt;
  &lt;input type=&quot;text&quot; name=&quot;msg2&quot;/&gt;&lt;br/&gt;
&lt;/div&gt;
&lt;!--
1. 作为一般函数调用: $(param)
    1). 参数为函数 : 当DOM加载完成后，执行此回调函数
    2). 参数为选择器字符串: 查找所有匹配的标签, 并将它们封装成jQuery对象
    3). 参数为DOM对象: 将dom对象封装成jQuery对象
    4). 参数为html标签字符串 (用得少): 创建标签对象并封装成jQuery对象
2. 作为对象使用: $.xxx()
    1). $.each() : 隐式遍历数组
    2). $.trim() : 去除两端的空格
--&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求1. 点击按钮: 显示按钮的文本, 显示一个新的输入框
   需求2. 遍历输出数组中所有元素值
   需求3. 去掉&quot;  my atguigu  &quot;两端的空格
   */
  /*需求1. 点击按钮: 显示按钮的文本, 显示一个新的输入框*/
  //1.1). 参数为函数 : 当DOM加载完成后，执行此回调函数
  $(function () { // 绑定文档加载完成的监听
    // 1.2). 参数为选择器字符串: 查找所有匹配的标签, 并将它们封装成jQuery对象
    $(&#39;#btn&#39;).click(function () { // 绑定点击事件监听
      // this是什么? 发生事件的dom元素(&lt;button&gt;)
      // alert(this.innerHTML)
      // 1.3). 参数为DOM对象: 将dom对象封装成jQuery对象
      alert($(this).html())
      // 1.4). 参数为html标签字符串 (用得少): 创建标签对象并封装成jQuery对象
      $(&#39;&lt;input type=&quot;text&quot; name=&quot;msg3&quot;/&gt;&lt;br/&gt;&#39;).appendTo(&#39;div&#39;)
    })
  })
  /*需求2. 遍历输出数组中所有元素值*/
  var arr = [2, 4, 7]
  // 1). $.each() : 隐式遍历数组
  $.each(arr, function (index, item) {
    console.log(index, item)
  })
  // 2). $.trim() : 去除两端的空格
  var str = &#39; my atguigu  &#39;
  // console.log(&#39;---&#39;+str.trim()+&#39;---&#39;)
  console.log(&#39;---&#39;+$.trim(str)+&#39;---&#39;)
&lt;/script&gt;</code></pre>
<h3 id="2、jQuery核心对象"><a href="#2、jQuery核心对象" class="headerlink" title="2、jQuery核心对象"></a>2、jQuery核心对象</h3><ul>
<li><p>简称: jQuery对象</p>
</li>
<li><p>得到jQuery对象: 执行jQuery函数返回的就是jQuery对象</p>
</li>
<li><p>使用jQuery对象: <code>$obj.xxx()</code></p>
</li>
</ul>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.3.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //2. jQuery对象: 执行jQuery函数得到它
  console.log($() instanceof Object) // true
&lt;/script&gt;</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815155511.png" alt="image-20200815155509580" class="lazyload"></p>
<p>理解</p>
<ul>
<li>即执行jQuery核心函数返回的对象</li>
<li>jQuery对象内部包含的是dom元素对象的伪数组(可能只有一个元素)</li>
<li>jQuery对象拥有很多有用的属性和方法, 让程序员能方便的操作dom</li>
</ul>
<p>属性/方法</p>
<ul>
<li><p>基本行为<br><code>size()</code>/<code>length</code><br><code>[index]</code>/<code>get(index)</code><br><code>each()</code><br><code>index()</code></p>
</li>
<li><p>属性</p>
<pre><code>    操作内部标签的属性或值</code></pre></li>
<li><p>CSS</p>
<pre><code>    操作标签的样式</code></pre></li>
<li><p>文档</p>
<pre><code>    对标签进行增删改操作</code></pre></li>
<li><p>筛选</p>
<pre><code>    根据指定的规则过滤内部的标签</code></pre></li>
<li><p>事件</p>
<pre><code>    处理事件监听相关</code></pre></li>
<li><p>效果</p>
<pre><code>    实现一些动画效果</code></pre></li>
</ul>
<pre><code class="html">&lt;button&gt;测试一&lt;/button&gt;
&lt;button&gt;测试二&lt;/button&gt;
&lt;button id=&quot;btn3&quot;&gt;测试三&lt;/button&gt;
&lt;button&gt;测试四&lt;/button&gt;
&lt;!--
1. jQuery对象是一个包含所有匹配的任意多个dom元素的伪数组对象
2. 基本行为
  * size()/length: 包含的DOM元素个数
  * [index]/get(index): 得到对应位置的DOM元素
  * each(): 遍历包含的所有DOM元素
  * index(): 得到在所在兄弟元素中的下标
--&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求:
   需求1. 统计一共有多少个按钮
   需求2. 取出第2个button的文本
   需求3. 输出所有button标签的文本
   需求4. 输出&#39;测试三&#39;按钮是所有按钮中的第几个
   */
  //需求1. 统计一共有多少个按钮
  var $buttons = $(&#39;button&#39;)
  /*size()/length: 包含的DOM元素个数*/
  console.log($buttons.size(), $buttons.length)
  //需求2. 取出第2个button的文本
  /*[index]/get(index): 得到对应位置的DOM元素*/
  console.log($buttons[1].innerHTML, $buttons.get(1).innerHTML)
  //需求3. 输出所有button标签的文本
  /*each(): 遍历包含的所有DOM元素*/
  /*$buttons.each(function (index, domEle) {
    console.log(index, domEle.innerHTML, this)
  })*/
  $buttons.each(function () {
    console.log(this.innerHTML)
  })
  //需求4. 输出&#39;测试三&#39;按钮是所有按钮中的第几个
  /*index(): 得到在所在兄弟元素中的下标*/
  console.log($(&#39;#btn3&#39;).index())  //2
  /*
  1. 伪数组
    * Object对象
    * length属性
    * 数值下标属性
    * 没有数组特别的方法: forEach(), push(), pop(), splice()
   */
  console.log($buttons instanceof Array) // false
  // 自定义一个伪数组
  var weiArr = {}
  weiArr.length = 0
  weiArr[0] = &#39;atguigu&#39;
  weiArr.length = 1
  weiArr[1] = 123
  weiArr.length = 2
  for (var i = 0; i &lt; weiArr.length; i++) {
    var obj = weiArr[i]
    console.log(i, obj)
  }
  console.log(weiArr.forEach, $buttons.forEach) //undefined, undefined
&lt;/script&gt;</code></pre>
<h2 id="三、使用jQuery核心函数"><a href="#三、使用jQuery核心函数" class="headerlink" title="三、使用jQuery核心函数"></a>三、使用jQuery核心函数</h2><h3 id="1、选择器"><a href="#1、选择器" class="headerlink" title="1、选择器"></a>1、选择器</h3><p>(1) 说明</p>
<ul>
<li>选择器本身只是一个有特定语法规则的字符串, 没有实质用处</li>
<li>它的基本语法规则使用的就是CSS的选择器语法, 并对基进行了扩展</li>
<li>只有调用<code>$()</code>, 并将选择器作为参数传入才能起作用</li>
<li><code>$(selector)</code>作用 : 根据选择器规则在整个文档中查找所有匹配的标签的数组, 并封装成jQuery对象返回(用来查找特定页面元素)</li>
</ul>
<p>(2) 分类</p>
<ul>
<li><p>基本选择器(最基本最常用的选择器)</p>
<ul>
<li><code>#id</code>：id选择器</li>
<li><code>element</code>：元素选择器</li>
<li><code>.class</code>：属性选择器</li>
<li><code>*</code>：任意标签</li>
<li><code>selector1,selector2,selectorN</code>：取多个选择器的并集(组合选择器)</li>
<li><code>selector1selector2selectorN</code>：取多个选择器的交集(相交选择器)</li>
</ul>
<pre><code class="html">&lt;div id=&quot;div1&quot; class=&quot;box&quot;&gt;div1(class=&quot;box&quot;)&lt;/div&gt;
&lt;div id=&quot;div2&quot; class=&quot;box&quot;&gt;div2(class=&quot;box&quot;)&lt;/div&gt;
&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;
&lt;span class=&quot;box&quot;&gt;span(class=&quot;box&quot;)&lt;/span&gt;
&lt;br&gt;
&lt;ul&gt;
  &lt;li&gt;AAAAA&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;BBBBB(title=&quot;hello&quot;)&lt;/li&gt;
  &lt;li class=&quot;box&quot;&gt;CCCCC(class=&quot;box&quot;)&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;DDDDDD(title=&quot;hello&quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求:
   1. 选择id为div1的元素
   2. 选择所有的div元素
   3. 选择所有class属性为box的元素
   4. 选择所有的div和span元素
   5. 选择所有class属性为box的div元素
   */
  //1. 选择id为div1的元素
  // $(&#39;#div1&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //2. 选择所有的div元素
  // $(&#39;div&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //3. 选择所有class属性为box的元素
  //$(&#39;.box&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //4. 选择所有的div和span元素
  // $(&#39;div,span&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //5. 选择所有class属性为box的div元素
  //$(&#39;div.box&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //$(&#39;*&#39;).css(&#39;background&#39;, &#39;red&#39;)
&lt;/script&gt;</code></pre>
</li>
</ul>
<ul>
<li><p>层次选择器(查找子元素, 后代元素, 兄弟元素的选择器)</p>
<ul>
<li><code>ancestor descendant</code>：在给定的祖先元素下的后代元素中匹配元素</li>
<li><code>parent &gt; child</code>：在给定的父元素下的子元素中匹配元素</li>
<li><code>prev + next</code>：匹配所有紧接在prev元素后的next元素</li>
<li><code>prev ~ siblings</code>：匹配prev元素之后的所有siblings元素</li>
</ul>
<pre><code class="html">&lt;ul&gt;
  &lt;li&gt;AAAAA&lt;/li&gt;
  &lt;li class=&quot;box&quot;&gt;CCCCC&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;&lt;span&gt;BBBBB&lt;/span&gt;&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;&lt;span class=&quot;box&quot;&gt;DDDD&lt;/span&gt;&lt;/li&gt;
  &lt;span&gt;EEEEE&lt;/span&gt;
&lt;/ul&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求:
   1. 选中ul下所有的的span
   2. 选中ul下所有的子元素span
   3. 选中class为box的下一个li
   4. 选中ul下的class为box的元素后面的所有兄弟元素
   */
  //1. 选中ul下所有的的span
  // $(&#39;ul span&#39;).css(&#39;background&#39;, &#39;yellow&#39;)
  //2. 选中ul下所有的子元素span
  // $(&#39;ul&gt;span&#39;).css(&#39;background&#39;, &#39;yellow&#39;)
  //3. 选中class为box的下一个li
  // $(&#39;.box+li&#39;).css(&#39;background&#39;, &#39;yellow&#39;)
  //4. 选中ul下的class为box的元素后面的所有兄弟元素
  $(&#39;ul .box~*&#39;).css(&#39;background&#39;, &#39;yellow&#39;)
&lt;/script&gt;</code></pre>
</li>
</ul>
<ul>
<li><p>过滤选择器(在原有选择器匹配的元素中进一步进行过滤的选择器)</p>
<ul>
<li>基本<ul>
<li><code>:first</code></li>
<li><code>:last</code></li>
<li><code>:eq(index)</code></li>
<li><code>:lt</code></li>
<li><code>:gt</code></li>
<li><code>:odd</code></li>
<li><code>:even</code></li>
<li><code>:not(selector)</code></li>
<li><code>header</code></li>
<li><code>animated</code></li>
<li><code>focus</code></li>
</ul>
</li>
<li>内容<ul>
<li><code>:contains(text)</code></li>
<li><code>empty</code></li>
<li><code>has(selector)</code></li>
<li><code>parent</code></li>
</ul>
</li>
<li>可见性<ul>
<li><code>:hidden</code></li>
<li><code>:visible</code></li>
</ul>
</li>
<li>属性<ul>
<li><code>[attrbute]</code></li>
<li><code>[attrName=value]</code></li>
<li><code>[attribute!=value]</code></li>
<li><code>[attribute^=value]</code></li>
<li><code>[attribute$=value]</code></li>
<li><code>[attribute*=value]</code></li>
<li><code>[attrSel1][attrSel2][attrSelN]</code></li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;div id=&quot;div1&quot; class=&quot;box&quot;&gt;class为box的div1&lt;/div&gt;
&lt;div id=&quot;div2&quot; class=&quot;box&quot;&gt;class为box的div2&lt;/div&gt;
&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;
&lt;span class=&quot;box&quot;&gt;class为box的span&lt;/span&gt;
&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt;AAAAA&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;BBBBB&lt;/li&gt;
  &lt;li class=&quot;box&quot;&gt;CCCCC&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;DDDDDD&lt;/li&gt;
  &lt;li title=&quot;two&quot;&gt;BBBBB&lt;/li&gt;
  &lt;li style=&quot;display:none&quot;&gt;我本来是隐藏的&lt;/li&gt;
&lt;/ul&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

  /*
   需求:
   1. 选择第一个div
   2. 选择最后一个class为box的元素
   3. 选择所有class属性不为box的div
   4. 选择第二个和第三个li元素
   5. 选择内容为BBBBB的li
   6. 选择隐藏的li
   7. 选择有title属性的li元素
   8. 选择所有属性title为hello的li元素
   */
  //1. 选择第一个div
  // $(&#39;div:first&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //2. 选择最后一个class为box的元素
  //$(&#39;.box:last&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //3. 选择所有class属性不为box的div
  // $(&#39;div:not(.box)&#39;).css(&#39;background&#39;, &#39;red&#39;)  //没有class属性也可以
  //4. 选择第二个和第三个li元素
  // $(&#39;li:gt(0):lt(2)&#39;).css(&#39;background&#39;, &#39;red&#39;) // 多个过滤选择器不是同时执行, 而是依次
  //$(&#39;li:lt(3):gt(0)&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //5. 选择内容为BBBBB的li
  // $(&#39;li:contains(&quot;BBBBB&quot;)&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //6. 选择隐藏的li
  // console.log($(&#39;li:hidden&#39;).length, $(&#39;li:hidden&#39;)[0])
  //7. 选择有title属性的li元素
  // $(&#39;li[title]&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //8. 选择所有属性title为hello的li元素
  $(&#39;li[title=&quot;hello&quot;]&#39;).css(&#39;background&#39;, &#39;red&#39;)
&lt;/script&gt;</code></pre>
</li>
</ul>
<p>练习： 表格隔行变色</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815163734.png" alt="image-20200815163732938" class="lazyload"></p>
<pre><code class="html">&lt;style&gt;
div, span, p {
  width: 140px;
  height: 140px;
  margin: 5px;
  background: #aaa;
  border: #000 1px solid;
  float: left;
  font-size: 17px;
  font-family: Verdana;
}

div.mini {
  width: 55px;
  height: 55px;
  background-color: #aaa;
  font-size: 12px;
}

div.hide {
  display: none;
}

#data {
  width: 600px;
}

#data, td, th {
  border-collapse: collapse;
  border: 1px solid #aaaaaa;
}

th, td {
  height: 28px;
}

#data thead {
  background-color: #333399;
  color: #ffffff;
}

.odd {
  background-color: #ccccff;
}
&lt;/style&gt;
&lt;table id=&quot;data&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;姓名&lt;/th&gt;
      &lt;th&gt;工资&lt;/th&gt;
      &lt;th&gt;入职时间&lt;/th&gt;
      &lt;th&gt;操作&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;tr&gt;
    &lt;td&gt;Tom&lt;/td&gt;
    &lt;td&gt;$3500&lt;/td&gt;
    &lt;td&gt;2010-10-25&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Mary&lt;/td&gt;
    &lt;td&gt;$3400&lt;/td&gt;
    &lt;td&gt;2010-12-1&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;King&lt;/td&gt;
    &lt;td&gt;$5900&lt;/td&gt;
    &lt;td&gt;2009-08-17&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Scott&lt;/td&gt;
    &lt;td&gt;$3800&lt;/td&gt;
    &lt;td&gt;2012-11-17&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Smith&lt;/td&gt;
    &lt;td&gt;$3100&lt;/td&gt;
    &lt;td&gt;2014-01-27&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Allen&lt;/td&gt;
    &lt;td&gt;$3700&lt;/td&gt;
    &lt;td&gt;2011-12-05&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  $(&#39;#data&gt;tbody&gt;tr:odd&#39;).css(&#39;background&#39;, &#39;#ccccff&#39;)
&lt;/script&gt;</code></pre>
<ul>
<li><p>表单选择器</p>
<ul>
<li>表单<ul>
<li><code>:input</code></li>
<li><code>:text</code></li>
<li><code>:checkbox</code></li>
<li><code>:radio</code></li>
</ul>
</li>
<li>表单对象属性<ul>
<li><code>:checked</code>: 选中的</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;form&gt;
  用户名: &lt;input type=&quot;text&quot;/&gt;&lt;br&gt;
  密 码: &lt;input type=&quot;password&quot;/&gt;&lt;br&gt;
  爱 好:
  &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt;篮球
  &lt;input type=&quot;checkbox&quot;/&gt;足球
  &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt;羽毛球 &lt;br&gt;
  性 别:
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&#39;male&#39;/&gt;男
  &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&#39;female&#39;/&gt;女&lt;br&gt;
  邮 箱: &lt;input type=&quot;text&quot; name=&quot;email&quot; disabled=&quot;disabled&quot;/&gt;&lt;br&gt;
  所在地:
  &lt;select&gt;
    &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;天津&lt;/option&gt;
    &lt;option value=&quot;3&quot;&gt;河北&lt;/option&gt;
  &lt;/select&gt;&lt;br&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求:
   1. 选择不可用的文本输入框
   2. 显示选择爱好 的个数
   3. 显示选择的城市名称
   */
  //1. 选择不可用的文本输入框
  // $(&#39;:text:disabled&#39;).css(&#39;background&#39;, &#39;red&#39;)
  //2. 显示选择爱好 的个数
  console.log($(&#39;:checkbox:checked&#39;).length)
  //3. 显示选择的城市名称
  $(&#39;:submit&#39;).click(function () {
    var city = $(&#39;select&gt;option:selected&#39;).html() // 选择的option的标签体文本
    city = $(&#39;select&#39;).val()  // 选择的option的value属性值
    alert(city)
  })
&lt;/script&gt;</code></pre>
</li>
</ul>
<h3 id="2、-工具方法"><a href="#2、-工具方法" class="headerlink" title="2、$工具方法"></a>2、<code>$</code>工具方法</h3><ol>
<li><code>$.each()</code>: 遍历数组或对象中的数据</li>
<li><code>$.trim()</code>: 去除字符串两边的空格</li>
<li><code>$.type(obj)</code>: 得到数据的类型</li>
<li><code>$.isArray(obj)</code>: 判断是否是数组</li>
<li><code>$.isFunction(obj)</code>: 判断是否是函数</li>
<li><code>$.parseJSON(json)</code>: 解析json字符串转换为js对象/数组</li>
</ol>
<pre><code class="html">&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //1. $.each(): 遍历数组或对象中的数据
  var obj = {
    name: &#39;Tom&#39;,
    setName: function (name) {
      this.name = name
    }
  }
  $.each(obj, function (key, value) {
    console.log(key, value)
  })

  //2. $.trim(): 去除字符串两边的空格
  //3. $.type(obj): 得到数据的类型
  console.log($.type($)) // &#39;function&#39;

  //4. $.isArray(obj): 判断是否是数组
  console.log($.isArray($(&#39;body&#39;)), $.isArray([])) // false true
  //5. $.isFunction(obj): 判断是否是函数
  console.log($.isFunction($)) // true
  //6. $.parseJSON(json) : 解析json字符串转换为js对象/数组
  var json = &#39;{&quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;:12}&#39;  // json对象: {}
  // json对象===&gt;JS对象
  console.log($.parseJSON(json))
  json = &#39;[{&quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;:12}, {&quot;name&quot;:&quot;JACK&quot;, &quot;age&quot;:13}]&#39; // json数组: []
  // json数组===&gt;JS数组
  console.log($.parseJSON(json))
  /*
  JSON.parse(jsonString)   json字符串---&gt;js对象/数组
  JSON.stringify(jsObj/jsArr)  js对象/数组---&gt;json字符串
  */
&lt;/script&gt;</code></pre>
<p>练习：多Tab点击切换</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815163919.png" alt="image-20200815163918240" class="lazyload"></p>
<pre><code class="html">&lt;style&gt;
*{margin:0;padding:0}#tab li{float:left;list-style:none;width:80px;height:40px;line-height:40px;cursor:pointer;text-align:center}#container{position:relative}#content1,#content2,#content3{width:300px;height:100px;padding:30px;position:absolute;top:40px;left:0}#tab1,#content1{background-color:#fc0}#tab2,#content2{background-color:#f0c}#tab3,#content3{background-color:#0cf}
&lt;/style&gt;
&lt;h2&gt;多Tab点击切换&lt;/h2&gt;
&lt;ul id=&quot;tab&quot;&gt;
  &lt;li id=&quot;tab1&quot; value=&quot;1&quot;&gt;10元套餐&lt;/li&gt;
  &lt;li id=&quot;tab2&quot; value=&quot;2&quot;&gt;30元套餐&lt;/li&gt;
  &lt;li id=&quot;tab3&quot; value=&quot;3&quot;&gt;50元包月&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&quot;container&quot;&gt;
  &lt;div id=&quot;content1&quot;&gt;
    10元套餐详情：&lt;br/&gt;&amp;nbsp;每月套餐内拨打100分钟，超出部分2毛/分钟
  &lt;/div&gt;
  &lt;div id=&quot;content2&quot; style=&quot;display: none&quot;&gt;
    30元套餐详情：&lt;br/&gt;&amp;nbsp;每月套餐内拨打300分钟，超出部分1.5毛/分钟
  &lt;/div&gt;
  &lt;div id=&quot;content3&quot; style=&quot;display: none&quot;&gt;
    50元包月详情：&lt;br/&gt;&amp;nbsp;每月无限量随心打
  &lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var $contents = $(&#39;#container&gt;div&#39;)
  // 给3个li加监听
  /*$(&#39;#tab&gt;li&#39;).click(function () { // 隐式遍历
    //alert(&#39;----&#39;)
    // 隐隐藏所有内容div
    $contents.css(&#39;display&#39;, &#39;none&#39;)
    // 显示对应的内容div
    // 得到当前点击的li在兄弟中下标
    var index = $(this).index()
    // 找到对应的内容div, 并显示
    $contents[index].style.display = &#39;block&#39;
    // $($contents[index]).css(&#39;display&#39;, &#39;block&#39;)
  })*/
  // 改进——第二三个div默认none，不需要全部设置隐藏
  var currIndex = 0 //当前显示的内容div的下标
  $(&#39;#tab&gt;li&#39;).click(function () { // 隐式遍历
    //alert(&#39;----&#39;)
    // 隐藏当前已经显示的内容div
    $contents[currIndex].style.display = &#39;none&#39;
    // 显示对应的内容div
      // 得到当前点击的li在兄弟中下标
    var index = $(this).index()
      // 找到对应的内容div, 并显示
    $contents[index].style.display = &#39;block&#39;
    // 更新下标
    currIndex = index
  })
&lt;/script&gt;</code></pre>
<h3 id="3、ajax"><a href="#3、ajax" class="headerlink" title="3、ajax"></a>3、ajax</h3><ul>
<li><p><code>ajax()</code></p>
</li>
<li><p><code>get()</code></p>
</li>
<li><p><code>post</code></p>
<p>……</p>
</li>
</ul>
<h2 id="四、使用jQuery对象"><a href="#四、使用jQuery对象" class="headerlink" title="四、使用jQuery对象"></a>四、使用jQuery对象</h2><h3 id="1、属性-文本"><a href="#1、属性-文本" class="headerlink" title="1、属性/文本"></a>1、属性/文本</h3><p>操作标签的属性, 标签体文本</p>
<p>操作任意属性</p>
<ul>
<li><code>attr(name)</code> /<code>attr(name, value)</code>: 读写非布尔值的标签属性</li>
<li><code>prop(name)</code> / <code>prop(name, value)</code>: 读写布尔值的标签属性</li>
<li><code>removeAttr(name)</code>/<code>removeProp(name)</code>: 删除属性</li>
</ul>
<p>操作class属性</p>
<ul>
<li><code>addClass(classValue)</code>: 添加class</li>
<li><code>removeClass(classValue)</code>: 移除指定class</li>
</ul>
<p>操作HTML代码/文本/值</p>
<ul>
<li><code>val()</code> / <code>val(value)</code>: 读写标签的value</li>
<li><code>html()</code> / <code>html(htmlString)</code>: 读写标签体文本</li>
</ul>
<pre><code class="html">&lt;div id=&quot;div1&quot; class=&quot;box&quot; title=&quot;one&quot;&gt;class为box的div1&lt;/div&gt;
&lt;div id=&quot;div2&quot; class=&quot;box&quot; title=&quot;two&quot;&gt;class为box的div2&lt;/div&gt;
&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;
&lt;span class=&quot;box&quot;&gt;class为box的span&lt;/span&gt;
&lt;br/&gt;
&lt;ul&gt;
  &lt;li&gt;AAAAA&lt;/li&gt;
  &lt;li title=&quot;hello&quot; class=&quot;box2&quot;&gt;BBBBB&lt;/li&gt;
  &lt;li class=&quot;box&quot;&gt;CCCCC&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;DDDDDD&lt;/li&gt;
  &lt;li title=&quot;two&quot;&gt;&lt;span&gt;BBBBB&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;guiguClass&quot;/&gt;
&lt;br&gt;
&lt;input type=&quot;checkbox&quot;&gt;
&lt;input type=&quot;checkbox&quot;&gt;
&lt;br&gt;
&lt;button&gt;选中&lt;/button&gt;
&lt;button&gt;不选中&lt;/button&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //1. 读取第一个div的title属性
  // console.log($(&#39;div:first&#39;).attr(&#39;title&#39;)) // one
  //2. 给所有的div设置name属性(value为atguigu)
  // $(&#39;div&#39;).attr(&#39;name&#39;, &#39;atguigu&#39;)
  //3. 移除所有div的title属性
  // $(&#39;div&#39;).removeAttr(&#39;title&#39;)
  //4. 给所有的div设置class=&#39;guiguClass&#39;
  //$(&#39;div&#39;).attr(&#39;class&#39;, &#39;guiguClass&#39;)
  //5. 给所有的div添加class=&#39;abc&#39;
  //$(&#39;div&#39;).addClass(&#39;abc&#39;)
  //6. 移除所有div的guiguClass的class
  //$(&#39;div&#39;).removeClass(&#39;guiguClass&#39;)
  //7. 得到最后一个li的标签体文本
  //console.log($(&#39;li:last&#39;).html())
  //8. 设置第一个li的标签体为&quot;&lt;h1&gt;mmmmmmmmm&lt;/h1&gt;&quot;
  //$(&#39;li:first&#39;).html(&#39;&lt;h1&gt;mmmmmmmmm&lt;/h1&gt;&#39;)
  //9. 得到输入框中的value值
  //console.log($(&#39;:text&#39;).val()) // 读取
  //10. 将输入框的值设置为atguigu
  //$(&#39;:text&#39;).val(&#39;atguigu&#39;) // 设置      读写合一
  //11. 点击&#39;全选&#39;按钮实现全选
    // attr(): 操作属性值为非布尔值的属性
    // prop(): 专门操作属性值为布尔值的属性
  var $checkboxs = $(&#39;:checkbox&#39;)
  $(&#39;button:first&#39;).click(function () {
    $checkboxs.prop(&#39;checked&#39;, true)
  })
  //12. 点击&#39;全不选&#39;按钮实现全不选
  $(&#39;button:last&#39;).click(function () {
    $checkboxs.prop(&#39;checked&#39;, false)
  })
&lt;/script&gt;</code></pre>
<p>练习表格隔行变色改进—&gt;odd样式类</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815164644.png" alt="image-20200815164643571" class="lazyload"></p>
<h3 id="2、CSS"><a href="#2、CSS" class="headerlink" title="2、CSS"></a>2、CSS</h3><p>(1) style样式(设置CSS样式/读取CSS值)</p>
<ul>
<li><code>css(styleName)</code>: 根据样式名得到对应的值</li>
<li><code>css(styleName, value)</code>: 设置一个样式</li>
<li><code>css({多个样式对})</code>: 设置多个样式</li>
</ul>
<pre><code class="html">&lt;p style=&quot;color: blue;&quot;&gt;HTML&lt;/p&gt;
&lt;p style=&quot;color: green;&quot;&gt;CSS&lt;/p&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //1. 得到第一个p标签的颜色
  //console.log($(&#39;p:first&#39;).css(&#39;color&#39;))
  //2. 设置所有p标签的文本颜色为red
  //$(&#39;p&#39;).css(&#39;color&#39;, &#39;red&#39;)
  //3. 设置第2个p的字体颜色(#ff0011),背景(blue),宽(300px), 高(30px)
  $(&#39;p:eq(1)&#39;).css({
    color: &#39;#ff0011&#39;,
    background: &#39;blue&#39;,
    width: 300,
    height: 30
  })
&lt;/script&gt;</code></pre>
<p>(2) 位置坐标(获取/设置标签的位置数据)</p>
<ul>
<li><code>offset()</code>: 读/写当前元素坐标(原点是页面左上角)</li>
<li><code>position()</code>: 读当前元素坐标(原点是父元素左上角)</li>
<li><code>scrollTop()</code>/<code>scrollLeft()</code>: 读/写元素/页面的滚动条坐标</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .div1 {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 20px;
    left: 10px;
    background: blue;
  }
  .div2 {
    position: absolute;
    width: 100px;
    height: 100px;
    top: 50px;
    background: red;
  }
  .div3 {
    position: absolute;
    top: 250px;
  }
&lt;/style&gt;
&lt;body style=&quot;height: 2000px;&quot;&gt;
&lt;div class=&quot;div1&quot;&gt;
  &lt;div class=&quot;div2&quot;&gt;测试offset&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#39;div3&#39;&gt;
  &lt;button id=&quot;btn1&quot;&gt;读取offset和position&lt;/button&gt;
  &lt;button id=&quot;btn2&quot;&gt;设置offset&lt;/button&gt;
&lt;/div&gt;
&lt;!--
获取/设置标签的位置数据
  * offset(): 相对页面左上角的坐标
  * position(): 相对于父元素左上角的坐标
--&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  $(&#39;#btn1&#39;).click(function () {
        // 打印 div1 相对于页面左上角的位置
    var offset = $(&#39;.div1&#39;).offset()
    console.log(offset.left, offset.top) // 10 20
        // 打印 div2 相对于页面左上角的位置
    offset = $(&#39;.div2&#39;).offset()
    console.log(offset.left, offset.top) // 10 70
        // 打印 div1 相对于父元素左上角的位置
    var position = $(&#39;.div1&#39;).position()
    console.log(position.left, position.top) // 10 20
        // 打印 div2 相对于父元素左上角的位置
    position = $(&#39;.div2&#39;).position()
    console.log(position.left, position.top) // 0 50
  })
  $(&#39;#btn2&#39;).click(function () {
    // 设置 div2 相对于页面的左上角的位置
    $(&#39;.div2&#39;).offset({
      left: 50,
      top: 100
    })
  })
&lt;/script&gt;</code></pre>
<ol>
<li><p>scrollTop(): 读取/设置滚动条的Y坐标</p>
</li>
<li><p><code>$(document.body).scrollTop()+$(document.documentElement).scrollTop()</code>: 读取页面滚动条的Y坐标(兼容chrome和IE)</p>
</li>
<li><p><code>$(&#39;body,html&#39;).scrollTop(60);</code>滚动到指定位置(兼容chrome和IE)</p>
</li>
</ol>
<pre><code class="html">&lt;body style=&quot;height: 2000px;&quot;&gt;
&lt;div style=&quot;border:1px solid black;width:100px;height:150px;overflow:auto&quot;&gt;
  This is some text. This is some text. This is some text. This is some text.
  This is some text. This is some text. This is some text. This is some text.
  This is some text. This is some text. This is some text. This is some text.
  This is some text. This is some text. This is some text. This is some text.
  This is some text. This is some text. This is some text. This is some text.
  This is some text. This is some text. This is some text. This is some text.
  his is some text.
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;button id=&quot;btn1&quot;&gt;得到scrollTop&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;设置scrollTop&lt;/button&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  //1. 得到div或页面滚动条的坐标
  $(&#39;#btn1&#39;).click(function () {
    console.log($(&#39;div&#39;).scrollTop())
    // console.log($(&#39;html&#39;).scrollTop()+$(&#39;body&#39;).scrollTop())
    console.log($(document.documentElement).scrollTop()+$(document.body).scrollTop()) // 兼容IE/Chrome
  })
  //2. 让div或页面的滚动条滚动到指定位置
  $(&#39;#btn2&#39;).click(function () {
    $(&#39;div&#39;).scrollTop(200)
    $(&#39;html,body&#39;).scrollTop(300)
  })
&lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>(3) 尺寸(获取/设置标签的尺寸数据)</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815171021.png" alt="image-20200815171020176" class="lazyload"></p>
<ul>
<li><p>内容尺寸</p>
<ul>
<li><code>height()</code>: height</li>
<li><code>width()</code>: width</li>
</ul>
</li>
<li><p>内部尺寸</p>
<ul>
<li><code>innerHeight()</code>: height+padding</li>
<li><code>innerWidth()</code>: width+padding</li>
</ul>
</li>
<li><p>外部尺寸</p>
<ul>
<li>outerHeight(false/true): height+padding+border 如果是true, 加上margin</li>
<li>outerWidth(false/true): width+padding+border 如果是true, 加上margin</li>
</ul>
</li>
</ul>
<pre><code class="html">div {
  width: 100px;
  height: 150px;
  background: red;
  padding: 10px;
  border: 10px #fbd850 solid;
  margin: 10px;
}
&lt;div&gt;div&lt;/div&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var $div = $(&#39;div&#39;)
  // 1. 内容尺寸
  console.log($div.width(), $div.height())  // 100 150
  // 2. 内部尺寸
  console.log($div.innerWidth(), $div.innerHeight()) //120 170
  // 3. 外部尺寸
  console.log($div.outerWidth(), $div.outerHeight()) //140 190
  console.log($div.outerWidth(true), $div.outerHeight(true)) //160 210
&lt;/script&gt;</code></pre>
<h3 id="3、筛选"><a href="#3、筛选" class="headerlink" title="3、筛选"></a>3、筛选</h3><p>(1) 过滤</p>
<p>在jQuery对象中的元素对象数组中过滤出一部分元素来</p>
<ol>
<li><p>first()</p>
</li>
<li><p>last()</p>
</li>
<li><p>eq(index|-index)</p>
</li>
<li><p>filter(selector)：对当前元素提要求</p>
</li>
<li><p>not(selector)：对当前元素提要求, 并取反</p>
</li>
<li><p>has(selector)：对子孙元素提要求</p>
</li>
</ol>
<pre><code class="html">&lt;ul&gt;
  &lt;li&gt;AAAAA&lt;/li&gt;
  &lt;li title=&quot;hello&quot; class=&quot;box2&quot;&gt;BBBBB&lt;/li&gt;
  &lt;li class=&quot;box&quot;&gt;CCCCC&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;DDDDDD&lt;/li&gt;
  &lt;li title=&quot;two&quot;&gt;&lt;span&gt;BBBBB&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;eeeee&lt;/li&gt;
&lt;li&gt;EEEEE&lt;/li&gt;
&lt;br&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var $lis = $(&#39;ul&gt;li&#39;)
  //1. ul下li标签第一个
  // $lis.first().css(&#39;background&#39;, &#39;red&#39;)
  // $lis[0].style.background = &#39;red&#39;

  //2. ul下li标签的最后一个
  // $lis.last().css(&#39;background&#39;, &#39;red&#39;)

  //3. ul下li标签的第二个
  // $lis.eq(1).css(&#39;background&#39;, &#39;red&#39;)

  //4. ul下li标签中title属性为hello的
  // $lis.filter(&#39;[title=hello]&#39;).css(&#39;background&#39;, &#39;red&#39;)

  //5. ul下li标签中title属性不为hello的
  // $lis.not(&#39;[title=hello]&#39;).css(&#39;background&#39;, &#39;red&#39;)
  // $lis.filter(&#39;[title!=hello]&#39;).filter(&#39;[title]&#39;).css(&#39;background&#39;, &#39;red&#39;)

  //6. ul下li标签中有span子标签的
  $lis.has(&#39;span&#39;).css(&#39;background&#39;, &#39;red&#39;)
&lt;/script&gt;</code></pre>
<p>(2) 查找</p>
<p>在已经匹配出的元素集合中根据选择器查找孩子/父母/兄弟标签</p>
<ol>
<li><p>children(): 子标签中找</p>
</li>
<li><p>find() : 后代标签中找</p>
</li>
<li><p>parent() : 父标签</p>
</li>
<li><p>prevAll() : 前面所有的兄弟标签</p>
</li>
<li><p>nextAll() : 后面所有的兄弟标签</p>
</li>
<li><p>siblings() : 前后所有的兄弟标签</p>
</li>
</ol>
<pre><code class="html">&lt;div id=&quot;div1&quot; class=&quot;box&quot; title=&quot;one&quot;&gt;class为box的div1&lt;/div&gt;
&lt;div id=&quot;div2&quot; class=&quot;box&quot;&gt;class为box的div2&lt;/div&gt;
&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;
&lt;span class=&quot;box&quot;&gt;class为box的span&lt;/span&gt;
&lt;br/&gt;
&lt;div&gt;
  &lt;ul&gt;
    &lt;span&gt;span文本1&lt;/span&gt;
    &lt;li&gt;AAAAA&lt;/li&gt;
    &lt;li title=&quot;hello&quot; class=&quot;box2&quot;&gt;BBBBB&lt;/li&gt;
    &lt;li class=&quot;box&quot; id=&#39;cc&#39;&gt;CCCCC&lt;/li&gt;
    &lt;li title=&quot;hello&quot;&gt;DDDDDD&lt;/li&gt;
    &lt;li title=&quot;two&quot;&gt;&lt;span&gt;span文本2&lt;/span&gt;&lt;/li&gt;
    &lt;span&gt;span文本3&lt;/span&gt;
  &lt;/ul&gt;
  &lt;span&gt;span文本444&lt;/span&gt;&lt;br&gt;
  &lt;li&gt;eeeee&lt;/li&gt;
  &lt;li&gt;EEEEE&lt;/li&gt;
  &lt;br&gt;
&lt;/div&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var $ul = $(&#39;ul&#39;)
  //1. ul标签的第2个span子标签
  //$ul.children(&#39;span:eq(1)&#39;).css(&#39;background&#39;, &#39;red&#39;)

  //2. ul标签的第2个span后代标签
  // $ul.find(&#39;span:eq(1)&#39;).css(&#39;background&#39;, &#39;red&#39;)

  //3. ul标签的父标签
  // $ul.parent().css(&#39;background&#39;, &#39;red&#39;)

  //4. id为cc的li标签的前面的所有li标签
  var $li = $(&#39;#cc&#39;)
  // $li.prevAll(&#39;li&#39;).css(&#39;background&#39;, &#39;red&#39;)

  //5. id为cc的li标签的所有兄弟li标签
  $li.siblings(&#39;li&#39;).css(&#39;background&#39;, &#39;red&#39;)
&lt;/script&gt;</code></pre>
<h3 id="4、文档处理-CUD"><a href="#4、文档处理-CUD" class="headerlink" title="4、文档处理(CUD)"></a>4、文档处理(CUD)</h3><ul>
<li>增加<ul>
<li>append() / appendTo(): 向当前匹配的所有元素内部的最后插入指定内容</li>
<li>preppend() / preppendTo(): 向当前匹配的所有元素内部的最前面插入指定内容</li>
<li>before(): 将指定内容插入到当前所有匹配元素的前面</li>
<li>after(): 将指定内容插入到当前所有匹配元素的后面替换节点</li>
</ul>
</li>
<li>删除<ul>
<li>remove(): 将自己及内部的孩子都删除</li>
<li>empty(): 掏空(自己还在)</li>
</ul>
</li>
<li>更新<ul>
<li>replaceWith()：用指定内容替换所有匹配的标签删除节点</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .div1 {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 20px;
    left: 10px;
    background: blue;
  }
  .div2 {
    position: absolute;
    width: 100px;
    height: 100px;
    /*top: 50px;*/
    background: red;
  }
  .div3 {
    position: absolute;
    top: 250px;
  }
&lt;/style&gt;
&lt;ul id=&quot;ul1&quot;&gt;
  &lt;li&gt;AAAAA&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;BBBBB&lt;/li&gt;
  &lt;li class=&quot;box&quot;&gt;CCCCC&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;DDDDDD&lt;/li&gt;
  &lt;li title=&quot;two&quot;&gt;EEEEE&lt;/li&gt;
  &lt;li&gt;FFFFF&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;ul id=&quot;ul2&quot;&gt;
  &lt;li&gt;aaa&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;bbb&lt;/li&gt;
  &lt;li class=&quot;box&quot;&gt;ccc&lt;/li&gt;
  &lt;li title=&quot;hello&quot;&gt;ddd&lt;/li&gt;
  &lt;li title=&quot;two&quot;&gt;eee&lt;/li&gt;
&lt;/ul&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //1. 向id为ul1的ul下添加一个span(最后)
  var $ul1 = $(&#39;#ul1&#39;)
  // $ul1.append(&#39;&lt;span&gt;append()添加的span&lt;/span&gt;&#39;)
  $(&#39;&lt;span&gt;appendTo()添加的span&lt;/span&gt;&#39;).appendTo($ul1)

  //2. 向id为ul1的ul下添加一个span(最前)
  // $ul1.prepend(&#39;&lt;span&gt;prepend()添加的span&lt;/span&gt;&#39;)
  $(&#39;&lt;span&gt;prependTo()添加的span&lt;/span&gt;&#39;).prependTo($ul1)

  //3. 在id为ul1的ul下的li(title为hello)的前面添加span
  $ul1.children(&#39;li[title=hello]&#39;).before(&#39;&lt;span&gt;before()添加的span&lt;/span&gt;&#39;)

  //4. 在id为ul1的ul下的li(title为hello)的后面添加span
  $ul1.children(&#39;li[title=hello]&#39;).after(&#39;&lt;span&gt;after()添加的span&lt;/span&gt;&#39;)

  //5. 将在id为ul2的ul下的li(title为hello)全部替换为p
  $(&#39;#ul2&gt;li[title=hello]&#39;).replaceWith(&#39;&lt;p&gt;replaceAll()替换的p&lt;/p&gt;&#39;)
  //6. 移除id为ul2的ul下的所有li
  // $(&#39;#ul2&#39;).empty()  // &lt;p&gt;也会删除
  $(&#39;#ul2&gt;li&#39;).remove()
&lt;/script&gt;</code></pre>
<h3 id="5、事件"><a href="#5、事件" class="headerlink" title="5、事件"></a>5、事件</h3><p>(1) 事件处理</p>
<ul>
<li><p>绑定事件</p>
<ul>
<li><p>eventName(function(){})：绑定对应事件名的监听, 例如：<code>$(&#39;#div&#39;).click(function(){});</code></p>
</li>
<li><p>on(‘eventName’, function(){})： 通用的绑定事件监听, 例如：<code>$(&#39;#div&#39;).on(&#39;click&#39;, function(){})</code></p>
<ul>
<li>常用: <code>click</code>, <code>mouseenter</code>/<code>mouseleave</code> <code>mouseover</code>/<code>mouseout</code> <code>focus</code>/<code>blur</code></li>
</ul>
<p>优缺点:</p>
<p>eventName: 编码方便, 但只能加一个监听, 且有的事件监听不支持</p>
<p>on: 编码不方便, 可以添加多个监听, 且更通用</p>
</li>
</ul>
</li>
<li><p>解绑事件</p>
<ul>
<li>off(‘eventName’)</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .out {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 20px;
    left: 10px;
    background: blue;
  }
  .inner {
    position: absolute;
    width: 100px;
    height: 100px;
    top: 50px;
    background: red;
  }
  .divBtn {
    position: absolute;
    top: 250px;
  }
&lt;/style&gt;
&lt;body style=&quot;height: 2000px;&quot;&gt;
&lt;div class=&quot;out&quot;&gt;
  外部DIV
  &lt;div class=&quot;inner&quot;&gt;内部div&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#39;divBtn&#39;&gt;
  &lt;button id=&quot;btn1&quot;&gt;取消绑定所有事件&lt;/button&gt;
  &lt;button id=&quot;btn2&quot;&gt;取消绑定mouseover事件&lt;/button&gt;
  &lt;button id=&quot;btn3&quot;&gt;测试事件坐标&lt;/button&gt;
  &lt;a href=&quot;http://www.baidu.com&quot; id=&quot;test4&quot;&gt;百度一下&lt;/a&gt;
&lt;/div&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  //1. 给.out绑定点击监听(用两种方法绑定)
  /*$(&#39;.out&#39;).click(function () {
   console.log(&#39;click out&#39;)
   })*/
  $(&#39;.out&#39;).on(&#39;click&#39;, function () {
    console.log(&#39;on click out&#39;)
  })

  //2. 给.inner绑定鼠标移入和移出的事件监听(用3种方法绑定)
  /*
   $(&#39;.inner&#39;)
   .mouseenter(function () { // 进入
    console.log(&#39;进入&#39;)
   })
   .mouseleave(function () { // 离开
   console.log(&#39;离开&#39;)
   })
   */
  /*
   $(&#39;.inner&#39;)
   .on(&#39;mouseenter&#39;, function () {
   console.log(&#39;进入2&#39;)
   })
   .on(&#39;mouseleave&#39;, function () {
   console.log(&#39;离开2&#39;)
   })
   */
  $(&#39;.inner&#39;).hover(function () {
    console.log(&#39;进入3&#39;)
  }, function () {
    console.log(&#39;离开3&#39;)
  })


  //3. 点击btn1解除.inner上的所有事件监听
  $(&#39;#btn1&#39;).click(function () {
    $(&#39;.inner&#39;).off()
  })

  //4. 点击btn2解除.inner上的mouseenter事件
  $(&#39;#btn2&#39;).click(function () {
    $(&#39;.inner&#39;).off(&#39;mouseenter&#39;)
  })

  //5. 点击btn3得到事件坐标
  $(&#39;#btn3&#39;).click(function (event) { // event事件对象
    console.log(event.offsetX, event.offsetY) // 原点为事件元素的左上角
    console.log(event.clientX, event.clientY) // 原点为窗口的左上角
    console.log(event.pageX, event.pageY) // 原点为页面的左上角
  })

  //6. 点击.inner区域, 外部点击监听不响应
  $(&#39;.inner&#39;).click(function (event) {
    console.log(&#39;click inner&#39;)
    //停止事件冒泡
    event.stopPropagation()
  })

  //7. 点击链接, 如果当前时间是偶数不跳转
  $(&#39;#test4&#39;).click(function (event) {
    if(Date.now()%2===0) {
      event.preventDefault()
    }
  })
&lt;/script&gt;</code></pre>
<p>(2) 事件切换</p>
<p>hover(function(){}, function(){}) 同时绑定鼠标移入和移出监听</p>
<p>区别mouseover与mouseenter?</p>
<ul>
<li><p>mouseover: 在移入子元素时也会触发, 对应mouseout</p>
</li>
<li><p>mouseenter: 只在移入当前元素时才触发, 对应mouseleave</p>
</li>
</ul>
<p>​        hover()使用的就是mouseenter()和mouseleave()</p>
<p>区别on(‘eventName’, fun)与eventName(fun)</p>
<ul>
<li><p>on(‘eventName’, fun): 通用, 但编码麻烦</p>
</li>
<li><p>eventName(fun): 编码简单, 但有的事件没有对应的方法</p>
</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
    * {
        margin: 0px;
    }
    .div1 {
        position: absolute;
        width: 200px;
        height: 200px;
        top: 50px;
        left: 10px;
        background: olive;
    }
    .div2 {
        position: absolute;
        width: 100px;
        height: 100px;
        top: 50px;
        background: red;
    }
    .div3 {
        position: absolute;
        width: 200px;
        height: 200px;
        top: 50px;
        left: 230px;
        background: olive;
    }
    .div4 {
        position: absolute;
        width: 100px;
        height: 100px;
        top: 50px;
        background: yellow;
    }
    .divText{
        position: absolute;
        top: 330px;
        left: 10px;
    }
&lt;/style&gt;
&lt;div class=&quot;divText&quot;&gt;
    区分鼠标的事件
&lt;/div&gt;
&lt;div class=&quot;div1&quot;&gt;
    div1.....
    &lt;div class=&quot;div2&quot;&gt;div2....&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;div3&quot;&gt;
    div3.....
    &lt;div class=&quot;div4&quot;&gt;div4....&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(&#39;.div1&#39;)
        .mouseover(function () {
            console.log(&#39;mouseover 进入&#39;)
        })
        .mouseout(function () {
            console.log(&#39;mouseout 离开&#39;)
        })
    $(&#39;.div3&#39;)
        .mouseenter(function () {
            console.log(&#39;mouseenter 进入&#39;)
        })
        .mouseleave(function () {
            console.log(&#39;mouseleave 离开&#39;)
        })
&lt;/script&gt;</code></pre>
<p>(3) 事件委托</p>
<ul>
<li>理解: 将子元素的事件委托给父辈元素处理<ul>
<li>事件监听绑定在父元素上, 但事件发生在子元素上</li>
<li>　事件会冒泡到父元素</li>
<li>但最终调用的事件回调函数的是子元素: event.target</li>
</ul>
</li>
<li>好处<ul>
<li>新增的元素没有事件监听</li>
<li>减少监听的数量(n==&gt;1)</li>
</ul>
</li>
<li>编码<ul>
<li>delegate(selector, ‘eventName’, function(event){}) // 回调函数中的this是子元素</li>
<li>undelegate(‘eventName’)</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;ul&gt;
  &lt;li&gt;11111&lt;/li&gt;
  &lt;li&gt;1111111&lt;/li&gt;
  &lt;li&gt;111111111&lt;/li&gt;
  &lt;li&gt;11111111111&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;22222&lt;/li&gt;
&lt;br&gt;
&lt;button id=&quot;btn&quot;&gt;添加新的li&lt;/button&gt;
&lt;br&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  /*
   需求：
   1. 点击 li 背景就会变为红色
   2. 点击 btn 就添加一个 li
  */
  $(&#39;ul&gt;li&#39;).click(function () {
    this.style.background = &#39;red&#39;
  })

  $(&#39;#btn&#39;).click(function () {
    $(&#39;ul&#39;).append(&#39;&lt;li&gt;新增的li....&lt;/li&gt;&#39;)
  })
&lt;/script&gt;</code></pre>
<p>引入：绑定事件监听的问题: 新加的元素没有监听</p>
<ol>
<li>事件委托(委派/代理):</li>
</ol>
<ul>
<li><p>将多个子元素(li)的事件监听委托给父辈元素(ul)处理</p>
</li>
<li><p>监听回调是加在了父辈元素上</p>
</li>
<li><p>当操作任何一个子元素(li)时, 事件会冒泡到父辈元素(ul)</p>
</li>
<li><p>父辈元素不会直接处理事件, 而是根据event.target得到发生事件的子元素(li), 通过这个子元素调用事件回调函数</p>
</li>
</ul>
<ol start="2">
<li>事件委托的2方:</li>
</ol>
<ul>
<li><p>委托方: 业主 li</p>
</li>
<li><p>被委托方: 中介 ul</p>
</li>
</ul>
<ol start="3">
<li>使用事件委托的好处</li>
</ol>
<ul>
<li><p>添加新的子元素, 自动有事件响应处理</p>
</li>
<li><p>减少事件监听的数量: n==&gt;1</p>
</li>
</ul>
<ol start="4">
<li>jQuery的事件委托API</li>
</ol>
<ul>
<li><p>设置事件委托: <code>$(parentSelector).delegate(childrenSelector, eventName, callback)</code></p>
</li>
<li><p>移除事件委托: <code>$(parentSelector).undelegate(eventName)</code></p>
</li>
</ul>
<pre><code class="html">&lt;ul&gt;
  &lt;li&gt;1111&lt;/li&gt;
  &lt;li&gt;2222&lt;/li&gt;
  &lt;li&gt;3333&lt;/li&gt;
  &lt;li&gt;4444&lt;/li&gt;
&lt;/ul&gt;
&lt;li&gt;22222&lt;/li&gt;
&lt;br&gt;
&lt;button id=&quot;btn1&quot;&gt;添加新的li&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;删除ul上的事件委托的监听器&lt;/button&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 设置事件委托
  $(&#39;ul&#39;).delegate(&#39;li&#39;, &#39;click&#39;, function () {
    // console.log(this)
    this.style.background = &#39;red&#39;
  })
  $(&#39;#btn1&#39;).click(function () {
    $(&#39;ul&#39;).append(&#39;&lt;li&gt;新增的li....&lt;/li&gt;&#39;)
  })
  $(&#39;#btn2&#39;).click(function () {
    // 移除事件委托
    $(&#39;ul&#39;).undelegate(&#39;click&#39;)
  })
&lt;/script&gt;</code></pre>
<ul>
<li><p>事件坐标</p>
<ul>
<li><p><code>event.offsetX</code>/<code>event.offsetY</code>: 原点是当前元素左上角(相对于事件元素左上角)</p>
</li>
<li><p><code>event.clientX</code>/<code>event.clientY</code>: 原点是窗口左上角(相对于视口的左上角)</p>
</li>
<li><p><code>event.pageX</code>/<code>event.pageY</code>: 原点是页面左上角(相对于页面的左上角)</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815173853.png" alt="image-20200815173852046" class="lazyload"></p>
</li>
</ul>
</li>
<li><p>事件相关处理</p>
<ul>
<li>停止事件冒泡: <code>event.stopPropagation()</code></li>
<li>阻止事件的默认行为: <code>event.preventDefault()</code></li>
</ul>
</li>
</ul>
<h3 id="6、动画效果"><a href="#6、动画效果" class="headerlink" title="6、动画效果"></a>6、动画效果</h3><p>在一定的时间内, 不断改变元素样式</p>
<p>(1) 滑动动画(不断改变元素的高度来实现的)</p>
<ul>
<li>slideDown()：带动画的展开</li>
<li>slideUp()：带动画的收缩</li>
<li>slideToggle()：带动画的切换展开/收缩</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .div1 {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 50px;
    left: 10px;
    background: red;
  }
&lt;/style&gt;
&lt;body&gt;
&lt;button id=&quot;btn1&quot;&gt;慢慢收缩&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;慢慢展开&lt;/button&gt;
&lt;button id=&quot;btn3&quot;&gt;收缩/展开切换&lt;/button&gt;
&lt;div class=&quot;div1&quot;&gt;
&lt;/div&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求：
   1. 点击btn1, 向上滑动
   2. 点击btn2, 向下滑动
   3. 点击btn3, 向上/向下切换
   */
  var $div1 = $(&#39;.div1&#39;)
  // 1. 点击btn1, 向上滑动
  $(&#39;#btn1&#39;).click(function () {
    $div1.slideUp(3000)
  })
  // 2. 点击btn2, 向下滑动
  $(&#39;#btn2&#39;).click(function () {
    $div1.slideDown()
  })
  // 3. 点击btn3, 向上/向下切换
  $(&#39;#btn3&#39;).click(function () {
    $div1.slideToggle()
  })
&lt;/script&gt;</code></pre>
<p>(2) 淡入淡出动画(不断改变元素的透明度来实现的)</p>
<ul>
<li>fadeIn()：带动画的显示</li>
<li>fadeOut()：带动画隐藏</li>
<li>fadeToggle()：带动画切换显示/隐藏</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .div1 {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 50px;
    left: 10px;
    background: red;
  }
&lt;/style&gt;
&lt;body&gt;
&lt;button id=&quot;btn1&quot;&gt;慢慢淡出&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;慢慢淡入&lt;/button&gt;
&lt;button id=&quot;btn3&quot;&gt;淡出/淡入切换&lt;/button&gt;
&lt;div class=&quot;div1&quot;&gt;
&lt;/div&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求：
   1. 点击btn1, 慢慢淡出
     * 无参
     * 有参
       * 字符串参数
       * 数字参数
   2. 点击btn3, 慢慢淡入
   3. 点击btn3, 淡出/淡入切换，动画结束时提示“动画结束了”
   */
  var $div1 = $(&#39;.div1&#39;)
  $(&#39;#btn1&#39;).click(function () {
    // $div1.fadeOut()
    // $div1.fadeOut(&#39;slow&#39;)
    $div1.fadeOut(1000, function () {
      alert(&#39;动画完成了!!!&#39;)
    })
  })
  $(&#39;#btn2&#39;).click(function () {
    $div1.fadeIn()
  })
  $(&#39;#btn3&#39;).click(function () {
    $div1.fadeToggle()
  })
&lt;/script&gt;</code></pre>
<p>(3) 显示/隐藏动画(不断改变元素的尺寸和透明度来实现)</p>
<ul>
<li>show()：(不)带动画的显示</li>
<li>hide()：(不)带动画的隐藏</li>
<li>toggle()：(不)带动画的切换显示/隐藏</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .div1 {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 50px;
    left: 10px;
    background: red;
    display: none;
  }
&lt;/style&gt;
&lt;body&gt;
&lt;button id=&quot;btn1&quot;&gt;瞬间显示&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;慢慢显示&lt;/button&gt;
&lt;button id=&quot;btn3&quot;&gt;慢慢隐藏&lt;/button&gt;
&lt;button id=&quot;btn4&quot;&gt;显示隐藏切换&lt;/button&gt;
&lt;div class=&quot;div1&quot;&gt;
&lt;/div&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
  需求:
  1. 点击btn1, 立即显示
  2. 点击btn2, 慢慢显示
  3. 点击btn3, 慢慢隐藏
  4. 点击btn4, 切换显示/隐藏
   */
  var $div1 = $(&#39;.div1&#39;)
  //1. 点击btn1, 立即显示
  $(&#39;#btn1&#39;).click(function () {
    $div1.show()
  })
  //2. 点击btn2, 慢慢显示
  $(&#39;#btn2&#39;).click(function () {
    $div1.show(1000)
  })
  //3. 点击btn3, 慢慢隐藏
  $(&#39;#btn3&#39;).click(function () {
    $div1.hide(1000)
  })
  //4. 点击btn4, 切换显示/隐藏
  $(&#39;#btn4&#39;).click(function () {
    $div1.toggle(1000)
  })
&lt;/script&gt;</code></pre>
<p>(4) 自定义动画</p>
<ul>
<li>animate({结束时的样式}, time, fun)：自定义动画效果的动画</li>
<li>stop()：停止动画</li>
</ul>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }

  .div1 {
    position: absolute;
    width: 100px;
    height: 100px;
    top: 50px;
    left: 300px;
    background: red;
  }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button id=&quot;btn1&quot;&gt;逐渐扩大&lt;/button&gt;
&lt;button id=&quot;btn2&quot;&gt;移动到指定位置&lt;/button&gt;
&lt;button id=&quot;btn3&quot;&gt;移动指定距离&lt;/button&gt;
&lt;button id=&quot;btn4&quot;&gt;停止动画&lt;/button&gt;

&lt;div class=&quot;div1&quot;&gt;
  花满田间，月照人影
&lt;/div&gt;
&lt;!--
jQuery动画本质 : 在指定时间内不断改变元素样式值来实现的
1. animate(): 自定义动画效果的动画
2. stop(): 停止动画
--&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求：
    1. 逐渐扩大
      1). 宽/高都扩为200px
      2). 宽先扩为200px, 高后扩为200px
    2. 移动到指定位置
      1).移动到(500, 100)处
      2).移动到(100, 20)处
    3.移动指定的距离
      1). 移动距离为(100, 50)
      2). 移动距离为(-100, -20)
    4. 停止动画
   */
  var $div1 = $(&#39;.div1&#39;)

  /*
   1. 逐渐扩大
     1). 宽/高都扩为200px
     2). 宽先扩为200px, 高后扩为200px
   */
  $(&#39;#btn1&#39;).click(function () {
    /*
    $div1.animate({
      width: 200,
      height: 200
    }, 1000)
    */
    $div1
      .animate({
        width: 200
      }, 1000)
      .animate({
        height: 200
      }, 1000)
  })
  /*
   2. 移动到指定位置
     1).移动到(500, 100)处
     2).移动到(100, 20)处
   */
  $(&#39;#btn2&#39;).click(function () {
    // 1).移动到(500, 100)处
    /*
    $div1.animate({ // 向右下移动
      left: 500,
      top: 100
    }, 1000)
    */

    // 2).移动到(100, 20)处
    $div1.animate({ // 向左上移动
      left: 100,  // 300
      top: 20  // 50
    }, 1000)
  })
  /*
   3.移动指定的距离
     1). 移动距离为(100, 50)
     2). 移动距离为(-100, -20)
   */
  $(&#39;#btn3&#39;).click(function () {
    // 1). 移动距离为(100, 50)
    /*$div1.animate({
      left: &#39;+=100&#39;,
      top: &#39;+=50&#39;
    }, 1000)*/
    // 2). 移动距离为(-100, -20)
    $div1.animate({
      left: &#39;-=100&#39;,
      top: &#39;-=20&#39;
    }, 3000)
  })
  $(&#39;#btn4&#39;).click(function () {
    $div1.stop()
  })
&lt;/script&gt;</code></pre>
<p>jQuery对象使用特点</p>
<ul>
<li>链式调用：调用jQuery对象的任何方法后返回的还是当前jQuery对象</li>
</ul>
<pre><code class="javascript">$(&#39;.div1&#39;)
        .mouseover(function () {
            console.log(&#39;mouseover 进入&#39;)
        })
        .mouseout(function () {
            console.log(&#39;mouseout 离开&#39;)
        })</code></pre>
<ul>
<li>读写合一<ul>
<li>读: 内部第一个dom元素</li>
<li>写: 内部所有的dom元素</li>
</ul>
</li>
</ul>
<h2 id="五、jQuery插件"><a href="#五、jQuery插件" class="headerlink" title="五、jQuery插件"></a>五、jQuery插件</h2><h3 id="1、扩展插件"><a href="#1、扩展插件" class="headerlink" title="1、扩展插件"></a>1、扩展插件</h3><ul>
<li>扩展jQuery的工具方法</li>
</ul>
<pre><code class="javascript">$.extend({
  xxx: fuction () {} // this是$
})
$.xxx()</code></pre>
<ul>
<li>扩展jQuery对象的方法</li>
</ul>
<pre><code class="javascript">$.fn.extend({
  xxx: function(){}  // this是jQuery对象
})
$obj.xxx()</code></pre>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .div1 {
    position: absolute;
    width: 100px;
    height: 100px;
    top: 50px;
    left: 10px;
    background: red;
  }
&lt;/style&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot;/&gt;足球
&lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot;/&gt;篮球
&lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot;/&gt;羽毛球
&lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot;/&gt;乒乓球
&lt;br/&gt;
&lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全　选&quot;/&gt;
&lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot;/&gt;
&lt;input type=&quot;button&quot; id=&quot;reverseCheckedBtn&quot; value=&quot;反选&quot;/&gt;
&lt;!--
1. 扩展jQuery的工具方法
  $.extend(object)
2. 扩展jQuery对象的方法
  $.fn.extend(object)
--&gt;
&lt;script src=&quot;js/jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/my_jQuery-plugin.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求：
   1. 给 $ 添加4个工具方法:
     * min(a, b) : 返回较小的值
     * max(c, d) : 返回较大的值
     * leftTrim() : 去掉字符串左边的空格
     * rightTrim() : 去掉字符串右边的空格
   2. 给jQuery对象 添加3个功能方法:
     * checkAll() : 全选
     * unCheckAll() : 全不选
     * reverseCheck() : 全反选
   */
  console.log($.min(3, 5), $.max(3, 5))
  var string = &#39;   my atguigu    &#39;
  console.log(&#39;-----&#39; + $.leftTrim(string) + &#39;-----&#39;)
  console.log(&#39;-----&#39; + $.rightTrim(string) + &#39;-----&#39;)
  var $items = $(&#39;:checkbox[name=items]&#39;)
  $(&#39;#checkedAllBtn&#39;).click(function () {
    $items.checkAll()
  })
  $(&#39;#checkedNoBtn&#39;).click(function () {
    $items.unCheckAll()
  })
  $(&#39;#reverseCheckedBtn&#39;).click(function () {
    $items.reverseCheck()
  })
&lt;/script&gt;</code></pre>
<h3 id="2、jQuery插件"><a href="#2、jQuery插件" class="headerlink" title="2、jQuery插件"></a>2、jQuery插件</h3><ul>
<li><p>理解</p>
<ul>
<li>基于jQuery编写的扩展库</li>
<li><a href="http://plugins.jquery.com/" target="_blank" rel="noopener">http://plugins.jquery.com/</a></li>
</ul>
</li>
<li><p>jquery-validation</p>
<ul>
<li>表单验证插件</li>
<li>参考”菜鸟教程”学习 <a href="https://www.runoob.com/jquery/jquery-plugin-validate.html" target="_blank" rel="noopener">https://www.runoob.com/jquery/jquery-plugin-validate.html</a></li>
<li>使用<ul>
<li>下载</li>
<li>引入js<ul>
<li>jquery-1.11.1.js</li>
<li>jquery.validate.js</li>
<li>messages_zh.js</li>
</ul>
</li>
<li>定义验证<ul>
<li>直接在标签中指定</li>
<li>js编码指定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>jquery UI  <a href="http://jqueryui.com/" target="_blank" rel="noopener">http://jqueryui.com/</a></p>
</li>
<li><p>laydate   <a href="http://www.layui.com/laydate/" target="_blank" rel="noopener">http://www.layui.com/laydate/</a></p>
</li>
</ul>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1、多库共存"><a href="#1、多库共存" class="headerlink" title="1、多库共存"></a>1、多库共存</h3><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
  * {
    margin: 0px;
  }
  .div1 {
    position: absolute;
    width: 100px;
    height: 100px;
    top: 50px;
    left: 10px;
    background: red;
  }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--
问题 : 如果有2个库都有$, 就存在冲突
解决 : jQuery库可以释放$的使用权, 让另一个库可以正常使用, 此时jQuery库只能使用jQuery了
API : jQuery.noConflict()
--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/myLib.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  // 释放$的使用权
  jQuery.noConflict()
  // 调用myLib中的$
  $()
  // 要想使用jQuery的功能, 只能使用jQuery
  jQuery(function () {
    console.log(&#39;文档加载完成&#39;)
  })
&lt;/script&gt;</code></pre>
<h3 id="2、jQuery中的-function"><a href="#2、jQuery中的-function" class="headerlink" title="2、jQuery中的$(function(){})"></a>2、jQuery中的<code>$(function(){})</code></h3><pre><code class="html">&lt;h1&gt;测试window.onload与$(document).ready()&lt;/h1&gt;
&lt;img id=&quot;logo&quot; src=&quot;https://gss0.bdstatic.com/5bVWsj_p_tVS5dKfpU_Y_D3/res/r/image/2017-05-19/6fec71d56242b74eb24b4ac80b817eac.png&quot;&gt;
&lt;!--
区别: window.onload与 $(document).ready()
  * window.onload
    * 包括页面的图片加载完后才会回调(晚)
    * 只能有一个监听回调
  * $(document).ready()
    * 等同于: $(function(){})
    * 页面加载完就回调(早)
    * 可以有多个监听回调
--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   需求：
   1. 直接打印img的宽度，观察其值
   2. 在 $(function(){}) 中 打印 img 的宽度
   3. 在 window.onload 中打印宽度
   4. 在 img 加载完成后打印宽度
   */
  // 1. 直接打印img的宽度，观察其值
  console.log(&#39;直接&#39;, $(&#39;#logo&#39;).width())
  window.onload = function () {
    console.log(&#39;onload&#39;, $(&#39;#logo&#39;).width())
  }
  window.onload = function () {
    console.log(&#39;onload2&#39;, $(&#39;#logo&#39;).width())
  }
  $(function () {
    console.log(&#39;ready&#39;, $(&#39;#logo&#39;).width())
  })
  $(function () {
    console.log(&#39;ready2&#39;, $(&#39;#logo&#39;).width())
  })
  $(&#39;#logo&#39;).on(&#39;load&#39;, function () {
    console.log(&#39;img load&#39;, $(this).width())
  })
  /*$(document).ready(function () {

  })*/
&lt;/script&gt;</code></pre>
<h3 id="3、练习"><a href="#3、练习" class="headerlink" title="3、练习"></a>3、练习</h3><p>以前用原生js实现过的用jQuery来一遍</p>
<p>(1) 爱好选择器</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815180658.png" alt="image-20200815180657634" class="lazyload"></p>
<pre><code class="html">&lt;form&gt;
  你爱好的运动是？&lt;input type=&quot;checkbox&quot; id=&quot;checkedAllBox&quot;/&gt;全选/全不选

  &lt;br/&gt;
  &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot;/&gt;足球
  &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot;/&gt;篮球
  &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot;/&gt;羽毛球
  &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot;/&gt;乒乓球
  &lt;br/&gt;
  &lt;input type=&quot;button&quot; id=&quot;checkedAllBtn&quot; value=&quot;全　选&quot;/&gt;
  &lt;input type=&quot;button&quot; id=&quot;checkedNoBtn&quot; value=&quot;全不选&quot;/&gt;
  &lt;input type=&quot;button&quot; id=&quot;checkedRevBtn&quot; value=&quot;反　选&quot;/&gt;
  &lt;input type=&quot;button&quot; id=&quot;sendBtn&quot; value=&quot;提　交&quot;/&gt;
&lt;/form&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
   功能说明:
   1. 点击&#39;全选&#39;: 选中所有爱好
   2. 点击&#39;全不选&#39;: 所有爱好都不勾选
   3. 点击&#39;反选&#39;: 改变所有爱好的勾选状态
   4. 点击&#39;提交&#39;: 提示所有勾选的爱好
   5. 点击&#39;全选/全不选&#39;: 选中所有爱好, 或者全不选中
   6. 点击某个爱好时, 必要时更新&#39;全选/全不选&#39;的选中状态
   */
  var $checkedAllBox = $(&#39;#checkedAllBox&#39;)
  var $items = $(&#39;:checkbox[name=items]&#39;)

  // 1. 点击&#39;全选&#39;: 选中所有爱好
  $(&#39;#checkedAllBtn&#39;).click(function () {
    $items.prop(&#39;checked&#39;, true)
    $checkedAllBox.prop(&#39;checked&#39;, true)
  })

  // 2. 点击&#39;全不选&#39;: 所有爱好都不勾选
  $(&#39;#checkedNoBtn&#39;).click(function () {
    $items.prop(&#39;checked&#39;, false)
    $checkedAllBox.prop(&#39;checked&#39;, false)
  })

  // 3. 点击&#39;反选&#39;: 改变所有爱好的勾选状态
  $(&#39;#checkedRevBtn&#39;).click(function () {
    $items.each(function () {
      this.checked = !this.checked
    })
    $checkedAllBox.prop(&#39;checked&#39;, $items.filter(&#39;:not(:checked)&#39;).length===0)
  })

  //4. 点击&#39;提交&#39;: 提示所有勾选的爱好
  $(&#39;#sendBtn&#39;).click(function () {
    $items.filter(&#39;:checked&#39;).each(function () {
      alert(this.value)
    })
  })

  // 5. 点击&#39;全选/全不选&#39;: 选中所有爱好, 或者全不选中
  $checkedAllBox.click(function () {
    $items.prop(&#39;checked&#39;, this.checked)
  })

  // 6. 点击某个爱好时, 必要时更新&#39;全选/全不选&#39;的选中状态
  $items.click(function () {
    $checkedAllBox.prop(&#39;checked&#39;, $items.filter(&#39;:not(:checked)&#39;).length===0)
  })
&lt;/script&gt;</code></pre>
<p>(2) 增删员工记录</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815180844.png" alt="image-20200815180841962" class="lazyload"></p>
<pre><code class="html">&lt;style&gt;
#total{width:450px;margin-left:auto;margin-right:auto}ul{list-style-type:none}li{border-style:solid;border-width:1px;padding:5px;margin:5px;background-color:#9f9;float:left}.inner{width:400px;border-style:solid;border-width:1px;margin:10px;padding:10px;float:left}#employeeTable{border-spacing:1px;background-color:black;margin:80px auto 10px auto}th,td{background-color:white}#formDiv{width:250px;border-style:solid;border-width:1px;margin:50px auto 10px auto;padding:10px}#formDiv input{width:100%}.word{width:40px}.inp{width:200px}#employeeTable,#employeeTable th,#employeeTable td{border:1px solid;border-spacing:0}
&lt;/style&gt;
&lt;table id=&quot;employeeTable&quot;&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;Email&lt;/th&gt;
    &lt;th&gt;Salary&lt;/th&gt;
    &lt;th&gt;&amp;nbsp;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Tom&lt;/td&gt;
    &lt;td&gt;tom@tom.com&lt;/td&gt;
    &lt;td&gt;5000&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;deleteEmp?id=001&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Jerry&lt;/td&gt;
    &lt;td&gt;jerry@sohu.com&lt;/td&gt;
    &lt;td&gt;8000&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;deleteEmp?id=002&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Bob&lt;/td&gt;
    &lt;td&gt;bob@tom.com&lt;/td&gt;
    &lt;td&gt;10000&lt;/td&gt;
    &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;div id=&quot;formDiv&quot;&gt;
  &lt;h4&gt;添加新员工&lt;/h4&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td class=&quot;word&quot;&gt;name:&lt;/td&gt;
      &lt;td class=&quot;inp&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;empName&quot; id=&quot;empName&quot;/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;word&quot;&gt;email:&lt;/td&gt;
      &lt;td class=&quot;inp&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot;/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;word&quot;&gt;salary:&lt;/td&gt;
      &lt;td class=&quot;inp&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;salary&quot; id=&quot;salary&quot;/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;
        &lt;button id=&quot;addEmpButton&quot; value=&quot;abc&quot;&gt;
          Submit
        &lt;/button&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>初级版本</p>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
  1. 添加
  2. 删除
   */
  $(&#39;#addEmpButton&#39;).click(function () {
    //1. 收集输入的数据
    var $empName = $(&#39;#empName&#39;)
    var $email = $(&#39;#email&#39;)
    var $salary = $(&#39;#salary&#39;)
    var empName = $empName.val()
    var email = $email.val()
    var salary = $salary.val()

    //2. 生成对应的&lt;tr&gt;标签结构, 并插入#employeeTable的tbody中
    /*
     &lt;tr&gt;
       &lt;td&gt;Bob&lt;/td&gt;
       &lt;td&gt;bob@tom.com&lt;/td&gt;
       &lt;td&gt;10000&lt;/td&gt;
       &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;
     &lt;/tr&gt;
     */
    var $xxx = $(&#39;&lt;tr&gt;&lt;/tr&gt;&#39;)
      .append(&#39;&lt;td&gt;&#39;+empName+&#39;&lt;/td&gt;&#39;) // 拼串
      .append(&#39;&lt;td&gt;&#39;+email+&#39;&lt;/td&gt;&#39;)
      .append(&#39;&lt;td&gt;&#39;+salary+&#39;&lt;/td&gt;&#39;)
      .append(&#39;&lt;td&gt;&lt;a href=&quot;deleteEmp?id=&quot;&#39;+Date.now()+&#39;&gt;Delete&lt;/a&gt;&lt;/td&gt;&#39;)
      .appendTo(&#39;#employeeTable&gt;tbody&#39;)
      .find(&#39;a&#39;)
      .click(clickDelete)

    //3. 清除输入
    $empName.val(&#39;&#39;)
    $email.val(&#39;&#39;)
    $salary.val(&#39;&#39;)
  })

  // 给所有删除链接绑定点击监听
  $(&#39;#employeeTable a&#39;).click(clickDelete)

  /*
  点击删除的回调函数
   */
  function clickDelete () {
    var $tr = $(this).parent().parent()
    var name = $tr.children(&#39;:first&#39;).html()
    if(confirm(&#39;确定删除&#39;+name+&#39;吗?&#39;)) {
      $tr.remove()
    }

    return false
  }

&lt;/script&gt;</code></pre>
<p>进阶版本</p>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  /*
  1. 添加
  2. 删除
   */
  $(&#39;#addEmpButton&#39;).click(function () {
    //1. 收集输入的数据
    var $empName = $(&#39;#empName&#39;)
    var $email = $(&#39;#email&#39;)
    var $salary = $(&#39;#salary&#39;)
    var empName = $empName.val()
    var email = $email.val()
    var salary = $salary.val()

    //2. 生成对应的&lt;tr&gt;标签结构, 并插入#employeeTable的tbody中
    /*
     &lt;tr&gt;
       &lt;td&gt;Bob&lt;/td&gt;
       &lt;td&gt;bob@tom.com&lt;/td&gt;
       &lt;td&gt;10000&lt;/td&gt;
       &lt;td&gt;&lt;a href=&quot;deleteEmp?id=003&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;
     &lt;/tr&gt;
     */
    var $xxx = $(&#39;&lt;tr&gt;&lt;/tr&gt;&#39;)
      .append(&#39;&lt;td&gt;&#39;+empName+&#39;&lt;/td&gt;&#39;) // 拼串
      .append(&#39;&lt;td&gt;&#39;+email+&#39;&lt;/td&gt;&#39;)
      .append(&#39;&lt;td&gt;&#39;+salary+&#39;&lt;/td&gt;&#39;)
      .append(&#39;&lt;td&gt;&lt;a href=&quot;deleteEmp?id=&quot;&#39;+Date.now()+&#39;&gt;Delete&lt;/a&gt;&lt;/td&gt;&#39;)
      .appendTo(&#39;#employeeTable&gt;tbody&#39;)

    //3. 清除输入
    $empName.val(&#39;&#39;)
    $email.val(&#39;&#39;)
    $salary.val(&#39;&#39;)
  })

  // 通过table实现对所有a的click事件委托
  $(&#39;#employeeTable&#39;).delegate(&#39;a&#39;, &#39;click&#39;, clickDelete)

  /*
  点击删除的回调函数
   */
  function clickDelete () {
    var $tr = $(this).parent().parent()
    var name = $tr.children(&#39;:first&#39;).html()
    if(confirm(&#39;确定删除&#39;+name+&#39;吗?&#39;)) {
      $tr.remove()
    }
    return false
  }
&lt;/script&gt;</code></pre>
<p>(3) 轮播图</p>
<pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;
/*去除内边距,没有链接下划线*/
* {
  margin: 0;
  padding: 0;
  text-decoration: none;
}
/*让&lt;body有20px的内边距*/
body {
  padding: 20px;
}
/*最外围的div*/
#container {
width: 600px;
height: 400px;
overflow: hidden;
position: relative; /*相对定位*/
margin: 0 auto;
}
/*包含所有图片的&lt;div&gt;*/
#list {
width: 4200px; /*7张图片的宽: 7*600 */
height: 400px;
position: absolute; /*绝对定位*/
z-index: 1;
}
/*所有的图片&lt;img&gt;*/
#list img {
float: left; /*浮在左侧*/
}
/*包含所有圆点按钮的&lt;div&gt;*/
#pointsDiv {
position: absolute;
height: 10px;
width: 100px;
z-index: 2;
bottom: 20px;
left: 250px;
}
/*所有的圆点&lt;span&gt;*/
#pointsDiv span {
cursor: pointer;
float: left;
border: 1px solid #fff;
width: 10px;
height: 10px;
border-radius: 50%;
background: #333;
margin-right: 5px;
}
/*第一个&lt;span&gt;*/
#pointsDiv .on {
background: orangered;
}
/*切换图标&lt;a&gt;*/
.arrow {
  cursor: pointer;
  display: none;
  line-height: 39px;
  text-align: center;
  font-size: 36px;
  font-weight: bold;
  width: 40px;
  height: 40px;
  position: absolute;
  z-index: 2;
  top: 180px;
  background-color: RGBA(0, 0, 0, 0.3);
  color: #fff;
}
/*鼠标移到切换图标上时*/
.arrow:hover {
  background-color: RGBA(0, 0, 0, 0.7);
}
/*鼠标移到整个div区域时*/
#container:hover .arrow {
display: block; /*显示*/
}
/*上一个切换图标的左外边距*/
#prev {
left: 20px;
}
/*下一个切换图标的右外边距*/
#next {
right: 20px;
}
&lt;/style&gt;
&lt;div id=&quot;container&quot;&gt;
  &lt;div id=&quot;list&quot; style=&quot;left: -600px;&quot;&gt;
    &lt;img src=&quot;img/5.jpg&quot; alt=&quot;5&quot;/&gt;
    &lt;img src=&quot;img/1.jpg&quot; alt=&quot;1&quot;/&gt;
    &lt;img src=&quot;img/2.jpg&quot; alt=&quot;2&quot;/&gt;
    &lt;img src=&quot;img/3.jpg&quot; alt=&quot;3&quot;/&gt;
    &lt;img src=&quot;img/4.jpg&quot; alt=&quot;4&quot;/&gt;
    &lt;img src=&quot;img/5.jpg&quot; alt=&quot;5&quot;/&gt;
    &lt;img src=&quot;img/1.jpg&quot; alt=&quot;1&quot;/&gt;
  &lt;/div&gt;
  &lt;div id=&quot;pointsDiv&quot;&gt;
    &lt;span index=&quot;1&quot; class=&quot;on&quot;&gt;&lt;/span&gt;
    &lt;span index=&quot;2&quot;&gt;&lt;/span&gt;
    &lt;span index=&quot;3&quot;&gt;&lt;/span&gt;
    &lt;span index=&quot;4&quot;&gt;&lt;/span&gt;
    &lt;span index=&quot;5&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
  &lt;a href=&quot;javascript:;&quot; id=&quot;prev&quot; class=&quot;arrow&quot;&gt;&amp;lt;&lt;/a&gt;
  &lt;a href=&quot;javascript:;&quot; id=&quot;next&quot; class=&quot;arrow&quot;&gt;&amp;gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  /*
 功能说明:
 1. 点击向右(左)的图标, 平滑切换到下(上)一页
 2. 无限循环切换: 第一页的上一页为最后页, 最后一页的下一页是第一页
 3. 每隔3s自动滑动到下一页
 4. 当鼠标进入图片区域时, 自动切换停止, 当鼠标离开后,又开始自动切换
 5. 切换页面时, 下面的圆点也同步更新
 6. 点击圆点图标切换到对应的页

 bug: 快速点击时, 翻页不正常
 */
$(function () {

  var $container = $(&#39;#container&#39;)
  var $list = $(&#39;#list&#39;)
  var $points = $(&#39;#pointsDiv&gt;span&#39;)
  var $prev = $(&#39;#prev&#39;)
  var $next = $(&#39;#next&#39;)
  var PAGE_WIDTH = 600 //一页的宽度
  var TIME = 400 // 翻页的持续时间
  var ITEM_TIME = 20 // 单元移动的间隔时间
  var imgCount = $points.length
  var index = 0 //当前下标
  var moving = false // 标识是否正在翻页(默认没有)


  // 1. 点击向右(左)的图标, 平滑切换到下(上)一页
  $next.click(function () {
    // 平滑翻到下一页
    nextPage(true)
  })
  $prev.click(function () {
    // 平滑翻到上一页
    nextPage(false)
  })

  // 3. 每隔3s自动滑动到下一页
  var intervalId = setInterval(function () {
    nextPage(true)
  }, 1000)

  // 4. 当鼠标进入图片区域时, 自动切换停止, 当鼠标离开后,又开始自动切换
  $container.hover(function () {
    // 清除定时器
    clearInterval(intervalId)
  }, function () {
    intervalId = setInterval(function () {
      nextPage(true)
    }, 1000)
  })

  // 6. 点击圆点图标切换到对应的页
  $points.click(function () {
    // 目标页的下标
    var targetIndex = $(this).index()
    // 只有当点击的不是当前页的圆点时才翻页
    if(targetIndex!=index) {
      nextPage(targetIndex)
    }
  })

  /**
   * 平滑翻页
   * @param next
   * true: 下一页
   * false: 上一页
   * 数值: 指定下标页
   */
  function nextPage (next) {
    /*
      总的时间: TIME=400
      单元移动的间隔时间: ITEM_TIME = 20
      总的偏移量: offset
      单元移动的偏移量: itemOffset = offset/(TIME/ITEM_TIME)

      启动循环定时器不断更新$list的left, 到达目标处停止停止定时器
     */
    //如果正在翻页, 直接结束
    if(moving) { //已经正在翻页中
      return
    }
    moving = true // 标识正在翻页
    // 总的偏移量: offset
    var offset = 0
    // 计算offset
    if(typeof next===&#39;boolean&#39;) {
      offset = next ? -PAGE_WIDTH : PAGE_WIDTH
    } else {
      offset = -(next-index)* PAGE_WIDTH
    }
    // 计算单元移动的偏移量: itemOffset
    var itemOffset = offset/(TIME/ITEM_TIME)
    // 得到当前的left值
    var currLeft = $list.position().left
    // 计算出目标处的left值
    var targetLeft = currLeft + offset
    // 启动循环定时器不断更新$list的left, 到达目标处停止停止定时器
    var intervalId = setInterval(function () {
      // 计算出最新的currLeft
      currLeft += itemOffset
      if(currLeft===targetLeft) { // 到达目标位置
        // 清除定时器
        clearInterval(intervalId)
        // 标识翻页停止
        moving = false
        // 如果到达了最右边的图片(1.jpg), 跳转到最左边的第2张图片(1.jpg)
        if(currLeft===-(imgCount+1) * PAGE_WIDTH) {
          currLeft = -PAGE_WIDTH
        } else if(currLeft===0){
          // 如果到达了最左边的图片(5.jpg), 跳转到最右边的第2张图片(5.jpg)
          currLeft = -imgCount * PAGE_WIDTH
        }
      }
      // 设置left
      $list.css(&#39;left&#39;, currLeft)
    }, ITEM_TIME)

    // 更新圆点
    updatePoints(next)
  }
  /**
   * 更新圆点
   * @param next
   */
  function updatePoints (next) {

    // 计算出目标圆点的下标targetIndex
    var targetIndex = 0
    if(typeof next === &#39;boolean&#39;) {
      if(next) {
        targetIndex = index + 1   // [0, imgCount-1]
        if(targetIndex===imgCount) {// 此时看到的是1.jpg--&gt;第1个圆点
          targetIndex = 0
        }
      } else {
        targetIndex = index - 1
        if(targetIndex===-1) { // 此时看到的是5.jpg--&gt;第5个圆点
          targetIndex = imgCount-1
        }
      }
    } else {
      targetIndex = next
    }
    // 将当前index的&lt;span&gt;的class移除
    // $points.eq(index).removeClass(&#39;on&#39;)
    $points[index].className = &#39;&#39;
    // 给目标圆点添加class=&#39;on&#39;
    // $points.eq(targetIndex).addClass(&#39;on&#39;)
    $points[targetIndex].className = &#39;on&#39;

    // 将index更新为targetIndex
    index = targetIndex
  }
})
&lt;/script&gt;</code></pre>
<p>jQuery文档的结构图</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815175515.png" alt="jQuery文档结构图" class="lazyload"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/04/15/JavaScriptAdvance/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg" data-sizes="auto" alt="JavaScript高级学习笔记" class="lazyload">
                    <h1>JavaScript高级学习笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年04月15日</a>
            <a><i class="nexmoefont icon-areachart"></i>10.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 49 分钟</a>
        </div>

        <article>
            
                <ul>
<li><p>基础总结</p>
</li>
<li><p>函数高级</p>
</li>
<li><p>面向对象高级</p>
</li>
<li><p>线程机制与事件机制</p>
</li>
</ul>
<h2 id="一、基础总结"><a href="#一、基础总结" class="headerlink" title="一、基础总结"></a>一、基础总结</h2><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><p><strong>分类</strong></p>
<ul>
<li><p>基本（值）类型</p>
<ul>
<li>String：任意字符串</li>
<li>Number：任意的数字</li>
<li>boolean：true/false</li>
<li>undefined：undefined</li>
<li>null：null</li>
</ul>
</li>
<li><p>对象（引用）类型</p>
<ul>
<li>Object：任意对象</li>
<li>Function：一种特殊的对象（可以执行）</li>
<li>Array：一种特殊的对象（数值下标，内部数据是有序的）</li>
</ul>
</li>
</ul>
<pre><code class="javascript">var obj = {
  name: &#39;TOM&#39;,
  age: 12
}
fuction test(){
  var a = 3
}
var arr = [3, &#39;abc&#39;]
arr[1]</code></pre>
<p><strong>判断</strong></p>
<ul>
<li><p><code>typeof</code></p>
<ul>
<li>可以判断：undefined/ 数值 /字符串/布尔值/function</li>
<li>不能判断：null与Object Object与array</li>
</ul>
</li>
<li><p><code>instanceof</code>：判断对象的具体类型</p>
</li>
<li><p><code>===</code>可以判断：undefined/null/function</p>
</li>
<li><p><code>isNaN</code> 判断NaN ……</p>
</li>
</ul>
<pre><code class="javascript">//1. 基本
// typeof返回数据类型的字符串表达
var a
// undefined
console.log(a, typeof a, typeof a===&#39;undefined&#39;,a===undefined )  // undefined &#39;undefined&#39; true true
console.log(undefined===&#39;undefined&#39;) // false
// Number Sting Boolean
a = 4
console.log(typeof a===&#39;number&#39;) // true
a = &quot;abc123&quot;
console.log(isNaN(a)) // true
a = &#39;string iiii&#39;
console.log(typeof a===&#39;string&#39;) // true
a = true
console.log(typeof a===&#39;boolean&#39;) // true
// null
a = null
console.log(typeof a, a===null) // &#39;object&#39; true

//2. 对象
var b1 = {
    b2: [1, &#39;abc&#39;, console.log],
    b3: function () {
        console.log(&#39;b3&#39;) // b3
        return function () {
            return &#39;funb1&#39;
        }
    }
}
// Object Array Function
console.log(b1 instanceof Object, b1 instanceof Array) // true  false
console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true
console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true
console.log(typeof b1.b2) // &#39;object&#39;
// Function
console.log(typeof b1.b3===&#39;function&#39;) // true
console.log(typeof b1.b2[2]===&#39;function&#39;) // true

// 细节问题
b1.b2[2](4) // 4
console.log(b1.b3()()) // funb1
/*
b1.b3() ---&gt; b3当前的function
b1.b3()() ---&gt; return的function
*/</code></pre>
<p><strong>实例</strong></p>
<p>实例：实例对象</p>
<p>类型：类型对象</p>
<pre><code class="javascript">function Person(name, age){ // 构造函数 类型
    this.name = name
  this.age = age
} 
var p = new Person(&#39;Tom&#39;, 12) // 根据类型创建的实例对象</code></pre>
<p><strong>其他问题</strong></p>
<ol>
<li><p>undefined与null的区别?</p>
<ul>
<li>undefined代表定义未赋值</li>
<li>nulll定义并赋值了, 只是值为null</li>
</ul>
<pre><code class="javascript">var a
console.log(a)  // undefined
a = null
console.log(a) // null</code></pre>
</li>
</ol>
<ol start="2">
<li><p>什么时候给变量赋值为null呢?</p>
<ul>
<li>初始赋值, 表明将要赋值为对象</li>
<li>结束前, 让对象成为垃圾对象(被垃圾回收器回收)</li>
</ul>
<pre><code class="javascript">//起始
var b = null  // 初始赋值为null, 表明将要赋值为对象
//确定对象就赋值
b = [&#39;atguigu&#39;, 12]
//最后
b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收)
// b = 2</code></pre>
</li>
</ol>
<ol start="3">
<li><p>严格区别变量类型与数据类型?</p>
<ul>
<li><p>数据的类型</p>
<ul>
<li>基本类型 </li>
<li>对象类型 </li>
</ul>
</li>
<li><p>变量的类型(变量内存值的类型)</p>
<ul>
<li>基本类型: 保存就是基本类型的数据</li>
<li>引用类型: 保存的是地址值</li>
</ul>
<pre><code class="javascript">var c = function () {

}
console.log(typeof c) // &#39;function&#39;</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="2、数据、变量与内存"><a href="#2、数据、变量与内存" class="headerlink" title="2、数据、变量与内存"></a>2、数据、变量与内存</h3><ol>
<li>什么是数据?</li>
</ol>
<ul>
<li><p>存储在内存中代表特定信息的’东东’, 本质上是0101…</p>
</li>
<li><p>数据的特点: 可传递, 可运算</p>
</li>
<li><p>一切皆数据</p>
</li>
<li><p>内存中所有操作的目标: 数据</p>
<ul>
<li>算术运算</li>
<li>逻辑运算</li>
<li>赋值</li>
<li>运行函数</li>
</ul>
</li>
</ul>
<ol start="2">
<li>什么是内存?</li>
</ol>
<ul>
<li><p>内存条通电后产生的可储存数据的空间(临时的)</p>
</li>
<li><p>内存产生和死亡: 内存条(电路版)—&gt;通电—&gt;产生内存空间—&gt;存储数据—&gt;处理数据—&gt;断电—&gt;内存空间和数据都消失</p>
</li>
<li><p>一块小内存的2个数据</p>
<ul>
<li>内部存储的数据</li>
<li>地址值</li>
</ul>
</li>
<li><p>内存分类</p>
<ul>
<li>栈: 全局变量/局部变量</li>
<li>堆: 对象</li>
</ul>
</li>
</ul>
<ol start="3">
<li>什么是变量?</li>
</ol>
<ul>
<li>可变化的量, 由变量名和变量值组成</li>
</ul>
<ul>
<li>每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据</li>
</ul>
<ol start="4">
<li>内存,数据, 变量三者之间的关系</li>
</ol>
<ul>
<li><p>内存用来存储数据的空间</p>
</li>
<li><p>变量是内存的标识</p>
</li>
</ul>
<pre><code class="javascript">var age = 18
console.log(age)

var obj = {name: &#39;Tom&#39;}
console.log(obj.name)

function fn () {
  var obj = {name: &#39;Tom&#39;}
}

var a = 3
var b = a + 2</code></pre>
<ol start="5">
<li>关于赋值与内存的问题</li>
</ol>
<p>问题: var a = xxx, a内存中到底保存的是什么?</p>
<ul>
<li><p>xxx是<strong>基本数据</strong>, 保存的就是这个<strong>数据</strong></p>
</li>
<li><p>xxx是<strong>对象</strong>, 保存的是对象的<strong>地址值</strong></p>
</li>
<li><p>xxx是一个<strong>变量</strong>, 保存的xxx的<strong>内存内容(可能是基本数据, 也可能是地址值)</strong></p>
</li>
</ul>
<pre><code class="javascript">var a = 3
a = function () {

}
var b = &#39;abc&#39;
a = b
b = {}
a = b</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815100154.png" alt="image-20200815100153040" class="lazyload"></p>
<ol start="6">
<li>关于引用变量赋值问题</li>
</ol>
<ul>
<li><p>2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据</p>
</li>
<li><p>2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象</p>
</li>
</ul>
<pre><code class="javascript">var obj1 = {name: &#39;Tom&#39;}
var obj2 = obj1
obj2.age = 12
console.log(obj1.age)  // 12
function fn (obj) {
  obj.name = &#39;A&#39;
}
fn(obj1)
console.log(obj2.name) //A

var a = {age: 12}
var b = a
a = {name: &#39;BOB&#39;, age: 13}
b.age = 14
console.log(b.age, a.name, a.age) // 14 Bob 13
function fn2 (obj) {
  obj = {age: 15}
}
fn2(a)
console.log(a.age) // 13</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815101835.png" alt="image-20200815101834022" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815102623.png" alt="image-20200815102622137" class="lazyload"></p>
<ol start="7">
<li>关于数据传递问题</li>
</ol>
<p>问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递</p>
<ul>
<li><p>理解1: 都是值(基本/地址值)传递</p>
</li>
<li><p>理解2: 可能是值传递, 也可能是引用传递(地址值)</p>
</li>
</ul>
<pre><code class="javascript">var a = 3
function fn (a) {
  a = a +1
}
fn(a)
console.log(a)  // 3

function fn2 (obj) {
  console.log(obj.name)
}
var obj = {name: &#39;Tom&#39;}
fn2(obj)  // Tom</code></pre>
<ol start="8">
<li>JS引擎如何管理内存</li>
</ol>
<p>问题: JS引擎如何管理内存?</p>
<ul>
<li>内存生命周期<ul>
<li>分配小内存空间, 得到它的使用权</li>
<li>存储数据, 可以反复进行操作</li>
<li>释放小内存空间</li>
</ul>
</li>
</ul>
<ul>
<li>释放内存<ul>
<li>局部变量: 函数执行完自动释放</li>
<li>对象: 成为垃圾对象==&gt;垃圾回收器回收</li>
</ul>
</li>
</ul>
<pre><code class="javascript">var a = 3
var obj = {}
obj = undefined

function fn () {
  var b = {}
}

fn() // b是自动释放, b所指向的对象是在后面的某个时刻由垃圾回收器回收</code></pre>
<h3 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h3><ol>
<li>什么是对象?</li>
</ol>
<ul>
<li><p>多个数据的封装体</p>
</li>
<li><p>用来保存多个数据的容器</p>
</li>
<li><p>一个对象代表现实中的一个事物</p>
</li>
</ul>
<ol start="2">
<li>为什么要用对象?</li>
</ol>
<ul>
<li>统一管理多个数据</li>
</ul>
<ol start="3">
<li>对象的组成</li>
</ol>
<ul>
<li><p>属性: 属性名(字符串)和属性值(任意)组成</p>
</li>
<li><p>方法: 一种特别的属性(属性值是函数)</p>
</li>
</ul>
<ol start="4">
<li>如何访问对象内部数据?</li>
</ol>
<ul>
<li><p><code>.属性名</code>: 编码简单, 有时不能用</p>
</li>
<li><p><code>[&#39;属性名&#39;]</code>: 编码麻烦, 能通用</p>
</li>
</ul>
<pre><code class="javascript">var p = {
  name: &#39;Tom&#39;,
  age: 12,
  setName: function (name) {
    this.name = name
  },
  setAge: function (age) {
    this.age = age
  }
}

p.setName(&#39;Bob&#39;)
p[&#39;setAge&#39;](23)
console.log(p.name, p[&#39;age&#39;])</code></pre>
<p>问题: 什么时候必须使用[‘属性名’]的方式?</p>
<ol>
<li><p>属性名包含特殊字符: <code>-</code>空格</p>
</li>
<li><p>属性名不确定</p>
</li>
</ol>
<pre><code class="javascript">var p = {}
//1. 给p对象添加一个属性: content type: text/json
// p.content-type = &#39;text/json&#39; //不能用
p[&#39;content-type&#39;] = &#39;text/json&#39;
console.log(p[&#39;content-type&#39;])

//2. 属性名不确定
var propName = &#39;myAge&#39;
var value = 18
// p.propName = value //不能用
p[propName] = value
console.log(p[propName])</code></pre>
<h3 id="4、函数"><a href="#4、函数" class="headerlink" title="4、函数"></a>4、函数</h3><ol>
<li>什么是函数?</li>
</ol>
<ul>
<li>实现特定功能的n条语句的封装体</li>
<li>只有函数是可以执行的, 其它类型的数据不能执行</li>
</ul>
<ol start="2">
<li>为什么要用函数?</li>
</ol>
<ul>
<li>提高代码复用</li>
<li>便于阅读交流</li>
</ul>
<ol start="3">
<li>如何定义函数?</li>
</ol>
<ul>
<li>函数声明</li>
<li>表达式</li>
</ul>
<ol start="4">
<li>如何调用(执行)函数?</li>
</ol>
<ul>
<li>test(): <strong>直接调用</strong></li>
<li>obj.test(): <strong>通过对象调用</strong></li>
<li>new test(): <strong>new调用</strong></li>
<li>test.call/apply(obj): <strong>临时让test成为obj的方法进行调用</strong></li>
</ul>
<pre><code class="javascript">/*
编写程序实现以下功能需求:
  1. 根据年龄输出对应的信息
  2. 如果小于18, 输出: 未成年, 再等等!
  3. 如果大于60, 输出: 算了吧!
  4. 其它, 输出: 刚好!
*/
function showInfo (age) {
  if(age&lt;18) {
    console.log(&#39;未成年, 再等等!&#39;)
  } else if(age&gt;60) {
    console.log(&#39;算了吧!&#39;)
  } else {
    console.log(&#39;刚好!&#39;)
  }
}

showInfo(17)
showInfo(20)
showInfo(65)

function fn1 () { //函数声明
  console.log(&#39;fn1()&#39;)
}
var fn2 = function () { //表达式
  console.log(&#39;fn2()&#39;)
}

fn1()
fn2()

var obj = {}
function test2 () {
  this.xxx = &#39;atguigu&#39;
}
// obj.test2()  不能直接, 根本就没有
test2.call(obj) // obj.test2()   // 可以让一个函数成为指定任意对象的方法进行调用
console.log(obj.xxx)</code></pre>
<h3 id="5、回调函数"><a href="#5、回调函数" class="headerlink" title="5、回调函数"></a>5、回调函数</h3><ol>
<li><p>什么函数才是回调函数?<br> 1). 你定义的<br> 2). 你没有调<br> 3). 但最终它执行了(在某个时刻或某个条件下)</p>
</li>
<li><p>常见的回调函数?</p>
<ul>
<li><p>dom事件回调函数 ==&gt;发生事件的dom元素</p>
</li>
<li><p>定时器回调函数 ===&gt;window</p>
</li>
<li><p>ajax请求回调函数(后面讲)</p>
</li>
<li><p>生命周期回调函数(后面讲)</p>
</li>
</ul>
</li>
</ol>
<pre><code class="html">&lt;button id=&quot;btn&quot;&gt;测试点击事件&lt;/button&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  document.getElementById(&#39;btn&#39;).onclick = function () { // dom事件回调函数
    alert(this.innerHTML)
  }
  //定时器
    // 超时定时器
    // 循环定时器
  setTimeout(function () { // 定时器回调函数
    alert(&#39;到点了&#39;+this)
  }, 2000)
  /*var a = 3
  alert(window.a)
  window.b = 4
  alert(b)*/
&lt;/script&gt;</code></pre>
<h3 id="6、IIFE"><a href="#6、IIFE" class="headerlink" title="6、IIFE"></a>6、IIFE</h3><ol>
<li>理解<ul>
<li>全称: Immediately-Invoked Function Expression（立即执行函数）</li>
</ul>
</li>
<li>作用<ul>
<li>隐藏实现</li>
<li>不会污染外部(全局)命名空间</li>
<li>用它来编码js模块</li>
</ul>
</li>
</ol>
<pre><code class="javascript">(function () { //匿名函数自调用
  var a = 3
  console.log(a + 3)
})()
var a = 4
console.log(a)
;(function () {
  var a = 1
  function test () {
    console.log(++a)
  }
  window.$ = function () { // 向外暴露一个全局函数
    return {
      test: test
    }
  }
})()
$().test() // 1.</code></pre>
<h3 id="7、函数中的this"><a href="#7、函数中的this" class="headerlink" title="7、函数中的this"></a>7、函数中的this</h3><ol>
<li>this是什么?<ul>
<li>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window</li>
<li>所有函数内部都有一个变量this</li>
<li>它的值是调用函数的当前对象</li>
</ul>
</li>
<li>如何确定this的值?<ul>
<li>test(): window</li>
<li>p.test(): p</li>
<li>new test(): 新创建的对象</li>
<li>p.call(obj): obj</li>
</ul>
</li>
</ol>
<pre><code class="javascript">function Person(color) {
  console.log(this)
  this.color = color;
  this.getColor = function () {
    console.log(this)
    return this.color;
  };
  this.setColor = function (color) {
    console.log(this)
    this.color = color;
  };
}

Person(&quot;red&quot;); //this是谁? window

var p = new Person(&quot;yello&quot;); //this是谁? p

p.getColor(); //this是谁? p

var obj = {};
p.setColor.call(obj, &quot;black&quot;); //this是谁? obj

var test = p.setColor;
test(); //this是谁? window

function fun1() {
  function fun2() {
    console.log(this);
  }

  fun2(); //this是谁? window
}
fun1();</code></pre>
<h2 id="二、函数高级"><a href="#二、函数高级" class="headerlink" title="二、函数高级"></a>二、函数高级</h2><p>超级重点，两大神兽：==原型和闭包==</p>
<h3 id="1、原型和原型链"><a href="#1、原型和原型链" class="headerlink" title="1、原型和原型链"></a>1、原型和原型链</h3><p>(1) 原型</p>
<ol>
<li>函数的prototype属性(图)<ul>
<li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li>
<li>原型对象中有一个属性constructor, 它指向函数对象</li>
</ul>
</li>
</ol>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815113737.png" alt="image-20200815113735029" class="lazyload"></p>
<ol start="2">
<li>给原型对象添加属性(一般都是方法)<ul>
<li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li>
</ul>
</li>
</ol>
<pre><code class="javascript">// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
console.log(Date.prototype, typeof Date.prototype)
function Fun () {//alt + shift +r(重命名rename)

}
console.log(Fun.prototype)  // 默认指向一个Object空对象(没有我们的属性)

// 原型对象中有一个属性constructor, 它指向函数对象
console.log(Date.prototype.constructor===Date)
console.log(Fun.prototype.constructor===Fun)

//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问
Fun.prototype.test = function () {
  console.log(&#39;test()&#39;)
}
var fun = new Fun()
fun.test()</code></pre>
<p>(2) 显式原型与隐式原型</p>
<ol>
<li>每个函数function都有一个prototype，即显式原型(属性)</li>
<li>每个实例对象都有一个<strong>proto</strong>，可称为隐式原型(属性)</li>
<li>对象的隐式原型的值为其对应构造函数的显式原型的值</li>
<li>内存结构(图)</li>
<li>总结:<ul>
<li>函数的<code>prototype</code>属性: 在定义函数时自动添加的, 默认值是一个空Object对象</li>
<li>对象的<code>__proto__</code>属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值</li>
<li>程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)</li>
</ul>
</li>
</ol>
<pre><code class="javascript">//定义构造函数
function Fn() {   // 内部语句: this.prototype = {}

}
// 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象
console.log(Fn.prototype)
// 2. 每个实例对象都有一个__proto__，可称为隐式原型
//创建实例对象
var fn = new Fn()  // 内部语句: this.__proto__ = Fn.prototype
console.log(fn.__proto__)
// 3. 对象的隐式原型的值为其对应构造函数的显式原型的值
console.log(Fn.prototype===fn.__proto__) // true
//给原型添加方法
Fn.prototype.test = function () {
  console.log(&#39;test()&#39;)
}
//通过实例调用原型的方法
fn.test()</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815115018.png" alt="image-20200815115016550" class="lazyload"></p>
<p>(3) 原型链</p>
<ol>
<li>原型链(图解)<ul>
<li>访问一个对象的属性时，<ul>
<li>先在自身属性中查找，找到返回</li>
<li>如果没有, 再沿着<code>__proto__</code>这条链向上查找, 找到返回</li>
<li>如果最终没找到, 返回undefined</li>
</ul>
</li>
<li>别名: 隐式原型链</li>
<li>作用: 查找对象的属性(方法)</li>
</ul>
</li>
</ol>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815115136.png" alt="image-20200815115135158" class="lazyload"></p>
<ol start="2">
<li>构造函数/原型/实体对象的关系(图解)</li>
</ol>
<pre><code class="javascript">var o1 = new Object();
var o2 = {};</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815115415.png" alt="image-20200815115413214" class="lazyload"></p>
<ol start="3">
<li>构造函数/原型/实体对象的关系2(图解)</li>
</ol>
<pre><code class="javascript">function Foo(){  }
// var Foo = new Function()
// Function = new Function()
// 所有函数的__proto__都是一样的</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815115508.png" alt="image-20200815115505581" class="lazyload"></p>
<pre><code class="javascript">// console.log(Object)
//console.log(Object.prototype)
console.log(Object.prototype.__proto__)
function Fn() {
  this.test1 = function () {
    console.log(&#39;test1()&#39;)
  }
}
console.log(Fn.prototype)
Fn.prototype.test2 = function () {
  console.log(&#39;test2()&#39;)
}

var fn = new Fn()

fn.test1()
fn.test2()
console.log(fn.toString())
console.log(fn.test3)
// fn.test3()

/*
1. 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)
  */
console.log(Fn.prototype instanceof Object) // true
console.log(Object.prototype instanceof Object) // false
console.log(Function.prototype instanceof Object) // true
/*
2. 所有函数都是Function的实例(包含Function)
*/
console.log(Function.__proto__===Function.prototype)
/*
3. Object的原型对象是原型链尽头
  */
console.log(Object.prototype.__proto__) // null
</code></pre>
<ol start="4">
<li>原型继承</li>
</ol>
<ul>
<li>构造函数的实例对象自动拥有构造函数原型对象的属性(方法)</li>
<li>利用的就是原型链</li>
</ul>
<ol start="5">
<li>原型属性问题</li>
</ol>
<ul>
<li>读取对象的属性值时: 会自动到原型链中查找</li>
<li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li>
<li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li>
</ul>
<pre><code class="javascript">function Fn() {

}
Fn.prototype.a = &#39;xxx&#39;
var fn1 = new Fn()
console.log(fn1.a, fn1)

var fn2 = new Fn()
fn2.a = &#39;yyy&#39;
console.log(fn1.a, fn2.a, fn2)

function Person(name, age) {
  this.name = name
  this.age = age
}
Person.prototype.setName = function (name) {
  this.name = name
}
var p1 = new Person(&#39;Tom&#39;, 12)
p1.setName(&#39;Bob&#39;)
console.log(p1)

var p2 = new Person(&#39;Jack&#39;, 12)
p2.setName(&#39;Cat&#39;)
console.log(p2)
console.log(p1.__proto__===p2.__proto__) // true</code></pre>
<p>(4) 探索instanceof</p>
<ol>
<li>instanceof是如何判断的?<ul>
<li>表达式: A instanceof B</li>
<li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li>
</ul>
</li>
<li>Function是通过new自己产生的实例</li>
</ol>
<p><em>案例1</em></p>
<pre><code class="javascript">function Foo() {  }
var f1 = new Foo()
console.log(f1 instanceof Foo) // true
console.log(f1 instanceof Object) // true</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815120818.png" alt="image-20200815120816214" class="lazyload"></p>
<p><em>案例2</em></p>
<pre><code class="javascript">console.log(Object instanceof Function) // true
console.log(Object instanceof Object) // true
console.log(Function instanceof Function) // true
console.log(Function instanceof Object) // true

function Foo() {}
console.log(Object instanceof  Foo) // false</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815120915.png" alt="image-20200815120913828" class="lazyload"></p>
<p>(5) 面试题</p>
<pre><code class="javascript">/*
测试题1
  */
function A () {

}
A.prototype.n = 1

var b = new A()

A.prototype = {
  n: 2,
  m: 3
}

var c = new A()
console.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815122322.png" alt="image-20200815122319966" class="lazyload"></p>
<pre><code class="javascript">/*
  测试题2
  */
function F (){}
Object.prototype.a = function(){
  console.log(&#39;a()&#39;)
}
Function.prototype.b = function(){
  console.log(&#39;b()&#39;)
}

var f = new F()
f.a() // a()
// f.b() // Uncaught TypeError: f.b is not a function
F.a() // a()
F.b() // b()
console.log(f) // F {}
console.log(Object.prototype) // {a: ƒ, constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, …}
console.log(Function.prototype) // ƒ () { [native code] }</code></pre>
<h3 id="2、执行上下文与执行上下文栈"><a href="#2、执行上下文与执行上下文栈" class="headerlink" title="2、执行上下文与执行上下文栈"></a>2、执行上下文与执行上下文栈</h3><p>(1) 变量提升与函数提升</p>
<ol>
<li>变量声明提升<ul>
<li>通过<strong>var定义(声明)的变量</strong>, 在定义语句之前就可以访问到</li>
<li>值: undefined</li>
</ul>
</li>
<li>函数声明提升<ul>
<li>通过<strong>function声明的函数</strong>, 在之前就可以直接调用</li>
<li>值: 函数定义(对象)</li>
</ul>
</li>
<li>问题: 变量提升和函数提升是如何产生的?<ul>
<li>在js中js引擎会优先解析var变量和function定义！在预解析完成后从上到下逐步进行！</li>
<li>解析var变量时，会把值存储在“执行环境”中，而不会去赋值，值是存储作用！例如:<br>alert（a）; var a = 2; 这时会输出undifiend,意思是没有被初始化没有被赋值!<br>这并不是没有被定义、错误了的意思！</li>
<li>在解析function时会把函数整体定义，这也就解释了为什么在function定义函数时为什么可以先调用后声明了！其实表面上看是先调用了，其实在内部机制中第一步实行的是把以function方式定义的函数先声明了（预处理）</li>
</ul>
</li>
</ol>
<pre><code class="javascript">/*
面试题 : 输出 undefined
  */
var a = 3
function fn () {
  console.log(a)
  var a = 4
}
fn() // undefined

console.log(b) //undefined  变量提升
fn2() //可调用  函数提升 fn2()
// fn3() //不能  变量提升 Uncaught TypeError: fn3 is not a function

var b = 3
function fn2() {
  console.log(&#39;fn2()&#39;)
}

var fn3 = function () {
  console.log(&#39;fn3()&#39;)
}</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815122405.png" alt="image-20200815122404360" class="lazyload"></p>
<p>(2) 执行上下文</p>
<ol>
<li>代码分类(位置)<ul>
<li>全局代码</li>
<li>函数(局部)代码</li>
</ul>
</li>
<li>全局执行上下文<ul>
<li>在执行全局代码前将window确定为全局执行上下文</li>
<li>对全局数据进行预处理<ul>
<li>var定义的全局变量==&gt;undefined, 添加为window的属性</li>
<li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li>
<li>this==&gt;赋值(window)</li>
</ul>
</li>
<li>开始执行全局代码<pre><code class="javascript">// 全局声明的变量和函数都会在window中：window.a1、window.a2()
console.log(a1, window.a1) // undefined undefined
window.a2() // a2() 
console.log(this) // Window
</code></pre>
</li>
</ul>
</li>
</ol>
<p>var a1 = 3 // 在这声明，事实上调到上面声明了，这里赋值(因此上面能访问)<br>function a2() { // 在这里声明，能够在上面调用<br>  console.log(‘a2()’)<br>}<br>console.log(a1) // 3</p>
<pre><code>


3. 函数执行上下文
  * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)
  * 对局部数据进行预处理
    * 形参变量——&gt;赋值(实参)——&gt;添加为执行上下文的属性
    * arguments==&gt;赋值(实参列表), 添加为执行上下文的属性
    * var定义的局部变量==&gt;undefined, 添加为执行上下文的属性
    * function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法
    * this==&gt;赋值(调用函数的对象)
  * 开始执行函数体代码

![image-20200815123117687](https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815123118.png)



(3) 执行上下文栈

1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
3. 在函数执行上下文创建后, 将其添加到栈中(压栈)
4. 在当前函数执行完后,将栈顶的对象移除(出栈)
5. 当所有的代码执行完后, 栈中只剩下window

```javascript
var a = 10
var bar = function (x) {
  var b = 5
  foo(x + b)
}
var foo = function (y) {
  var c = 5
  console.log(a + c + y)
}
bar(10)
// bar(10)</code></pre><p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815123328.png" alt="image-20200815123327077" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815123402.png" alt="image-20200815123401244" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815123416.png" alt="image-20200815123414448" class="lazyload"></p>
<pre><code class="javascript">console.log(&#39;gb: &#39;+ i)
var i = 1
foo(1)
function foo(i) {
  if (i == 4) {
    return
  }
  console.log(&#39;fb:&#39; + i)
  foo(i + 1) //递归调用: 在函数内部调用自己
  console.log(&#39;fe:&#39; + i)
}
console.log(&#39;ge: &#39; + i)
/*
1. 依次输出什么?
  gb: undefined
  fb: 1
  fb: 2
  fb: 3
  fe: 3
  fe: 2
  fe: 1
  ge: 1
2. 整个过程中产生了几个执行上下文?  5   */</code></pre>
<p>(4) 面试题</p>
<pre><code class="javascript">/*
  测试题1:  先执行变量提升, 再执行函数提升(先找var和function xxx(){})
  */
function a() {}
var a
console.log(typeof a) // function</code></pre>
<pre><code class="javascript">/*
  测试题2: 先提出去，window中有b，且未赋值
  */
if (!(b in window)) {
  var b = 1
}
console.log(b) // undefined</code></pre>
<pre><code class="javascript">/*
  测试题3: 针对变量名同名或函数名同名的情况：如果声明了同名的函数其定义会被后者覆盖，声明了同名的变量其值也会被后者覆盖
  */
var c = 1
function c(c) {
  console.log(c)
  var c = 3
}
console.log(c) // 1
c(2) // 报错 Uncaught TypeError: c is not a function

再看一个
//声明阶段
function x(){//函数声明
    //console.log(5)此句会被下句代码覆盖
    console.log(3)
}
var x;//变量声明，因为x已经声明过了，此处不进行声明（忽略）
//执行阶段
console.log(x) // ƒ x(){//函数声明//console.log(5);此句会被下句代码覆盖console.log(3);}
console.log(x()) // 3
x=1 
x=100 //x的值被覆盖
console.log(x) // 100
console.log(x()) // Uncaught TypeError: x is not a function</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815125003.png" alt="image-20200815125002631" class="lazyload"></p>
<h3 id="3、作用域与作用域链"><a href="#3、作用域与作用域链" class="headerlink" title="3、作用域与作用域链"></a>3、作用域与作用域链</h3><p>(1) 作用域</p>
<ol>
<li>理解<ul>
<li>就是一块”地盘”, 一个代码段所在的区域</li>
<li>它是静态的(相对于上下文对象), 在编写代码时就确定了</li>
</ul>
</li>
<li>分类<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>没有块作用域(ES6有了)<pre><code class="javascript">/*  //没块作用域
if(true) {
var c = 3
}
console.log(c) // 3 有块作用域则报错*/</code></pre>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li>作用<ul>
<li>隔离变量，不同作用域下同名变量不会有冲突</li>
</ul>
</li>
</ol>
<p>例如把如下代码分割</p>
<pre><code class="javascript">var a = 10,
  b = 20
function fn(x) {
  var a = 100,
    c = 300;
  console.log(&#39;fn()&#39;, a, b, c, x) 
  function bar(x) {
    var a = 1000,
      d = 400
    console.log(&#39;bar()&#39;, a, b, c, d, x)
  }
  bar(100) // bar() 1000 20 300 400 100
  bar(200) // bar() 1000 20 300 400 200
}
fn(10) // fn() 100 20 300 10</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815125424.png" alt="image-20200815125422438" class="lazyload"></p>
<p>(2) 作用域与执行上下文</p>
<ol>
<li>区别1<ul>
<li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时</li>
<li>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建</li>
<li>函数执行上下文是在调用函数时, 函数体代码执行之前创建</li>
</ul>
</li>
<li>区别2<ul>
<li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li>
<li>执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放</li>
</ul>
</li>
<li>联系<ul>
<li>执行上下文(对象)是从属于所在的作用域</li>
<li>全局上下文环境==&gt;全局作用域</li>
<li>函数上下文环境==&gt;对应的函数使用域</li>
</ul>
</li>
</ol>
<p>还是上面那串代码</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815125637.png" alt="image-20200815125635951" class="lazyload"></p>
<p>(3) 作用域链</p>
<ol>
<li>理解<ul>
<li>多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)</li>
<li>查找变量时就是沿着作用域链来查找的</li>
</ul>
</li>
<li>查找一个变量的查找规则<ul>
<li>在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2</li>
<li>在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3</li>
<li>再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常</li>
</ul>
</li>
</ol>
<pre><code class="javascript">var a = 1
function fn1() {
  var b = 2
  function fn2() {
    var c = 3
    console.log(c) // 3
    console.log(b) // 2
    console.log(a) // 1
    console.log(d) // Uncaught ReferenceError: d is not defined
  }
  fn2()
}
fn1()</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815125756.png" alt="image-20200815125755108" class="lazyload"></p>
<p>(4) 面试题</p>
<pre><code class="javascript">var x = 10;
function fn() {
  console.log(x);
}
function show(f) {
  var x = 20;
  f();
}
show(fn); // 10</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815125904.png" alt="image-20200815125902910" class="lazyload"></p>
<pre><code class="javascript">var fn = function () {
  console.log(fn)
}
fn() // f(){console.log(fn)}

var obj = {
  fn2: function () {
    console.log(fn2)
    //console.log(this.fn2) // ƒ () {// console.log(fn2) console.log(this.fn2)}
  }
}
obj.fn2() // Uncaught ReferenceError: fn2 is not defined</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815125936.png" alt="image-20200815125935489" class="lazyload"></p>
<h3 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h3><p>(1) 引入实例</p>
<pre><code class="html">&lt;button&gt;测试1&lt;/button&gt;
&lt;button&gt;测试2&lt;/button&gt;
&lt;button&gt;测试3&lt;/button&gt;
&lt;!--
需求: 点击某个按钮, 提示&quot;点击的是第n个按钮&quot;
--&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var btns = document.getElementsByTagName(&#39;button&#39;)
  //遍历加监听
  /*// 无论点哪个都是 第4个 ——点击的时候循环已经执行完了
  for (var i = 0,length=btns.length; i &lt; length; i++) {
    var btn = btns[i]
    btn.onclick = function () {
      alert(&#39;第&#39;+(i+1)+&#39;个&#39;)
    }
  }*/
  /*
  for (var i = 0,length=btns.length; i &lt; length; i++) {
    var btn = btns[i]
    //将btn所对应的下标保存在btn上，利用这中方式可以实现
    btn.index = i
    btn.onclick = function () {
      alert(&#39;第&#39;+(this.index+1)+&#39;个&#39;)
    }
  }*/

  //利用闭包
  for (var i = 0,length=btns.length; i &lt; length; i++) {
    (function (j) {
      var btn = btns[j]
      btn.onclick = function () {
        alert(&#39;第&#39;+(j+1)+&#39;个&#39;)
      }
    })(i)
  }
&lt;/script&gt;</code></pre>
<p>(2) 理解闭包</p>
<ol>
<li>如何产生闭包?<ul>
<li>当一个<strong>嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)</strong>时, 就产生了闭包</li>
</ul>
</li>
<li>闭包到底是什么?<ul>
<li>使用chrome调试查看</li>
<li>理解一: 闭包是嵌套的内部函数(绝大部分人)</li>
<li>理解二: 包含被引用变量(函数)的对象(极少数人)</li>
<li>注意: 闭包存在于嵌套的内部函数中</li>
</ul>
</li>
<li><strong><em>产生闭包的条件?</em></strong><ul>
<li>函数嵌套</li>
<li>内部函数引用了外部函数的数据(变量/函数)</li>
</ul>
</li>
</ol>
<pre><code class="javascript">function fn1 () {
  var a = 2
  var b = &#39;abc&#39;
  function fn2 () { //执行函数定义就会产生闭包(不用调用内部函数)
    console.log(a)
  }
  // fn2()
}
fn1()

function fun1() {
  var a = 3
  var fun2 = function () { // 声明变量形式定义函数，不会产生闭包
    console.log(a)
  }
}
fun1()</code></pre>
<p>(3) 常见的闭包</p>
<ol>
<li>将函数作为另一个函数的返回值</li>
<li>将函数作为实参传递给另一个函数调用</li>
</ol>
<pre><code class="javascript">// 1. 将函数作为另一个函数的返回值
function fn1() {
  var a = 2
  function fn2() {
    a++
    console.log(a)
  }
  return fn2
}
var f = fn1()
f() // 3
f() // 4
/* f调用的是内部函数，fn1外部函数执行了一次，产生1个闭包 */

// 2. 将函数作为实参传递给另一个函数调用
function showDelay(msg, time) {
  setTimeout(function () {
    alert(msg)
  }, time)
}
showDelay(&#39;test&#39;, 2000)</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815131913.png" alt="image-20200815131912058" class="lazyload"></p>
<p>(4) 闭包的作用</p>
<ol>
<li>使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)</li>
<li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li>
</ol>
<p><em>问题:</em></p>
<ul>
<li><p>函数执行完后, 函数内部声明的局部变量是否还存在? </p>
<p>一般是不存在, 存在于闭中的变量才可能存在</p>
</li>
<li><p>在函数外部能直接访问函数内部的局部变量吗? </p>
<p>不能, 但我们可以通过闭包让外部操作它</p>
</li>
</ul>
<pre><code class="javascript">function fn1() {
  var a = 2
  function fn2() {
    a++
    console.log(a)
    // return a
  }
  function fn3() {
    a--
    console.log(a)
  }
  return fn3
}
var f = fn1()
f() // 1
f() // 0</code></pre>
<p>(5) 闭包的生命周期</p>
<ol>
<li>产生: 在嵌套内部函数<strong>定义</strong>执行完时就产生了(不是在调用)</li>
<li>死亡: 在嵌套的内部函数成为垃圾对象时</li>
</ol>
<pre><code>function fn1() {
  //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)
  var a = 2
  function fn2 () {
    a++
    console.log(a)
  }
  return fn2
}
var f = fn1()
f() // 3
f() // 4
f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)</code></pre><p>(6) 闭包的应用: 自定义JS模块</p>
<p>模块：</p>
<ul>
<li>具有特定功能的js文件<ul>
<li>将所有的数据和功能都封装在一个函数内部(私有的)</li>
<li>只向外暴露一个包括n个方法的对象或函数</li>
<li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</li>
</ul>
</li>
</ul>
<p>例如：</p>
<p>文件<code>myModule1.js</code>就是一个模块</p>
<pre><code class="javascript">function myModule() {
  //私有数据
  var msg = &#39;Hello This is Module1&#39;
  //操作数据的函数
  function doSomething() {
    console.log(&#39;doSomething() &#39;+msg.toUpperCase())
  }
  function doOtherthing () {
    console.log(&#39;doOtherthing() &#39;+msg.toLowerCase())
  }

  //向外暴露对象(给外部使用的方法)
  return {
    doSomething: doSomething,
    doOtherthing: doOtherthing
  }
}</code></pre>
<p>在其他文件中引入</p>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var module = myModule()
  module.doSomething()
  module.doOtherthing()
&lt;/script&gt;</code></pre>
<p>下面这种更好用一点，可以不需要先执行那个函数（IIFE）</p>
<p><code>myModule2.js</code></p>
<pre><code class="javascript">(function () {
  //私有数据
  var msg = &#39;Hello This is Module1&#39;
  //操作数据的函数
  function doSomething() {
    console.log(&#39;doSomething() &#39;+msg.toUpperCase())
  }
  function doOtherthing () {
    console.log(&#39;doOtherthing() &#39;+msg.toLowerCase())
  }

  //向外暴露对象(给外部使用的方法)
  window.myModule2 = {
    doSomething: doSomething,
    doOtherthing: doOtherthing
  }
})()</code></pre>
<p>引入使用</p>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;myModule2.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  myModule2.doSomething()
  myModule2.doOtherthing()
&lt;/script&gt;</code></pre>
<p>压缩代码时，会把变量改为a、b、c这种的，因此最好这样做</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815132854.png" alt="image-20200815132852872" class="lazyload"></p>
<p>(7) 闭包的缺点及解决</p>
<ol>
<li>缺点<ul>
<li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li>
<li>容易造成内存泄露</li>
</ul>
</li>
<li>解决<ul>
<li>能不用闭包就不用</li>
<li>及时释放</li>
</ul>
</li>
</ol>
<pre><code class="javascript">function fn1() {
  var arr = new Array[100000]
  function fn2() {
    console.log(arr.length)
  }
  return fn2
}
var f = fn1()
f()

f = null //让内部函数成为垃圾对象--&gt;回收闭包</code></pre>
<p>补充：内存溢出与内存泄露</p>
<ul>
<li>内存溢出<ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误</li>
</ul>
</li>
<li>内存泄露<ul>
<li>占用的内存没有及时释放</li>
<li>内存泄露积累多了就容易导致内存溢出</li>
<li>常见的内存泄露：<ul>
<li>意外的全局变量</li>
<li>没有及时清理的计时器或回调函数</li>
<li>闭包</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815133732.png" alt="image-20200815133731332" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815133741.png" alt="image-20200815133739782" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815133756.png" alt="image-20200815133755479" class="lazyload"></p>
<p>(8) 面试题</p>
<pre><code class="javascript">//代码片段一
var name = &quot;The Window&quot;;
var object = {
  name : &quot;My Object&quot;,
  getNameFunc : function(){
    return function(){
      return this.name;
    };
  }
};
alert(object.getNameFunc()());  // the window

//代码片段二
var name2 = &quot;The Window&quot;;
var object2 = {
  name2 : &quot;My Object&quot;,
  getNameFunc : function(){
    var that = this;
    return function(){
      return that.name2;
    };
  }
};
alert(object2.getNameFunc()()); // my object

// 三
function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n)
    }
  }
}
var a = fun(0)
a.fun(1)
a.fun(2)
a.fun(3)//undefined,0,0,0

var b = fun(0).fun(1).fun(2).fun(3)//undefined,0,1,2

var c = fun(0).fun(1)
c.fun(2)
c.fun(3)//undefined,0,1,1</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815133831.png" alt="image-20200815133830697" class="lazyload"></p>
<h2 id="三、面向对象高级"><a href="#三、面向对象高级" class="headerlink" title="三、面向对象高级"></a>三、面向对象高级</h2><h3 id="1、对象创建模式"><a href="#1、对象创建模式" class="headerlink" title="1、对象创建模式"></a>1、对象创建模式</h3><p>有如下五种方式：</p>
<p>(1) Object构造函数模式</p>
<ul>
<li>套路: 先创建空Object对象, 再动态添加属性/方法</li>
<li>适用场景: 起始时不确定对象内部数据</li>
<li>问题: 语句太多</li>
</ul>
<pre><code class="javascript">/*
一个人: name:&quot;Tom&quot;, age: 12
  */
// 先创建空Object对象
var p = new Object()
p = {} //此时内部数据是不确定的
// 再动态添加属性/方法
p.name = &#39;Tom&#39;
p.age = 12
p.setName = function (name) {
  this.name = name
}

//测试
console.log(p.name, p.age)
p.setName(&#39;Bob&#39;)
console.log(p.name, p.age)</code></pre>
<p>(2) 对象字面量模式</p>
<ul>
<li>套路: 使用{}创建对象, 同时指定属性/方法<ul>
<li>适用场景: 起始时对象内部数据是确定的</li>
<li>问题: 如果创建多个对象, 有重复代码</li>
</ul>
</li>
</ul>
<pre><code class="javascript">var p = {
  name: &#39;Tom&#39;,
  age: 12,
  setName: function (name) {
    this.name = name
  }
}

//测试
console.log(p.name, p.age)
p.setName(&#39;JACK&#39;)
console.log(p.name, p.age)

var p2 = {  //如果创建多个对象代码很重复
  name: &#39;Bob&#39;,
  age: 13,
  setName: function (name) {
    this.name = name
  }
}</code></pre>
<p>(3) <del>工厂模式</del></p>
<ul>
<li>套路: 通过工厂函数动态创建对象并返回<ul>
<li>适用场景: 需要创建多个对象</li>
<li>问题: 对象没有一个具体的类型, 都是Object类型</li>
</ul>
</li>
</ul>
<pre><code class="javascript">function createPerson(name, age) { //返回一个对象的函数===&gt;工厂函数
  var obj = {
    name: name,
    age: age,
    setName: function (name) {
      this.name = name
    }
  }

  return obj
}

// 创建2个人
var p1 = createPerson(&#39;Tom&#39;, 12)
var p2 = createPerson(&#39;Bob&#39;, 13)

// p1/p2是Object类型

function createStudent(name, price) {
  var obj = {
    name: name,
    price: price
  }
  return obj
}
var s = createStudent(&#39;张三&#39;, 12000)
// s也是Object</code></pre>
<p>(4) 自定义构造函数模式</p>
<ul>
<li>套路: 自定义构造函数, 通过new创建对象</li>
<li>适用场景: 需要创建多个类型确定的对象</li>
<li>问题: 每个对象都有相同的数据, 浪费内存</li>
</ul>
<pre><code class="javascript">//定义类型
function Person(name, age) {
  this.name = name
  this.age = age
  this.setName = function (name) {
    this.name = name
  }
}
var p1 = new Person(&#39;Tom&#39;, 12)
p1.setName(&#39;Jack&#39;)
console.log(p1.name, p1.age)
console.log(p1 instanceof Person)

function Student (name, price) {
  this.name = name
  this.price = price
}
var s = new Student(&#39;Bob&#39;, 13000)
console.log(s instanceof Student)

var p2 = new Person(&#39;JACK&#39;, 23)
console.log(p1, p2)</code></pre>
<p>方法两者都有，且相同，不需要单独拥有，可放到原型中(方法一般放到原型中)——&gt;</p>
<p>(5) 构造函数+原型的组合模式</p>
<ul>
<li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li>
<li>适用场景: 需要创建多个类型确定的对象</li>
</ul>
<pre><code class="javascript">function Person(name, age) { //在构造函数中只初始化一般函数
  this.name = name
  this.age = age
}
Person.prototype.setName = function (name) {
  this.name = name
}

var p1 = new Person(&#39;Tom&#39;, 23)
var p2 = new Person(&#39;Jack&#39;, 24)
console.log(p1, p2)</code></pre>
<h3 id="2、继承模式"><a href="#2、继承模式" class="headerlink" title="2、继承模式"></a>2、继承模式</h3><p>继承，在js中有三种方式：</p>
<p>(1) 原型链继承</p>
<ol>
<li>套路<ul>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型的构造函数</li>
<li>创建父类型的对象赋值给子类型的原型</li>
<li>将子类型原型的构造属性设置为子类型</li>
<li>给子类型原型添加方法</li>
<li>创建子类型的对象: 可以调用父类型的方法</li>
</ul>
</li>
<li>关键<ul>
<li>子类型的原型为父类型的一个实例对象</li>
</ul>
</li>
</ol>
<pre><code class="javascript">//父类型
function Supper() {
  this.supProp = &#39;Supper property&#39;
}
Supper.prototype.showSupperProp = function () {
  console.log(this.supProp)
}

//子类型
function Sub() {
  this.subProp = &#39;Sub property&#39;
}

// 子类型的原型为父类型的一个实例对象
Sub.prototype = new Supper()
// 让子类型的原型的constructor指向子类型
Sub.prototype.constructor = Sub
Sub.prototype.showSubProp = function () {
  console.log(this.subProp)
}

var sub = new Sub()
sub.showSupperProp()
// sub.toString()
sub.showSubProp()

console.log(sub)  // Sub</code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815135207.png" alt="image-20200815135206553" class="lazyload"></p>
<p>(2) 借用构造函数继承</p>
<ol>
<li>套路:<ul>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li>在子类型构造函数中调用父类型构造</li>
</ul>
</li>
<li>关键:<ul>
<li>在子类型构造函数中通用call()调用父类型构造函数</li>
</ul>
</li>
</ol>
<pre><code class="javascript">function Person(name, age) {
  this.name = name
  this.age = age
}
function Student(name, age, price) {
  Person.call(this, name, age)  // 相当于: this.Person(name, age)
  /*this.name = name
  this.age = age*/
  this.price = price
}

var s = new Student(&#39;Tom&#39;, 20, 14000)
console.log(s.name, s.age, s.price)</code></pre>
<p>(3) 组合继承</p>
<ol>
<li><p>利用原型链实现对父类型对象的方法继承</p>
</li>
<li><p>利用super()借用父类型构建函数初始化相同属性</p>
</li>
</ol>
<pre><code class="javascript">function Person(name, age) {
  this.name = name
  this.age = age
}
Person.prototype.setName = function (name) {
  this.name = name
}

function Student(name, age, price) {
  Person.call(this, name, age)  // 为了得到属性
  this.price = price
}
Student.prototype = new Person() // 为了能看到父类型的方法
Student.prototype.constructor = Student //修正constructor属性
Student.prototype.setPrice = function (price) {
  this.price = price
}

var s = new Student(&#39;Tom&#39;, 24, 15000)
s.setName(&#39;Bob&#39;)
s.setPrice(16000)
console.log(s.name, s.age, s.price)</code></pre>
<h2 id="四、线程机制与事件机制"><a href="#四、线程机制与事件机制" class="headerlink" title="四、线程机制与事件机制"></a>四、线程机制与事件机制</h2><h3 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h3><p>(1) 进程(process)</p>
<ul>
<li>程序的一次执行, 它占有一片独有的内存空间</li>
<li>可以通过windows任务管理器查看进程</li>
</ul>
<p>(2) 线程(thread)</p>
<ul>
<li>是进程内的一个独立执行单元</li>
<li>是程序执行的一个完整流程</li>
<li>是CPU的最小的调度单元</li>
</ul>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815135743.png" alt="线程与进程" class="lazyload"></p>
<p>应用程序必须运行在某个进程的某个线程上<br>一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建<br>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的<br>一个进程内的数据可以供其中的多个线程直接共享<br>多个进程之间的数据是不能直接共享的<br>线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用</p>
<p>(3) 相关问题</p>
<ol>
<li>何为多进程与多线程?</li>
</ol>
<ul>
<li>多进程运行: 一应用程序可以同时启动多个实例运行</li>
<li>多线程: 在一个进程内, 同时有多个线程运行</li>
</ul>
<ol start="2">
<li>比较单线程与多线程?</li>
</ol>
<ul>
<li>多线程<ul>
<li>优点<ul>
<li>能有效提升CPU的利用率</li>
</ul>
</li>
<li>缺点<ul>
<li>创建多线程开销</li>
<li>线程间切换开销</li>
<li>死锁与状态同步问题</li>
</ul>
</li>
</ul>
</li>
<li>单线程<ul>
<li>优点<ul>
<li>顺序编程简单易懂</li>
</ul>
</li>
<li>缺点<ul>
<li>效率低</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>JS是单线程还是多线程?</li>
</ol>
<ul>
<li>js是单线程运行的，但使用H5中的 Web Workers可以多线程运行</li>
</ul>
<ol start="4">
<li>浏览器运行是单线程还是多线程?</li>
</ol>
<ul>
<li>都是多线程运行的</li>
</ul>
<ol start="5">
<li>浏览器运行是单进程还是多进程?</li>
</ol>
<ul>
<li>有的是单进程<ul>
<li>firefox</li>
<li>老版IE</li>
</ul>
</li>
<li>有的是多进程<ul>
<li>chrome</li>
<li>新版IE</li>
</ul>
</li>
<li>如何查看浏览器是否是多进程运行的呢?<ul>
<li>任务管理器–&gt;进程</li>
</ul>
</li>
</ul>
<h3 id="2、浏览器内核"><a href="#2、浏览器内核" class="headerlink" title="2、浏览器内核"></a>2、浏览器内核</h3><ul>
<li>支撑浏览器运行的最核心的程序</li>
<li>不同的浏览器可能不一样<ul>
<li>Chrome, Safari : webkit</li>
<li>firefox : Gecko</li>
<li>IE    : Trident</li>
<li>360,搜狗等国内浏览器: Trident + webkit</li>
</ul>
</li>
<li>内核由很多模块组成<ul>
<li>主线程<ul>
<li>js引擎模块 : 负责js程序的编译与运行</li>
<li>html,css文档解析模块 : 负责页面文本的解析</li>
<li>DOM/CSS模块 : 负责dom/css在内存中的相关处理 </li>
<li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)<pre><code>......</code></pre></li>
</ul>
</li>
<li>​    分线程<ul>
<li>定时器模块 : 负责定时器的管理</li>
<li>DOM事件响应模块 : 负责事件的管理</li>
<li>网络请求模块 : 负责ajax请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、定时器引发的思考"><a href="#3、定时器引发的思考" class="headerlink" title="3、定时器引发的思考"></a>3、定时器引发的思考</h3><ol>
<li>定时器真是定时执行的吗?</li>
</ol>
<ul>
<li><p>定时器并不能保证真正定时执行</p>
</li>
<li><p>一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)</p>
</li>
</ul>
<ol start="2">
<li>定时器回调函数是在分线程执行的吗?</li>
</ol>
<ul>
<li>在主线程执行的, js是单线程的</li>
</ul>
<ol start="3">
<li>定时器是如何实现的?</li>
</ol>
<ul>
<li>事件循环模型(后面讲)</li>
</ul>
<pre><code class="javascript">document.getElementById(&#39;btn&#39;).onclick = function () {
  var start = Date.now()
  console.log(&#39;启动定时器前...&#39;)
  setTimeout(function () {
    console.log(&#39;定时器执行了&#39;, Date.now()-start)
  }, 200)
  console.log(&#39;启动定时器后...&#39;)

  // 做一个长时间的工作
  for (var i = 0; i &lt; 1000000000; i++) {

  }
}</code></pre>
<h3 id="4、JS是单线程执行的"><a href="#4、JS是单线程执行的" class="headerlink" title="4、JS是单线程执行的"></a>4、JS是单线程执行的</h3><ol>
<li><p>如何证明js执行是单线程的?</p>
<ul>
<li>setTimeout()的回调函数是在主线程执行的</li>
<li>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</li>
</ul>
</li>
<li><p>为什么js要用单线程模式, 而不用多线程模式?</p>
<ul>
<li>JavaScript的单线程，与它的用途有关。</li>
<li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</li>
<li>这决定了它只能是单线程，否则会带来很复杂的同步问题</li>
</ul>
</li>
<li><p>代码的分类:</p>
<ul>
<li>初始化代码</li>
<li>回调代码</li>
</ul>
</li>
<li><p>js引擎执行代码的基本流程</p>
<ul>
<li>先执行初始化代码: 包含一些特别的代码   回调函数(异步执行)<ul>
<li>设置定时器</li>
<li>绑定事件监听</li>
<li>发送ajax请求</li>
</ul>
</li>
<li>后面在某个时刻才会执行回调代码(回调函数包含的代码)</li>
</ul>
</li>
</ol>
<pre><code class="javascript">setTimeout(function () {
  console.log(&#39;timeout 2222&#39;)
  alert(&#39;22222222&#39;)
}, 2000)
setTimeout(function () {
  console.log(&#39;timeout 1111&#39;)
  alert(&#39;1111111&#39;)
}, 1000)
setTimeout(function () {
  console.log(&#39;timeout() 00000&#39;)
}, 0)
function fn() {
  console.log(&#39;fn()&#39;)
}
fn()

console.log(&#39;alert()之前&#39;)
alert(&#39;------&#39;) //暂停当前主线程的执行, 同时暂停计时, 点击确定后, 恢复程序执行和计时
console.log(&#39;alert()之后&#39;)</code></pre>
<h3 id="5、浏览器的事件循环-轮询-模型"><a href="#5、浏览器的事件循环-轮询-模型" class="headerlink" title="5、浏览器的事件循环(轮询)模型"></a>5、浏览器的事件循环(轮询)模型</h3><p>(1) 模型原理图</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815141019.png" alt="image-20200815141017614" class="lazyload"></p>
<ol>
<li>所有代码分类<ul>
<li>初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li>
<li>回调执行代码(异步代码): 处理回调逻辑</li>
</ul>
</li>
<li>js引擎执行代码的基本流程:<ul>
<li>初始化代码===&gt;回调代码</li>
</ul>
</li>
<li>模型的2个重要组成部分:<ul>
<li>事件(定时器/DOM事件/Ajax)管理模块</li>
<li>回调队列</li>
</ul>
</li>
<li>模型的运转流程<ul>
<li>执行初始化代码, 将事件回调函数交给对应模块管理</li>
<li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li>
<li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li>
</ul>
</li>
</ol>
<pre><code class="javascript">function fn1() {
  console.log(&#39;fn1()&#39;)
}
fn1()
document.getElementById(&#39;btn&#39;).onclick = function () {
  console.log(&#39;点击了btn&#39;)
}
setTimeout(function () {
  console.log(&#39;定时器执行了&#39;)
}, 2000)
function fn2() {
  console.log(&#39;fn2()&#39;)
}
fn2()</code></pre>
<p>(2) 相关重要概念</p>
<ol>
<li>执行栈 execution stack</li>
</ol>
<ul>
<li>所有的代码都是在此空间中执行的</li>
</ul>
<ol start="2">
<li><p>浏览器内核 browser core</p>
<ul>
<li><p>js引擎模块(在主线程处理)</p>
</li>
<li><p>其它模块(在主/分线程处理)</p>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815141526.png" alt="运行原理图" class="lazyload"></p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>任务队列 task queue</p>
</li>
<li><p>消息队列 message queue</p>
</li>
<li><p>事件队列 event queue</p>
<p>上面这三个在同一个 callback queue </p>
</li>
</ol>
<ol start="6">
<li><p>事件轮询 event loop<br> 从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)</p>
</li>
<li><p>事件驱动模型 event-driven interaction model</p>
</li>
<li><p>请求响应模型 request-response model</p>
</li>
</ol>
<h3 id="6、H5-Web-Workers-多线程"><a href="#6、H5-Web-Workers-多线程" class="headerlink" title="6、H5 Web Workers(多线程)"></a>6、H5 Web Workers(多线程)</h3><p>(1) 介绍</p>
<ul>
<li>Web Workers 是 HTML5 提供的一个javascript多线程解决方案</li>
<li>我们可以将一些大计算量的代码交由web Worker运行而不冻结用户界面</li>
<li>但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</li>
</ul>
<p>(2) 相关API</p>
<ul>
<li>Worker: 构造函数, 加载分线程执行的js文件</li>
<li>Worker.prototype.onmessage: 用于接收另一个线程的回调函数</li>
<li>Worker.prototype.postMessage: 向另一个线程发送消息</li>
</ul>
<p>(3) 使用</p>
<ul>
<li>创建在分线程执行的js文件</li>
</ul>
<pre><code class="javascript">var onmessage =function (event){ //不能用函数声明
    console.log(&#39;onMessage()22&#39;);
    var upper = event.data.toUpperCase();//通过event.data获得发送来的数据
    postMessage( upper );//将获取到的数据发送会主线程
}</code></pre>
<ul>
<li>在主线程中的js中发消息并设置回调</li>
</ul>
<pre><code class="javascript">//创建一个Worker对象并向它传递将在新线程中执行的脚本的URL
var worker = new Worker(&quot;worker.js&quot;);  
//接收worker传过来的数据函数
worker.onmessage = function (event) {     
    console.log(event.data);             
};
//向worker发送数据
worker.postMessage(&quot;hello world&quot;);    </code></pre>
<p><img data-sizes="auto" data-src="https://cdn.jsdelivr.net/gh/wallleap/cdn/img/pic/illustration/20200815143823.png" alt="image-20200815143821391" class="lazyload"></p>
<p>(4) 应用练习</p>
<ul>
<li>直接在主线程</li>
</ul>
<pre><code class="javascript">&lt;input type=&quot;text&quot; placeholder=&quot;数值&quot; id=&quot;number&quot;&gt;
&lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 1 1 2 3 5 8    f(n) = f(n-1) + f(n-2)
function fibonacci(n) {
  return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2)  //递归调用
}
// console.log(fibonacci(7))
var input = document.getElementById(&#39;number&#39;)
document.getElementById(&#39;btn&#39;).onclick = function () {
  var number = input.value
  var result = fibonacci(number)
  alert(result)
}
&lt;/script&gt;</code></pre>
<ul>
<li><p>使用Worker在分线程</p>
<ul>
<li>主线程</li>
</ul>
<pre><code class="javascript">var input = document.getElementById(&#39;number&#39;)
document.getElementById(&#39;btn&#39;).onclick = function () {
  var number = input.value

  //创建一个Worker对象
  var worker = new Worker(&#39;worker.js&#39;)
  // 绑定接收消息的监听
  worker.onmessage = function (event) {
    console.log(&#39;主线程接收分线程返回的数据: &#39;+event.data)
    alert(event.data)
  }

  // 向分线程发送消息
  worker.postMessage(number)
  console.log(&#39;主线程向分线程发送数据: &#39;+number)
}
// console.log(this) // window</code></pre>
</li>
</ul>
<ul>
<li><p>分线程 worker.js</p>
<pre><code class="javascript">function fibonacci(n) {
return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2)  //递归调用
}

console.log(this)
this.onmessage = function (event) {
var number = event.data
console.log(&#39;分线程接收到主线程发送的数据: &#39;+number)
//计算
var result = fibonacci(number)
postMessage(result)
console.log(&#39;分线程向主线程返回数据: &#39;+result)
// alert(result)  alert是window的方法, 在分线程不能调用
// 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面
}</code></pre>
</li>
</ul>
<p>(5) 不足</p>
<ul>
<li>worker内代码不能操作DOM(更新UI)</li>
<li>不能跨域加载JS</li>
<li>不是每个浏览器都支持这个新特性</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="nexmoefont icon-right"></i></a>
    </nav>
  
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js,gh/nexmoe/nexmoe.github.io@latest/js/app.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!--<script src="/js/app.js?v=1599833537938"></script>-->


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>


 
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js"></script>
<script> 
!function(e,t,a){function n(){c(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o(),r()}function r(){for(var e=0;e<d.length;e++)d[e].alpha<=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)}function o(){var t="function"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),i(e)}}function i(e){var a=t.createElement("div");a.className="heart",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement("style");a.type="text/css";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName("head")[0].appendChild(a)}function s(){return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);
</script>

  





</body>

</html>
